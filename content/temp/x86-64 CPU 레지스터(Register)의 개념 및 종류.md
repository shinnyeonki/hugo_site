---
title: x86 64 CPU 레지스터(Register)의 개념 및 종류
date: 2024-03-20T14:24:00+09:00
lastmod: 2024-03-20T14:24:00+09:00
resource-path: temp/x86-64 CPU 레지스터(Register)의 개념 및 종류.md
aliases: 
tags:
  - cpu
  - register
---
32bit, 64bit 운영체제에서 32bit, 64bit 는 레지스터 및 데이터 경로의 크기 를 의미한다.  
위 예시에서 AH 는 8bit 운영체제와 호환되는 레지스터라고 이해하면 된다. 

 운영체제의 발전에 따라, 수행해야할 기능이 많아지면서  
많은 정보를 다룰 수 있도록 새로운 레지스터가 추가되고, 크기도 점점 커졌다.

 \*  E 는 Extended 의 약자. R은 왜 R인지 모르겠다..  
\* CPU의 아키텍쳐에 따라 레지스터의 종류가 다를 수 있다.

___

## **범용 레지스터**
====
범용 레지스터는 연산 결과의 임시 저장, 산술 및 논리 연산, 주소 색인 등 다양한 용도로 사용되는 다목적 레지스터이다.  
종류는 EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, EIP 가 있다.

하지만 이는 관례적으로 사용되는 용도별로 나눠놓은 것으로

범용 레지스터라는 이름과 같이 프로그래머의 의도, 또는 규약(**stdcall, **Thiscall...****) 따라 다르게 사용될 수 있다.

-   **EAX/RAX (Accumulator Register, 누산기 레지스터)**  
    산술, 논리 연산을 담당하는 레지스터로, 함수의 반환값이 이 레지스터에 저장된다.  
    -   **EAX 레지스터의 종류**  
        RAX: 64비트 (x86-64 아키텍처에서의 확장된 EAX)  
        EAX: 32비트 누산기 레지스터  
        AX: 16비트의 EAX 레지스터 하위 부분  
        AH: AX의 상위 8비트  
        AL: AX의 하위 8비트
-   **EBX/RBX (Base Register, 베이스 레지스터)**메모리 주소를 저장하기 위해 사용되는 레지스터.  
    종종 배열이나 문자열과 같은 데이터 구조에 접근하기 위한 기준 포인터로 사용된다.
    -   **EBX 레지스터의 종류**  
        RBX: 64비트 (x86-64 아키텍처에서의 확장된 EBX)  
        EBX: 32비트 베이스 레지스터  
        BX: 16비트의 EBX 레지스터 하위 부분  
        BH: BX의 상위 8비트  
        BL: BX의 하위 8비트
-   **ECX/RCX (Count Register, 카운트 레지스터)  
    **반복 작업에서 카운터 역할을 수행하는 레지스터이다.  
    loop 명령어 사용시 레지스터의 값을 하나씩 감소시키며, 0이 될때까지 반복 작업을 수행한다.
    -   **ECX 레지스터의 종류**  
        RCX: 64비트 (x86-64 아키텍처에서의 확장된 ECX)  
        ECX: 32비트 카운트 레지스터  
        CX: 16비트의 ECX 레지스터 하위 부분  
        CH: CX의 상위 8비트  
        CL: CX의 하위 8비트
-   **EDX/RDX (Data Register, 데이터 레지스터)  
    **EAX 레지스터와 함께 사용하여 큰 수를 연산을 하거나, 그 결과를 저장할 수 있는 레지스터이다.  
    64bit 더블워드 연산을 수행할 때에도 사용 가능하다. (div, mul)
    -   **EDX 레지스터의 종류**  
        RDX: 64비트 (x86-64 아키텍처에서의 확장된 EDX)  
        EDX: 32비트 데이터 레지스터  
        DX: 16비트의 EDX 레지스터 하위 부분  
        DH: DX의 상위 8비트  
        DL: DX의 하위 8비트

___

## **인덱스 레지스터**

메모리 내의 데이터 접근 및 조작에 **특화**된 레지스터로, SI, DI 는 x86 아키텍쳐에서 범용 레지스터로 분류되기도 한다.

-   **ESI/RSI (Source Index, 소스 인덱스 레지스터)**  
    데이터 복사, 문자열 연산, 입력/출력 처리 등의 작업에서 소스 데이터의 주소를 가리키는 데 사용된다.
    -   **ESI 레지스터의 종류**  
        RSI: 64비트 (x86-64 아키텍처에서의 확장된 ESI)  
        ESI: 32비트 소스 인덱스 레지스터  
        SI: 16비트의 ESI 레지스터 하위 부분
-   **EDI/RDI (Destination Index, 목적지 인덱스 레지스터)  
    **데이터 복사, 문자열 처리, 배열조작 등의 작업에서 목적지 데이터의 메모리 주소를 가리키는데 사용된다.
    -   **EDI 레지스터의 종류**  
        RDI: 64비트 (x86-64 아키텍처에서의 확장된 EDI)  
        EDI: 32비트 목적지 인덱스 레지스터  
        DI: 16비트의 EDI 레지스터 하위 부분

___

## **포인터 레지스터**

스택과 프로그램의 실행 흐름 관리에 사용되는 레지스터로, 메모리 주소가 저장된다.

-   **ESP/RSP (Stack Pointer, 스택 포인터 레지스터)  
    **프로그램의 스택 메모리 내에서, 현재 스택 최상단 주소를 저장하는 레지스터이다.  
    함수 호출, 지역 변수 관리, 함수 내 데이터 저장 및 복구 등의 작업에서 필수적으로 사용된다.
    -   **ESP 레지스터의 종류**  
        RSP: 64비트 (x86-64 아키텍처에서의 확장된 ESP)  
        ESP: 32비트 스택 포인터 레지스터.  
        SP: 16비트의 ESP 레지스터 하위 부분.
-   **EBP/RBP (Base Pointer, 베이스 포인터 레지스터)**함수내의 지역 변수와 인자에 일관되고, 쉽게 접근하기 위해 사용되는 포인터 역할 레지스터이다.  
    스택 내에서 접근할 부분의 메모리 주소를 저장한다.
    -   **EBP 레지스터의 종류**  
        RBP: 64비트 (x86-64 아키텍처에서의 확장된 EBP).  
        EBP: 32비트 베이스 포인터 레지스터.  
        BP: 16비트의 EBP 레지스터 하위 부분.
-   **EIP/RIP (Instruction Pointer, 명령 포인터)  
    **다음에 실행될 명령의 메모리 주소를 저장한다. 
    -   **EIP 레지스터의 종류**  
        RIP: 64비트 (x86-64 아키텍처)  
        EIP: 32비트

___

## **세그먼트 레지스터**

메모리를 다른 세그먼트로 나누어 관리하고, 각 세그먼트에 대한 기준 주소를 저장한다.

세그먼트를 이용함으로써, 물리 메모리를 효율적으로 사용하고 프로그램 간 메모리 격리를 가능하게 한다.  

-   **CS (Code Segment, 코드 세그먼트):** 현재 프로그램의 코드가 포함된 세그먼트의 주소를 저장하는 레지스터
-   **DS (Data Segment, 데이터 세그먼트):** 데이터가 포함된 세그먼트의 주소를 저장하는 레지스터
-   **SS (Stack Segment, 스택 세그먼트):** 스택이 포함된 세그먼트의 주소를 저장하는 레지스터
-   **ES, FS, GS:** 추가적인 데이터 세그먼트 주소를 저장하는 레지스터

___

## **플래그 레지스터**

연산의 결과를 나타내는 플래그들을 포함하고, 특정 프로세서 연산을 제어한다.

-   RFLAGS: 64비트 (x86-64 아키텍처)
-   EFLAGS: 32비트

1.  Zero Flag(ZF)  
    목적: 작업 결과가 0일 경우 설정한다.  
    사용: JZ(Jump-if-zero) 또는 JNZ(Jump-if-not-zero)와 같은 조건부 분기 지시에 일반적으로 사용된다.
2.  Sign Flag(SF)  
    목적: 작업 결과가 음수일 경우 설정한다.  
    사용: 부호화된 산술 연산에서 결과의 부호를 나타낸다.
3.  Carry Flag(CF)  
    목적: 산술 연산에서 가장 중요한 비트의 수행이 발생할 경우 설정한다(부호가 없는 연산에서 유용함).  
    사용: 최소 비트에서 다음 비트로의 오버플로를 나타내기 위해 다중 정밀도 산술에서 사용된다.
4.  Overflow Flag(OF)  
    목적: 산술 연산으로 인해 부호화된 오버플로가 발생할 경우 설정한다. 즉, 결과가 너무 커서 지정된 비트 수로 표시할 수 없다.  
    사용: 서명된 산술 연산에 중요하다.
5.  Parity Flag(PF)  
    목적: 결과에 설정된 비트 수가 짝수인지 설정한다.  
    사용: 오류 검사 및 단순 패리티 검사에 자주 사용된다.
6.  Auxiliary Carry Flag(AC)  
    목적: BCD(Binary Coded Decimal) 산술에서 사용되는 결과의 하위 절반부터 수행되는 수행이 있는지 설정한다.  
    용도: BCD 계산에서 특화된 산술 연산 및 특정 유형의 보정에 유용하다.
7.  Interrupt Enable/Disable Flag(IF)  
    목적: 하드웨어 인터럽트를 활성화하거나 비활성화하는 데 사용된다.  
    사용: CPU가 인터럽트 처리를 제어할 수 있다.
8.  Direction Flag(DF)  
    목적: 문자열 작업에서 처리 방향(증가 또는 감소)을 제어하기 위해 사용된다.  
    사용: 문자열 및 메모리 작업에서 데이터 블록을 통한 이동 방향을 제어한다.

___


<table data-ke-align="alignLeft"><tbody><tr><td>8-bit<br>(예:&nbsp;Intel&nbsp;8080,&nbsp;<br>Zilog&nbsp;Z80)</td><td>A (Accumulator), B, C, D, E, H, L, SP (Stack Pointer), PC (Program Counter)</td></tr><tr><td>16-bit<br>(예:&nbsp;Intel&nbsp;8086/8088)</td><td>AX, BX, CX, DX, SI, DI, BP, SP, CS, DS, ES, SS, IP (Instruction Pointer), Flags</td></tr><tr><td>32-bit<br>(예:&nbsp;Intel&nbsp;80386)</td><td>EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, CS, DS, ES, SS, FS, GS, EIP (Extended IP), EFlags</td></tr><tr><td>64-bit<br>(예:&nbsp;x86-64&nbsp;아키텍처)</td><td>RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, CS, DS, ES, SS, FS, GS, RIP (Register IP), RFlags, R8-R15</td></tr></tbody></table>

 \* 틀린 부분이 있으면 알려주세요
---
title: signal 차이 unix(macos) vs linux
resource-path: signal 차이 unix(macos) vs linux.md
keywords:
tags:
  - ai-content
  - system-programing
date: 2025-09-09T23:07:14+09:00
lastmod: 2025-10-23T04:34:07+09:00
---
## macOS와 Linux의 신호(Signal) 상세 분석

| 시그널 이름        | macOS 기본 동작     | macOS 설명                       | Linux 기본 동작       | Linux 설명 (Comment)                     | 차이점 / 비고                                                                                                                                                   |
| :------------ | :-------------- | :----------------------------- | :---------------- | :------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **SIGHUP**    | 프로세스 종료         | 터미널 라인 끊김                      | Term              | 제어 터미널에서 끊김 감지 또는 제어 프로세스 종료           | 설명은 유사하며, 둘 다 프로세스를 종료합니다.                                                                                                                                 |
| **SIGINT**    | 프로세스 종료         | 프로그램 인터럽트                      | Term              | 키보드로부터의 인터럽트                           | 유사하며, 둘 다 프로세스를 종료하며, 주로 Ctrl+C로 발생합니다.                                                                                                                    |
| **SIGQUIT**   | 코어 이미지 생성       | 프로그램 종료                        | Core              | 키보드로부터의 종료                             | 둘 다 코어 덤프를 생성하고 종료합니다.                                                                                                                                     |
| **SIGILL**    | 코어 이미지 생성       | 불법 명령어                         | Core              | 불법 명령어 (Illegal Instruction)           | 둘 다 코어 덤프를 생성합니다.                                                                                                                                          |
| **SIGTRAP**   | 코어 이미지 생성       | 트레이스 트랩                        | Core              | 트레이스/브레이크포인트 트랩                        | 둘 다 코어 덤프를 생성합니다.                                                                                                                                          |
| **SIGABRT**   | 코어 이미지 생성       | 프로그램 중단 (이전 SIGIOT)            | Core              | abort(3)로부터의 중단 시그널                    | 둘 다 코어 덤프를 생성합니다. Linux는 `abort(3)`로부터 발생한다고 명시합니다.                                                                                                        |
| **SIGEMT**    | 코어 이미지 생성       | 명령어 에뮬레이트 실행                   | Term              | 에뮬레이터 트랩                               | **차이점:** macOS는 코어 이미지를 생성하지만, Linux는 프로세스를 종료합니다. 이는 "에뮬레이터 트랩" 조건에 대한 다른 처리를 나타낼 수 있습니다. Linux는 이 시그널에 대한 명시적인 코어 덤프 동작이 없습니다.                           |
| **SIGFPE**    | 코어 이미지 생성       | 부동 소수점 예외                      | Core              | 부동 소수점 예외                              | 둘 다 코어 덤프를 생성합니다.                                                                                                                                          |
| **SIGKILL**   | 프로세스 종료         | 프로그램 강제 종료                     | Term              | 강제 종료 시그널                              | 둘 다 프로세스를 종료하며, 포착하거나 무시할 수 없습니다.                                                                                                                          |
| **SIGBUS**    | 코어 이미지 생성       | 버스 에러                          | Core              | 버스 에러 (잘못된 메모리 접근)                     | 둘 다 코어 덤프를 생성합니다.                                                                                                                                          |
| **SIGSEGV**   | 코어 이미지 생성       | 세그멘테이션 위반                      | Core              | 유효하지 않은 메모리 참조                         | 둘 다 코어 덤프를 생성합니다.                                                                                                                                          |
| **SIGSYS**    | 코어 이미지 생성       | 존재하지 않는 시스템 콜 호출               | Core              | 잘못된 시스템 콜 (SVr4); seccomp(2) 참조        | 둘 다 코어 덤프를 생성합니다. Linux는 `seccomp(2)`에 대한 추가 컨텍스트를 제공합니다.                                                                                                  |
| **SIGPIPE**   | 프로세스 종료         | 리더 없는 파이프에 쓰기                  | Term              | 파이프 깨짐: 리더 없는 파이프에 쓰기; pipe(7) 참조      | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGALRM**   | 프로세스 종료         | 실시간 타이머 만료                     | Term              | alarm(2)로부터의 타이머 시그널                   | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGTERM**   | 프로세스 종료         | 소프트웨어 종료 시그널                   | Term              | 종료 시그널                                 | 둘 다 프로세스를 종료합니다. 이것은 기본 종료 시그널입니다.                                                                                                                         |
| **SIGURG**    | 시그널 무시          | 소켓에 긴급 조건 발생                   | Ign               | 소켓의 긴급 조건 (4.2BSD)                     | 둘 다 시그널을 무시합니다.                                                                                                                                            |
| **SIGSTOP**   | 프로세스 중지         | 중지 (포착하거나 무시할 수 없음)            | Stop              | 프로세스 중지                                | 둘 다 프로세스를 중지하며 포착하거나 무시할 수 없습니다.                                                                                                                           |
| **SIGTSTP**   | 프로세스 중지         | 키보드로부터 발생한 중지 시그널              | Stop              | 터미널에서 입력된 중지                           | 둘 다 프로세스를 중지하며, 주로 Ctrl+Z로 발생합니다.                                                                                                                          |
| **SIGCONT**   | 시그널 무시          | 중지 후 계속 진행                     | Cont              | 중지 후 계속 진행                             | 둘 다 중지된 프로세스를 계속 진행합니다.                                                                                                                                    |
| **SIGCHLD**   | 시그널 무시          | 자식 상태 변경됨                      | Ign               | 자식 프로세스 중지 또는 종료                       | 둘 다 기본적으로 시그널을 무시합니다.                                                                                                                                      |
| **SIGTTIN**   | 프로세스 중지         | 제어 터미널에서 백그라운드 읽기 시도           | Stop              | 백그라운드 프로세스를 위한 터미널 입력                  | 둘 다 프로세스를 중지합니다.                                                                                                                                           |
| **SIGTTOU**   | 프로세스 중지         | 제어 터미널에 백그라운드 쓰기 시도            | Stop              | 백그라운드 프로세스를 위한 터미널 출력                  | 둘 다 프로세스를 중지합니다.                                                                                                                                           |
| **SIGIO**     | 시그널 무시          | 디스크립터에서 I/O 가능 (fcntl(2) 참조)   | Term              | I/O 이제 가능 (4.2BSD)                     | **차이점:** macOS는 기본적으로 이 시그널을 무시하는 반면, Linux는 프로세스를 종료합니다. Linux는 또한 `SIGPOLL`의 동의어라고 명시합니다. 이는 중요한 행동 차이입니다.                                               |
| **SIGXCPU**   | 프로세스 종료         | CPU 시간 제한 초과 (setrlimit(2) 참조) | Core              | CPU 시간 제한 초과 (4.2BSD); setrlimit(2) 참조 | **차이점:** macOS는 프로세스를 종료하는 반면, Linux는 코어 덤프를 생성합니다. 둘 다 `setrlimit(2)`를 인정합니다.                                                                             |
| **SIGXFSZ**   | 프로세스 종료         | 파일 크기 제한 초과 (setrlimit(2) 참조)  | Core              | 파일 크기 제한 초과 (4.2BSD); setrlimit(2) 참조  | **차이점:** macOS는 프로세스를 종료하는 반면, Linux는 코어 덤프를 생성합니다. 둘 다 `setrlimit(2)`를 인정합니다.                                                                             |
| **SIGVTALRM** | 프로세스 종료         | 가상 시간 알람 (setitimer(2) 참조)     | Term              | 가상 알람 시계 (4.2BSD)                      | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGPROF**   | 프로세스 종료         | 프로파일링 타이머 알람 (setitimer(2) 참조) | Term              | 프로파일링 타이머 만료                           | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGWINCH**  | 시그널 무시          | 윈도우 크기 변경                      | Ign               | 윈도우 크기 변경 시그널 (4.3BSD, Sun)            | 둘 다 시그널을 무시합니다.                                                                                                                                            |
| **SIGINFO**   | 시그널 무시          | 키보드로부터의 상태 요청                  | - (`SIGPWR`의 동의어) | `SIGPWR`의 동의어 (기본적으로 Term)             | **차이점:** macOS는 `SIGINFO`를 상태 요청(예: Ctrl+T)을 위한 별개의 무시 가능한 시그널로 처리합니다. Linux는 `SIGINFO`를 `SIGPWR`의 동의어로 나열하며, 이는 기본적으로 종료됩니다. 이름과 기본 동작 모두에서 중요한 차이가 있습니다. |
| **SIGUSR1**   | 프로세스 종료         | 사용자 정의 시그널 1                   | Term              | 사용자 정의 시그널 1                           | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGUSR2**   | 프로세스 종료         | 사용자 정의 시그널 2                   | Term              | 사용자 정의 시그널 2                           | 둘 다 프로세스를 종료합니다.                                                                                                                                           |
| **SIGCLD**    | **(macOS에 없음)** |                                | Ign               | `SIGCHLD`의 동의어                         | **Linux 전용:** `SIGCHLD`의 동의어입니다. macOS에는 `SIGCLD`가 별개의 시그널로 나열되지 않습니다.                                                                                     |
| **SIGIOT**    | **(macOS에 없음)** |                                | Core              | IOT 트랩. `SIGABRT`의 동의어                 | **Linux 전용:** `SIGABRT`의 동의어로 나열됩니다. macOS는 `SIGABRT`가 "이전 SIGIOT"였다고 언급하지만, `SIGIOT`를 별개의 시그널로 나열하지는 않습니다.                                                |
| **SIGLOST**   | **(macOS에 없음)** |                                | Term              | 파일 잠금 손실 (사용되지 않음)                     | **Linux 전용:** 파일 잠금과 관련된 시그널이며 "사용되지 않음"으로 나열됩니다. macOS에는 없습니다.                                                                                            |
| **SIGPOLL**   | **(macOS에 없음)** |                                | Term              | 폴링 가능한 이벤트 (Sys V); `SIGIO`의 동의어       | **Linux 전용:** `SIGIO`의 동의어입니다. macOS에는 없습니다.                                                                                                               |
| **SIGPWR**    | **(macOS에 없음)** |                                | Term              | 전원 장애 (System V)                       | **Linux 전용:** 전원 장애 이벤트에 대한 시그널입니다. Linux의 `SIGINFO`는 이것의 동의어이며, 이는 macOS의 `SIGINFO`와는 큰 차이입니다.                                                            |
| **SIGSTKFLT** | **(macOS에 없음)** |                                | Term              | 보조 프로세서의 스택 오류 (사용되지 않음)               | **Linux 전용:** 보조 프로세서의 스택 오류에 대한 시그널이며 "사용되지 않음"으로 나열됩니다. macOS에는 없습니다.                                                                                    |
| **SIGUNUSED** | **(macOS에 없음)** |                                | Core              | `SIGSYS`와 동의어                          | **Linux 전용:** `SIGSYS`의 동의어입니다. macOS에는 없습니다.                                                                                                              |

---

### 주요 차이점 요약:

1.  **특정 시그널의 기본 동작:**
    *   **SIGEMT:** macOS (코어 덤프) vs. Linux (종료).
    *   **SIGIO:** macOS (무시) vs. Linux (종료).
    *   **SIGXCPU:** macOS (종료) vs. Linux (코어 덤프).
    *   **SIGXFSZ:** macOS (종료) vs. Linux (코어 덤프).

2.  **`SIGINFO`와 `SIGPWR`:**
    *   **macOS `SIGINFO`:** 상태 요청(예: Ctrl+T)을 위한 별개의 시그널이며, 기본적으로 무시됩니다.
    *   **Linux `SIGINFO`:** `SIGPWR`(전원 장애)의 *동의어*이며, 기본적으로 종료됩니다. 이는 기능적으로 중요한 차이입니다.

3.  **Linux 전용 시그널 (macOS에는 없음):**
    *   **SIGCLD:** `SIGCHLD`의 동의어.
    *   **SIGIOT:** `SIGABRT`의 동의어 (macOS는 `SIGABRT`가 이전에 `SIGIOT`였다고 언급하지만 별개의 시그널로 나열하지는 않습니다).
    *   **SIGLOST:** 파일 잠금 손실 (사용되지 않음).
    *   **SIGPOLL:** `SIGIO`의 동의어.
    *   **SIGPWR:** 전원 장애.
    *   **SIGSTKFLT:** 보조 프로세서의 스택 오류 (사용되지 않음).
    *   **SIGUNUSED:** `SIGSYS`의 동의어.

4.  **시그널 번호:** 일반적인 시그널의 이름은 대부분 일치하지만, 일부 시그널의 숫자 값은 두 운영 체제 간에 다를 수 있습니다. (제공된 목록에는 macOS의 번호만 표시되어 있습니다.) 예를 들어, `SIGINFO`는 macOS에서 29입니다.

### 1. 신호(Signal)란 무엇인가?

컴퓨팅에서 **신호(Signal)**는 운영체제(커널)가 특정 프로세스에게 비동기적인 이벤트가 발생했음을 알리기 위해 사용하는 제한된 형태의 **프로세스 간 통신(IPC, Inter-Process Communication)** 메커니즘입니다. 신호는 종종 "소프트웨어 인터럽트(Software Interrupt)"라고도 불리며, 프로세스가 정상적인 실행 흐름을 잠시 멈추고 해당 이벤트를 처리하도록 유도합니다.

#### 신호의 발생 원인
신호는 다양한 상황에서 발생할 수 있습니다.
1.  **사용자의 직접적인 요청:** 사용자가 키보드 조합(예: `Ctrl+C` -> SIGINT, `Ctrl+Z` -> SIGTSTP)을 통해 현재 실행 중인 프로세스에 신호를 보낼 때.
2.  **하드웨어 예외:** 프로세스가 잘못된 연산(예: 0으로 나누기 -> SIGFPE)을 하거나, 허용되지 않은 메모리 공간에 접근(-> SIGSEGV)하는 등 하드웨어 수준의 오류가 발생했을 때.
3.  **다른 프로세스의 요청:** 한 프로세스가 `kill()` 시스템 콜을 사용하여 다른 프로세스에 특정 신호를 보낼 때 (예: `kill -9 [PID]`).
4.  **운영체제(커널)의 알림:** 자식 프로세스가 종료되었을 때(-> SIGCHLD), 파이프의 읽기 쪽이 닫혔는데 쓰려고 할 때(-> SIGPIPE), 알람 타이머가 만료되었을 때(-> SIGALRM) 등 커널이 특정 상태 변화를 프로세스에 알릴 때.

#### 신호에 대한 프로세스의 반응 (Signal Disposition)
프로세스는 신호를 수신했을 때 다음 세 가지 행동 중 하나를 취할 수 있습니다.
1.  **기본 행동(Default Action) 수행:** 각 신호에는 미리 정해진 기본 행동이 있습니다. 이 행동은 프로세스 종료, 코어 덤프 생성 후 종료, 프로세스 중지, 신호 무시 등 다양합니다.
2.  **신호 잡기(Catch the Signal):** 프로그래머가 특정 신호에 대한 처리 함수(Signal Handler)를 미리 등록해두면, 해당 신호가 도착했을 때 프로세스는 실행을 잠시 멈추고 등록된 핸들러 함수를 실행합니다. 핸들러 실행이 끝나면 원래 실행 흐름으로 복귀합니다. 이를 통해 프로세스는 종료되지 않고 특정 상황에 능동적으로 대처할 수 있습니다 (예: SIGINT 수신 시 임시 파일 정리 후 종료).
3.  **신호 무시(Ignore the Signal):** 프로세스는 특정 신호를 무시하도록 설정할 수 있습니다. 이 경우 해당 신호가 도착해도 아무런 행동도 취하지 않습니다.

단, 두 가지 예외적인 신호가 있습니다. **`SIGKILL`**과 **`SIGSTOP`**은 어떤 경우에도 잡거나(Catch) 무시할(Ignore) 수 없습니다. 이들은 커널이 프로세스를 확실하게 제어하기 위한 최후의 수단으로, 항상 기본 행동(각각 프로세스 강제 종료, 프로세스 정지)을 수행합니다.

### 2. 주요 신호(Signal) 상세 설명

두 운영체제에서 공통적으로 사용되는 중요한 신호들을 기능별로 묶어 상세히 설명하겠습니다.

#### (1) 프로세스 종료 관련 신호

이 신호들은 주로 프로세스를 정상적으로 또는 강제적으로 종료시키는 데 사용됩니다.

*   **SIGHUP (1):** Hang Up. 과거 모뎀 시절, 통신 연결이 끊겼을 때 보내던 신호에서 유래했습니다. 현대에는 터미널 세션이 종료되거나, 데몬(daemon) 프로세스에게 **설정 파일을 다시 읽어오도록** 지시하는 용도로 널리 사용됩니다. `systemctl reload`나 `service nginx reload`와 같은 명령어들이 내부적으로 SIGHUP을 보냅니다.
*   **SIGINT (2):** Interrupt. 사용자가 키보드에서 `Ctrl+C`를 눌렀을 때 터미널이 전송하는 신호입니다. "프로그램을 중단해달라"는 정중한 요청으로, 대부분의 프로그램은 이 신호를 받으면 진행 중인 작업을 정리하고(예: 임시 파일 삭제) 종료합니다.
*   **SIGQUIT (3):** Quit. 사용자가 `Ctrl+\\`를 눌렀을 때 전송됩니다. SIGINT보다 더 강한 종료 요청이며, 기본 동작은 **[코어 덤프(Core Dump)](코어%20덤프(Core%20Dump).md)를 생성하고 종료**하는 것입니다. 코어 덤프는 프로세스가 비정상 종료될 당시의 메모리 상태를 담은 파일로, 디버깅에 매우 유용합니다.
*   **SIGTERM (15):** Terminate. 가장 일반적인 "소프트웨어 종료 신호"입니다. `kill` 명령어에 PID만 입력하면 기본적으로 이 신호가 전송됩니다. SIGINT와 마찬가지로 "정리하고 종료하라"는 요청이며, 프로세스가 이 신호를 잡아서 안전하게 종료할 시간을 가질 수 있습니다. 가장 표준적이고 권장되는 종료 방식입니다.
*   **SIGKILL (9):** Kill. **"절대적이고 무자비한 종료 명령"**입니다. 이 신호는 프로세스가 무시하거나 핸들러로 잡을 수 없습니다. 커널이 직접 프로세스의 실행을 중단시키기 때문에, 프로세스는 어떠한 정리 작업도 수행할 수 없습니다. 좀비 프로세스나 응답 없는 프로세스를 강제로 제거할 때 최후의 수단으로 사용됩니다. `kill -9`로 유명합니다.

#### (2) 하드웨어 및 소프트웨어 예외 관련 신호

프로세스가 잘못된 연산을 시도했을 때 커널에 의해 생성되는 신호들입니다.

*   **SIGSEGV (11):** Segmentation Violation. "세그멘테이션 오류"로, C/C++ 개발자에게 가장 익숙한 신호입니다. 프로세스가 자신에게 할당되지 않은 메모리 영역에 접근하거나, 읽기 전용 영역에 쓰려고 할 때 발생합니다. 주로 포인터 관련 버그로 인해 발생합니다.
*   **SIGILL (4):** Illegal Instruction. 프로세스가 CPU가 이해할 수 없는 기계어 코드(예: 손상된 코드, 존재하지 않는 명령어)를 실행하려고 할 때 발생합니다.
*   **SIGFPE (8):** Floating-Point Exception. 부동소수점 연산에서 예외가 발생했을 때(예: 0으로 나누기, 오버플로우) 전송됩니다. 이름과 달리 정수 나눗셈에서 0으로 나눌 때도 이 신호가 발생할 수 있습니다.
*   **SIGBUS (10, 7 on Linux):** Bus Error. SIGSEGV와 유사하지만, 원인이 다릅니다. SIGSEGV가 논리적인 메모리 접근 권한 위반이라면, SIGBUS는 물리적으로 유효하지 않은 주소에 접근하려 할 때 발생합니다. (예: CPU의 정렬(alignment) 요구사항 위반, 존재하지 않는 물리 메모리 주소 접근).
*   **SIGABRT (6):** Abort. `abort()` 함수 호출을 통해 프로세스가 자기 자신에게 보내는 신호입니다. 복구 불가능한 심각한 내부 오류를 감지했을 때, 프로그램 스스로 비정상 종료를 선택하는 용도로 사용됩니다. 기본 동작은 코어 덤프 생성 후 종료입니다.

#### (3) 작업 제어(Job Control) 관련 신호

터미널 셸 환경에서 프로세스의 실행을 일시 중지하거나 재개할 때 사용됩니다.

*   **SIGTSTP (18, 20 on Linux):** Stop from Terminal. 사용자가 키보드에서 `Ctrl+Z`를 눌렀을 때 전송되는 신호입니다. SIGSTOP과 달리 "정중한 중지 요청"이므로 프로세스가 무시하거나 처리할 수 있습니다.
*   **SIGSTOP (17, 19 on Linux):** Stop. `SIGKILL`의 중지 버전입니다. 프로세스가 이 신호를 무시하거나 핸들러로 잡을 수 없습니다. 운영체제는 이 신호를 통해 어떤 프로세스든 강제로 실행을 중지시킬 수 있습니다.
*   **SIGCONT (19, 18 on Linux):** Continue. `SIGSTOP`이나 `SIGTSTP`에 의해 중지된 프로세스의 실행을 재개시키는 신호입니다. 셸에서 `fg` 또는 `bg` 명령어를 사용하면 이 신호가 전송됩니다.
*   **SIGTTIN (21) / SIGTTOU (22):** 백그라운드 프로세스가 제어 터미널에 대한 입/출력을 시도할 때 발생합니다. 기본 동작은 프로세스를 중지시키는 것입니다. 이는 여러 백그라운드 작업이 동시에 터미널을 사용하려 할 때 발생하는 혼란을 방지하기 위함입니다.

#### (4) 기타 주요 신호

*   **SIGCHLD (20, 17 on Linux):** Child Status Changed. 자식 프로세스가 종료되거나, 중지되거나, 재개될 때 부모 프로세스에게 전송되는 신호입니다. 부모 프로세스는 이 신호를 통해 자식의 상태 변화를 감지하고, `wait()` 계열 함수를 호출하여 좀비 프로세스가 되는 것을 방지할 수 있습니다.
*   **SIGPIPE (13):** Pipe. 파이프(pipe)의 읽기 쪽(reader)이 닫혔는데 쓰기 쪽(writer)에서 계속 쓰려고 할 때 발생합니다. 예를 들어, `ls -R / | head -n 10` 명령어에서 `head`가 10줄을 읽고 종료되면, `ls`는 더 이상 데이터를 쓸 곳이 없어지고 SIGPIPE 신호를 받고 종료됩니다.
*   **SIGALRM (14):** Alarm. `alarm()` 함수 호출로 설정된 실시간 타이머가 만료되었을 때 발생하는 신호입니다.
*   **SIGUSR1 (30, 10 on Linux) / SIGUSR2 (31, 12 on Linux):** User-defined Signal. 이 두 신호는 시스템에 의해 특정 용도가 정해져 있지 않습니다. 개발자가 애플리케이션의 필요에 따라 자유롭게 의미를 부여하고 프로세스 간 통신에 사용할 수 있도록 예약된 신호입니다.

---

### 3. macOS와 Linux의 신호(Signal) 차이점

두 운영체제는 POSIX 표준을 준수하기 때문에 대부분의 핵심 신호(SIGHUP, SIGINT, SIGKILL, SIGTERM 등)는 이름과 기능이 동일합니다. 하지만 각 운영체제의 역사적 배경(macOS는 BSD 기반, Linux는 System V와 독자적 발전)으로 인해 몇 가지 미묘하지만 중요한 차이점이 존재합니다.

#### (1) 신호 번호(Signal Number)의 차이

가장 눈에 띄는 차이점 중 하나는 일부 신호의 번호가 다르다는 것입니다.

| Signal Name | macOS Number | Linux Number |
|-------------|--------------|--------------|
| SIGBUS      | 10           | 7            |
| SIGCHLD     | 20           | 17           |
| SIGSTOP     | 17           | 19           |
| SIGTSTP     | 18           | 20           |
| SIGCONT     | 19           | 18           |
| SIGUSR1     | 30           | 10           |
| SIGUSR2     | 31           | 12           |

**중요성:** 이 차이점 때문에 **프로그래머는 절대로 코드에 신호 번호를 하드코딩해서는 안 됩니다.** 예를 들어, `kill(pid, 9)` 대신 `kill(pid, SIGKILL)`과 같이 항상 표준 헤더 파일에 정의된 심볼릭 이름(symbolic name)을 사용해야 이식성 있는 코드를 작성할 수 있습니다.

#### (2) 기본 동작(Default Action)의 차이

제공된 표에서 몇몇 신호의 기본 동작이 다르게 명시되어 있습니다.

*   **SIGXCPU (CPU 시간 초과), SIGXFSZ (파일 크기 제한 초과):**
    *   **macOS:** `terminate process` (프로세스 종료)
    *   **Linux:** `Core` (코어 덤프 생성 후 종료)
    *   **분석:** 이는 운영체제의 기본 철학 차이를 보여줍니다. Linux는 자원 제한을 초과한 경우, 원인 분석을 위한 디버깅 정보(코어 덤프)를 남기는 것을 기본으로 합니다. 반면 macOS는 더 간결하게 프로세스를 종료시키는 것을 기본 동작으로 설정했습니다. 물론 이 동작은 `setrlimit()` 시스템 콜을 통해 변경할 수 있습니다.

*   **SIGIO (I/O 가능):**
    *   **macOS:** `discard signal` (신호 무시)
    *   **Linux:** `Term` (프로세스 종료)
    *   **분석:** 이 신호는 비동기 I/O를 위해 사용되는데, 기본 동작이 다르다는 것은 이 기능을 사용할 때 운영체제별로 핸들러를 반드시 등록해야 함을 시사합니다. Linux의 경우 핸들러를 등록하지 않으면 프로세스가 예기치 않게 종료될 수 있습니다.

#### (3) 운영체제 고유 또는 역사적 신호의 차이

*   **macOS (BSD 계열)의 특징적 신호:**
    *   **SIGINFO (29):** BSD 시스템에서 유래한 신호로, 터미널에서 `Ctrl+T`를 누르면 전송됩니다. 실행 중인 프로세스의 상태 정보(예: `dd` 명령어의 진행 상황)를 출력하도록 요청하는 데 사용됩니다. Linux에는 기본적으로 같은 이름의 신호가 없지만, 일부 시스템에서는 `SIGPWR`에 매핑되기도 합니다.
    *   **SIGEMT (7):** Emulate Instruction Trap. PDP-11과 같은 구형 하드웨어에서 사용되던 에뮬레이터 트랩 신호입니다. 현대적인 시스템에서는 거의 사용되지 않지만, BSD의 역사적 유산으로 macOS 목록에 남아있습니다. Linux 목록에도 존재는 하지만 비표준으로 취급됩니다.

*   **Linux의 특징적 신호:**
    *   **SIGPWR (Power Failure):** System V에서 유래한 신호로, 시스템 전원에 문제가 생겼을 때(예: UPS 배터리 부족) 시스템 관리 데몬에게 알려 안전한 종료 절차를 밟도록 하는 데 사용됩니다.
    *   **SIGSTKFLT (Stack Fault on coprocessor):** 과거 수치 연산 보조 프로세서(coprocessor)의 스택 오류를 위한 신호였으나, 현대 x86 아키텍처에서는 사용되지 않아 사실상 사장되었습니다.
    *   **SIGPOLL:** System V의 `SIGIO`와 동일한 역할을 하는 신호입니다. Linux는 두 이름 모두를 지원하여 호환성을 높였습니다.
    *   **SIGCLD, SIGIOT:** 각각 `SIGCHLD`, `SIGABRT`의 오래된 동의어(synonym)입니다. 과거 다른 Unix 버전과의 호환성을 위해 남아있습니다.

---

### 4. 결론

macOS와 Linux의 신호 시스템은 POSIX라는 강력한 표준 아래에서 높은 수준의 호환성을 보입니다. 개발자들은 `SIGINT`, `SIGTERM`, `SIGSEGV`와 같은 핵심 신호들이 두 플랫폼에서 거의 동일하게 작동할 것이라고 기대할 수 있습니다.

하지만 그 기저에는 **BSD(macOS)와 System V(Linux)**라는 서로 다른 UNIX 계보의 영향이 남아있습니다. 이로 인해 일부 비표준적이거나 역사적인 신호(`SIGINFO`, `SIGPWR`)의 존재 유무, 특정 오류 상황에서의 기본 행동(`SIGXCPU`의 코어 덤프 여부), 그리고 동의어의 사용 등에서 미세한 차이가 나타납니다.

따라서 높은 이식성이 요구되는 시스템 프로그래밍을 할 때는 POSIX 표준에 정의된 신호들을 중심으로 코드를 작성하고, 특정 운영체제에만 의존적인 신호의 사용은 가급적 피하는 것이 바람직합니다. 제공된 두 표는 이러한 차이점과 공통점을 명확하게 보여주는 훌륭한 자료입니다.

---
title: Spec Driven Development
date: 2025-10-13T13:36:25+09:00
lastmod: 2025-10-13T13:45:24+09:00
resource-path: Spec-Driven Development.md
aliases:
tags:
  - ai-content
---
## 권력의 역전

수십 년간 코드가 왕이었습니다. 명세는 코드를 보조하는 역할을 했습니다. 코딩이라는 "진짜 작업"이 시작되면 지었다가 허물어버리는 비계와 같았습니다. 우리는 개발을 안내하기 위해 제품 요구사항 문서(PRD)를 작성했고, 구현에 정보를 제공하기 위해 설계 문서를 만들었으며, 아키텍처를 시각화하기 위해 다이어그램을 그렸습니다. 하지만 이것들은 항상 코드 자체에 종속적이었습니다. 코드가 진실이었습니다. 다른 모든 것은 기껏해야 좋은 의도에 불과했습니다. 코드는 진실의 원천이었고, 코드가 발전함에 따라 명세는 그 속도를 거의 따라가지 못했습니다. 자산(코드)과 구현이 하나로 묶여 있기 때문에, 코드로부터 빌드하지 않고서는 병렬적인 구현을 갖기란 쉽지 않습니다.

명세 주도 개발(SDD)은 이 권력 구조를 뒤집습니다. 명세가 코드를 보조하는 것이 아니라, 코드가 명세를 보조합니다. 제품 요구사항 문서(PRD)는 구현을 위한 가이드가 아니라, 구현을 생성하는 원천입니다. 기술 계획은 코딩에 정보를 제공하는 문서가 아니라, 코드를 생산하는 정밀한 정의입니다. 이것은 우리가 소프트웨어를 구축하는 방식에 대한 점진적인 개선이 아닙니다. 무엇이 개발을 주도하는가에 대한 근본적인 재고입니다.

명세와 구현 사이의 격차는 소프트웨어 개발 초기부터 고질적인 문제였습니다. 우리는 더 나은 문서, 더 상세한 요구사항, 더 엄격한 프로세스로 이 격차를 메우려 노력했습니다. 이러한 접근 방식들은 그 격차를 필연적인 것으로 받아들이기 때문에 실패합니다. 격차를 좁히려 할 뿐, 결코 제거하지는 못합니다. SDD는 명세와 명세로부터 파생된 구체적인 구현 계획을 실행 가능하게 만듦으로써 그 격차를 제거합니다. 명세와 구현 계획이 코드를 생성할 때, 격차는 존재하지 않습니다. 오직 변환만 있을 뿐입니다.

이러한 변환은 이제 AI가 복잡한 명세를 이해하고 구현하며, 상세한 구현 계획을 만들 수 있게 되었기 때문에 가능해졌습니다. 하지만 구조 없이 원시적인 AI 생성은 혼돈을 낳습니다. SDD는 작동하는 시스템을 생성할 만큼 정밀하고, 완전하며, 모호하지 않은 명세와 그에 따른 구현 계획을 통해 그 구조를 제공합니다. 명세가 주요 산출물이 됩니다. 코드는 특정 언어와 프레임워크로 표현된 (구현 계획에 따른) 구현체가 됩니다.

이 새로운 세계에서 소프트웨어를 유지보수한다는 것은 명세를 발전시키는 것을 의미합니다. 개발팀의 의도는 자연어("**의도 주도 개발**"), 디자인 자산, 핵심 원칙 및 기타 가이드라인으로 표현됩니다. 개발의 **공용어(lingua franca)**는 더 높은 수준으로 이동하고, 코드는 마지막 단계를 처리하는 접근 방식이 됩니다.

디버깅은 잘못된 코드를 생성하는 명세와 그 구현 계획을 수정하는 것을 의미합니다. 리팩토링은 명확성을 위해 명세를 재구성하는 것을 의미합니다. 전체 개발 워크플로우는 명세를 중심적인 진실의 원천으로 재편성되며, 구현 계획과 코드는 지속적으로 재생성되는 결과물이 됩니다. 새로운 기능으로 앱을 업데이트하거나, 창의적인 존재로서 새로운 병렬 구현을 만드는 것은 명세를 재검토하고 새로운 구현 계획을 만드는 것을 의미합니다. 따라서 이 프로세스는 0 -> 1, (1', ...), 2, 3, N의 과정을 거칩니다.

개발팀은 창의성, 실험, 비판적 사고에 집중하게 됩니다.

## 실제 SDD 워크플로우

워크플로우는 종종 모호하고 불완전한 아이디어에서 시작됩니다. AI와의 반복적인 대화를 통해 이 아이디어는 포괄적인 PRD가 됩니다. AI는 명확한 질문을 하고, 엣지 케이스를 식별하며, 정밀한 인수 기준을 정의하는 데 도움을 줍니다. 전통적인 개발에서 며칠간의 회의와 문서 작업이 필요했던 일이, 집중적인 명세 작업 몇 시간 만에 이루어집니다. 이는 전통적인 소프트웨어 개발 수명주기(SDLC)를 변화시킵니다. 요구사항과 설계는 별개의 단계가 아니라 지속적인 활동이 됩니다. 이는 팀이 검토한 명세를 표현하고 버전 관리하며, 브랜치를 생성하고 병합하는 **팀 프로세스**를 지원합니다.

제품 관리자가 인수 기준을 업데이트하면, 구현 계획은 영향을 받는 기술적 결정을 자동으로 표시합니다. 아키텍트가 더 나은 패턴을 발견하면, PRD는 새로운 가능성을 반영하여 업데이트됩니다.

이 명세 과정 전반에 걸쳐, 리서치 에이전트가 중요한 컨텍스트를 수집합니다. 라이브러리 호환성, 성능 벤치마크, 보안 영향을 조사합니다. 조직의 제약 조건은 자동으로 발견되고 적용됩니다. 회사의 데이터베이스 표준, 인증 요구사항, 배포 정책 등이 모든 명세에 원활하게 통합됩니다.

PRD로부터 AI는 요구사항을 기술적 결정에 매핑하는 구현 계획을 생성합니다. 모든 기술 선택에는 문서화된 근거가 있습니다. 모든 아키텍처 결정은 특정 요구사항으로 거슬러 올라갑니다. 이 과정 전반에 걸쳐, 일관성 검증이 지속적으로 품질을 향상시킵니다. AI는 일회성 관문으로서가 아니라 지속적인 개선 과정으로서 명세의 모호성, 모순, 격차를 분석합니다.

코드 생성은 명세와 그 구현 계획이 충분히 안정화되는 즉시 시작되지만, "완전"할 필요는 없습니다. 초기 생성물은 명세가 실제로 의미가 있는지 테스트하는 탐색적일 수 있습니다. 도메인 개념은 데이터 모델이 됩니다. 사용자 스토리는 API 엔드포인트가 됩니다. 인수 시나리오는 테스트가 됩니다. 이는 명세를 통해 개발과 테스트를 통합합니다. 테스트 시나리오는 코드 작성 후에 작성되는 것이 아니라, 구현과 테스트를 모두 생성하는 명세의 일부입니다.

피드백 루프는 초기 개발을 넘어 확장됩니다. 프로덕션 환경의 지표와 장애는 단순히 긴급 수정(hotfix)을 유발하는 데 그치지 않고, 다음 재생성을 위해 명세를 업데이트합니다. 성능 병목 현상은 새로운 비기능적 요구사항이 됩니다. 보안 취약점은 모든 미래 생성물에 영향을 미치는 제약 조건이 됩니다. 명세, 구현, 그리고 운영 현실 사이의 이러한 반복적인 상호작용이야말로 진정한 이해가 나타나는 지점이며, 전통적인 SDLC가 지속적인 진화로 변모하는 곳입니다.

## 지금 SDD가 중요한 이유

세 가지 트렌드가 SDD를 가능하게 할 뿐만 아니라 필수적으로 만듭니다.

첫째, AI 역량이 자연어 명세를 통해 안정적으로 작동하는 코드를 생성할 수 있는 임계점에 도달했습니다. 이는 개발자를 대체하는 것이 아니라, 명세에서 구현으로의 기계적인 번역을 자동화함으로써 개발자의 효율성을 증폭시키는 것입니다. 이는 탐색과 창의성을 증폭시키고, "처음부터 다시 시작하기"를 쉽게 지원하며, 추가, 삭제, 비판적 사고를 지원할 수 있습니다.

둘째, 소프트웨어의 복잡성은 기하급수적으로 계속 증가하고 있습니다. 현대 시스템은 수십 개의 서비스, 프레임워크, 의존성을 통합합니다. 이 모든 조각들을 수동 프로세스를 통해 원래의 의도와 일치시키는 것은 점점 더 어려워지고 있습니다. SDD는 명세 주도 생성을 통해 체계적인 일관성을 제공합니다. 프레임워크는 인간 우선이 아닌 AI 우선 지원을 제공하거나, 재사용 가능한 컴포넌트를 중심으로 설계되도록 진화할 수 있습니다.

셋째, 변화의 속도가 가속화되고 있습니다. 오늘날 요구사항은 과거 어느 때보다 훨씬 빠르게 변화합니다. 방향 전환(Pivoting)은 더 이상 예외적인 일이 아니라 예상되는 일입니다. 현대 제품 개발은 사용자 피드백, 시장 상황, 경쟁 압력에 기반한 빠른 반복을 요구합니다. 전통적인 개발은 이러한 변화를 방해 요소로 취급합니다. 각 방향 전환은 문서, 설계, 코드를 통해 수동으로 변경 사항을 전파해야 합니다. 그 결과는 속도를 제한하는 느리고 신중한 업데이트이거나, 기술 부채를 축적하는 빠르고 무모한 변경입니다.

SDD는 "만약 우리가 티셔츠를 더 많이 팔기 위한 비즈니스 요구를 촉진하기 위해 애플리케이션을 재구현하거나 변경해야 한다면, 그것을 어떻게 구현하고 실험할 것인가?"와 같은 가상/시뮬레이션 실험을 지원할 수 있습니다.

SDD는 요구사항 변경을 장애물에서 정상적인 워크플로우로 변환합니다. 명세가 구현을 주도할 때, 방향 전환은 수동 재작성이 아닌 체계적인 재생성이 됩니다. PRD에서 핵심 요구사항을 변경하면, 영향을 받는 구현 계획이 자동으로 업데이트됩니다. 사용자 스토리를 수정하면, 해당 API 엔드포인트가 재생성됩니다. 이것은 단지 초기 개발에 관한 것이 아니라, 필연적인 변화 속에서도 엔지니어링 속도를 유지하는 것에 관한 것입니다.

## 핵심 원칙

**명세가 공용어(Lingua Franca)**: 명세가 주요 산출물이 됩니다. 코드는 특정 언어와 프레임워크로 표현된 구현체가 됩니다. 소프트웨어를 유지보수한다는 것은 명세를 발전시키는 것을 의미합니다.

**실행 가능한 명세**: 명세는 작동하는 시스템을 생성할 만큼 정밀하고, 완전하며, 모호하지 않아야 합니다. 이는 의도와 구현 사이의 격차를 제거합니다.

**지속적인 개선**: 일관성 검증은 일회성 관문이 아니라 지속적으로 발생합니다. AI는 지속적인 프로세스로서 명세의 모호성, 모순, 격차를 분석합니다.

**리서치 기반 컨텍스트**: 리서치 에이전트는 명세 과정 전반에 걸쳐 기술적 옵션, 성능 영향, 조직의 제약 조건을 조사하며 중요한 컨텍스트를 수집합니다.

**양방향 피드백**: 프로덕션 환경의 현실이 명세 진화에 정보를 제공합니다. 지표, 장애, 운영상의 교훈이 명세 개선을 위한 입력이 됩니다.

**탐색을 위한 브랜칭**: 동일한 명세에서 여러 구현 접근 방식을 생성하여 성능, 유지보수성, 사용자 경험, 비용 등 다양한 최적화 목표를 탐색합니다.

## 구현 접근법

오늘날 SDD를 실천하려면 기존 도구들을 조합하고 프로세스 전반에 걸쳐 규율을 유지해야 합니다. 이 방법론은 다음을 통해 실천할 수 있습니다.

- 반복적인 명세 개발을 위한 AI 어시스턴트
- 기술적 컨텍스트 수집을 위한 리서치 에이전트
- 명세를 구현으로 변환하기 위한 코드 생성 도구
- 명세 우선 워크플로우에 맞게 조정된 버전 관리 시스템
- 명세 문서의 AI 분석을 통한 일관성 검사

핵심은 명세를 진실의 원천으로 취급하고, 코드는 그 반대가 아니라 명세를 보조하는 생성된 결과물로 다루는 것입니다.

## 명령어를 통한 SDD 간소화

SDD 방법론은 명세 → 계획 → 작업화 워크플로우를 자동화하는 세 가지 강력한 명령어를 통해 크게 향상됩니다.

### `/speckit.specify` 명령어

이 명령어는 간단한 기능 설명(사용자 프롬프트)을 자동 리포지토리 관리가 포함된 완전하고 구조화된 명세로 변환합니다.

1.  **자동 기능 번호 매기기**: 기존 명세를 스캔하여 다음 기능 번호(예: 001, 002, 003)를 결정합니다.
2.  **브랜치 생성**: 설명에서 시맨틱 브랜치 이름을 생성하고 자동으로 생성합니다.
3.  **템플릿 기반 생성**: 기능 명세 템플릿을 복사하고 사용자의 요구사항에 맞게 커스터마이즈합니다.
4.  **디렉토리 구조**: 모든 관련 문서를 위해 적절한 `specs/[branch-name]/` 구조를 생성합니다.

### `/speckit.plan` 명령어

기능 명세가 존재하면, 이 명령어는 포괄적인 구현 계획을 생성합니다.

1.  **명세 분석**: 기능 요구사항, 사용자 스토리, 인수 기준을 읽고 이해합니다.
2.  **헌법 준수**: 프로젝트 헌법 및 아키텍처 원칙과의 일관성을 보장합니다.
3.  **기술적 변환**: 비즈니스 요구사항을 기술 아키텍처 및 구현 세부사항으로 변환합니다.
4.  **상세 문서화**: 데이터 모델, API 계약, 테스트 시나리오를 위한 지원 문서를 생성합니다.
5.  **빠른 시작 검증**: 주요 검증 시나리오를 담은 빠른 시작 가이드를 생성합니다.

### `/speckit.tasks` 명령어

계획이 생성된 후, 이 명령어는 계획 및 관련 설계 문서를 분석하여 실행 가능한 작업 목록을 생성합니다.

1.  **입력**: `plan.md`(필수)를 읽고, `data-model.md`, `contracts/`, `research.md`가 있는 경우 함께 읽습니다.
2.  **작업 도출**: 계약, 엔티티, 시나리오를 특정 작업으로 변환합니다.
3.  **병렬화**: 독립적인 작업을 `[P]`로 표시하고 안전하게 병렬 처리할 수 있는 그룹을 개략적으로 설명합니다.
4.  **출력**: 작업 에이전트가 실행할 수 있도록 기능 디렉토리에 `tasks.md`를 작성합니다.

### 예시: 채팅 기능 구축하기

이 명령어들이 전통적인 개발 워크플로우를 어떻게 변화시키는지 보여줍니다.

**전통적인 접근 방식:**

```text
1. 문서에 PRD 작성 (2-3시간)
2. 설계 문서 작성 (2-3시간)
3. 프로젝트 구조 수동 설정 (30분)
4. 기술 명세 작성 (3-4시간)
5. 테스트 계획 작성 (2시간)
총: ~12시간의 문서 작업
```

**명령어를 사용한 SDD 접근 방식:**

```bash
# 1단계: 기능 명세 생성 (5분)
/speckit.specify 실시간 채팅 시스템 (메시지 기록 및 사용자 접속 상태 표시 기능 포함)

# 이 명령어는 자동으로 다음을 수행합니다:
# - "003-chat-system" 브랜치 생성
# - specs/003-chat-system/spec.md 생성
# - 구조화된 요구사항으로 파일 채우기

# 2단계: 구현 계획 생성 (5분)
/speckit.plan 실시간 메시징은 WebSocket, 기록은 PostgreSQL, 접속 상태는 Redis 사용

# 3단계: 실행 가능한 작업 생성 (5분)
/speckit.tasks

# 이 명령어는 자동으로 다음을 생성합니다:
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md (WebSocket 라이브러리 비교)
# - specs/003-chat-system/data-model.md (Message 및 User 스키마)
# - specs/003-chat-system/contracts/ (WebSocket 이벤트, REST 엔드포인트)
# - specs/003-chat-system/quickstart.md (주요 검증 시나리오)
# - specs/003-chat-system/tasks.md (계획에서 도출된 작업 목록)
```

15분 안에 다음을 얻을 수 있습니다:

- 사용자 스토리와 인수 기준이 포함된 완전한 기능 명세
- 기술 선택과 근거가 포함된 상세한 구현 계획
- 코드 생성을 위한 준비된 API 계약 및 데이터 모델
- 자동 및 수동 테스트를 위한 포괄적인 테스트 시나리오
- 기능 브랜치에 올바르게 버전 관리된 모든 문서

### 구조화된 자동화의 힘

이러한 명령어들은 단지 시간을 절약하는 것뿐만 아니라, 일관성과 완전성을 강제합니다:

1.  **누락되는 세부사항 없음**: 템플릿은 비기능적 요구사항부터 오류 처리에 이르기까지 모든 측면을 고려하도록 보장합니다.
2.  **추적 가능한 결정**: 모든 기술적 선택은 특정 요구사항으로 연결됩니다.
3.  **살아있는 문서**: 명세가 코드를 생성하기 때문에 코드와 동기화 상태를 유지합니다.
4.  **신속한 반복**: 며칠이 아닌 몇 분 만에 요구사항을 변경하고 계획을 재생성합니다.

이 명령어들은 명세를 정적인 문서가 아닌 실행 가능한 산출물로 취급함으로써 SDD 원칙을 구현합니다. 명세 프로세스를 필요악에서 개발의 원동력으로 변화시킵니다.

### 템플릿 주도 품질: 구조가 LLM을 제약하여 더 나은 결과를 만드는 방법

이 명령어들의 진정한 힘은 단순한 자동화가 아니라, 템플릿이 LLM의 행동을 더 높은 품질의 명세로 유도하는 방식에 있습니다. 템플릿은 LLM의 출력을 생산적인 방향으로 제약하는 정교한 프롬프트 역할을 합니다.

#### 1. 섣부른 구현 세부사항 방지

기능 명세 템플릿은 명시적으로 지시합니다:

```text
- ✅ 사용자가 무엇을(WHAT) 왜(WHY) 필요로 하는지에 집중하세요.
- ❌ 어떻게(HOW) 구현할지는 피하세요 (기술 스택, API, 코드 구조 언급 금지).
```

이 제약은 LLM이 적절한 추상화 수준을 유지하도록 강제합니다. LLM이 자연스럽게 "리액트와 리덕스를 사용하여 구현"으로 넘어갈 수 있는 상황에서, 템플릿은 "사용자는 데이터의 실시간 업데이트가 필요하다"에 집중하게 만듭니다. 이러한 분리는 구현 기술이 변경되더라도 명세가 안정적으로 유지되도록 보장합니다.

#### 2. 명시적인 불확실성 표시 강제

두 템플릿 모두 `[명확화 필요]` 마커 사용을 의무화합니다:

```text
사용자 프롬프트로부터 이 명세를 생성할 때:
1. **모든 모호함을 표시**: [명확화 필요: 구체적인 질문]을 사용하세요.
2. **추측하지 마세요**: 프롬프트에 명시되지 않은 것이 있다면 표시하세요.
```

이는 그럴듯하지만 잠재적으로 잘못된 가정을 하는 일반적인 LLM의 행동을 방지합니다. "로그인 시스템"이 이메일/비밀번호 인증을 사용한다고 추측하는 대신, LLM은 `[명확화 필요: 인증 방식이 명시되지 않음 - 이메일/비밀번호, SSO, OAuth?]`와 같이 표시해야 합니다.

#### 3. 체크리스트를 통한 구조화된 사고

템플릿에는 명세를 위한 "단위 테스트" 역할을 하는 포괄적인 체크리스트가 포함되어 있습니다:

```markdown
### 요구사항 완전성
- [ ] [명확화 필요] 마커가 남아있지 않음
- [ ] 요구사항은 테스트 가능하고 모호하지 않음
- [ ] 성공 기준은 측정 가능함
```

이 체크리스트는 LLM이 자신의 결과물을 체계적으로 자체 검토하도록 강제하여, 그렇지 않으면 놓칠 수 있는 격차를 잡아냅니다. 이는 LLM에게 품질 보증 프레임워크를 제공하는 것과 같습니다.

#### 4. 게이트를 통한 헌법 준수

구현 계획 템플릿은 단계별 게이트를 통해 아키텍처 원칙을 강제합니다:

```markdown
### -1단계: 사전 구현 게이트
#### 단순성 게이트 (제7조)
- [ ] 3개 이하의 프로젝트를 사용하고 있는가?
- [ ] 미래를 대비한 과도한 설계(future-proofing)는 없는가?
#### 추상화 방지 게이트 (제8조)
- [ ] 프레임워크를 직접 사용하고 있는가?
- [ ] 단일 모델 표현을 사용하는가?
```

이러한 게이트는 LLM이 복잡성을 명시적으로 정당화하도록 만들어 과도한 엔지니어링을 방지합니다. 게이트를 통과하지 못하면, LLM은 "복잡성 추적" 섹션에 그 이유를 문서화해야 하며, 이는 아키텍처 결정에 대한 책임감을 만듭니다.

#### 5. 계층적 세부 정보 관리

템플릿은 적절한 정보 아키텍처를 강제합니다:

```text
**중요**: 이 구현 계획은 높은 수준에서 읽기 쉽게 유지되어야 합니다.
모든 코드 샘플, 상세 알고리즘, 또는 광범위한 기술 명세는
반드시 적절한 `implementation-details/` 파일에 위치해야 합니다.
```

이는 명세가 읽을 수 없는 코드 덤프가 되는 일반적인 문제를 방지합니다. LLM은 적절한 세부 수준을 유지하는 법을 배우고, 복잡성을 별도의 파일로 추출하면서 주요 문서는 탐색하기 쉽게 유지합니다.

#### 6. 테스트 우선 사고

구현 템플릿은 테스트 우선 개발을 강제합니다:

```text
### 파일 생성 순서
1. API 명세를 포함하는 `contracts/` 생성
2. 계약 → 통합 → 종단간(e2e) → 단위 테스트 순서로 테스트 파일 생성
3. 테스트를 통과시키기 위한 소스 파일 생성
```

이 순서 제약은 LLM이 구현 전에 테스트 가능성과 계약에 대해 생각하도록 보장하여, 더 견고하고 검증 가능한 명세를 이끌어 냅니다.

#### 7. 추측성 기능 방지

템플릿은 추측을 명시적으로 금지합니다:

```text
- [ ] 추측성이거나 "필요할지도 모르는" 기능 없음
- [ ] 모든 단계에는 명확한 전제 조건과 결과물이 있음
```

이는 LLM이 구현을 복잡하게 만드는 "있으면 좋은" 기능을 추가하는 것을 막습니다. 모든 기능은 명확한 인수 기준이 있는 구체적인 사용자 스토리로 거슬러 올라가야 합니다.

### 복합 효과

이러한 제약들은 함께 작용하여 다음과 같은 명세를 생성합니다:

- **완전함**: 체크리스트가 누락되는 것을 방지합니다.
- **모호하지 않음**: 강제된 명확화 마커가 불확실성을 강조합니다.
- **테스트 가능함**: 테스트 우선 사고가 프로세스에 내장되어 있습니다.
- **유지보수 가능함**: 적절한 추상화 수준과 정보 계층 구조를 가집니다.
- **구현 가능함**: 구체적인 결과물이 있는 명확한 단계로 구성됩니다.

템플릿은 LLM을 창의적인 작가에서 규율 있는 명세 엔지니어로 변모시켜, 그 능력을 일관되게 고품질이고 실행 가능한, 진정으로 개발을 주도하는 명세를 생산하는 방향으로 유도합니다.

## 헌법적 기반: 아키텍처 규율 강제

SDD의 핵심에는 명세가 코드가 되는 방식을 지배하는 불변의 원칙 집합인 헌법이 있습니다. 헌법(`memory/constitution.md`)은 시스템의 아키텍처 DNA 역할을 하여, 생성된 모든 구현이 일관성, 단순성, 품질을 유지하도록 보장합니다.

### 개발의 9개 조항

헌법은 개발 프로세스의 모든 측면을 형성하는 9개의 조항을 정의합니다.

#### 제1조: 라이브러리 우선 원칙

모든 기능은 예외 없이 독립적인 라이브러리로 시작해야 합니다. 이는 처음부터 모듈식 설계를 강제합니다.

```text
Specify의 모든 기능은 반드시 독립적인 라이브러리로 시작해야 한다.
어떤 기능도 재사용 가능한 라이브러리 컴포넌트로 먼저 추상화되지 않고
애플리케이션 코드 내에서 직접 구현되어서는 안 된다.
```

이 원칙은 명세가 모놀리식 애플리케이션이 아닌 모듈식이고 재사용 가능한 코드를 생성하도록 보장합니다. LLM이 구현 계획을 생성할 때, 명확한 경계와 최소한의 의존성을 가진 라이브러리로 기능을 구조화해야 합니다.

#### 제2조: CLI 인터페이스 의무화

모든 라이브러리는 명령줄 인터페이스(CLI)를 통해 기능을 노출해야 합니다.

```text
모든 CLI 인터페이스는 다음을 반드시 준수해야 한다:
- 텍스트를 입력으로 받는다 (stdin, 인수, 또는 파일을 통해)
- 텍스트를 출력으로 생성한다 (stdout을 통해)
- 구조화된 데이터 교환을 위해 JSON 형식을 지원한다
```

이는 관찰 가능성과 테스트 가능성을 강제합니다. LLM은 기능을 불투명한 클래스 내부에 숨길 수 없으며, 모든 것은 텍스트 기반 인터페이스를 통해 접근하고 검증할 수 있어야 합니다.

#### 제3조: 테스트 우선 원칙

가장 혁신적인 조항으로, 테스트 없이는 코드도 없습니다.

```text
이것은 협상 불가능하다: 모든 구현은 엄격한 테스트 주도 개발(TDD)을 따라야 한다.
다음이 선행되지 않고는 어떠한 구현 코드도 작성되어서는 안 된다:
1. 단위 테스트가 작성된다.
2. 테스트가 사용자에 의해 검증되고 승인된다.
3. 테스트가 실패하는 것(Red 단계)이 확인된다.
```

이는 전통적인 AI 코드 생성을 완전히 뒤집습니다. 코드를 생성하고 작동하기를 바라는 대신, LLM은 먼저 행동을 정의하는 포괄적인 테스트를 생성하고, 승인을 받은 후, 그 다음에야 구현을 생성해야 합니다.

#### 제7조 & 제8조: 단순성과 추상화 방지

이 두 조항은 과도한 엔지니어링에 맞서 싸웁니다.

```text
제7조 3항: 최소한의 프로젝트 구조
- 초기 구현 시 최대 3개의 프로젝트
- 추가 프로젝트는 문서화된 정당화 필요

제8조 1항: 프레임워크 신뢰
- 프레임워크 기능을 감싸지 말고 직접 사용한다
```

LLM이 자연스럽게 정교한 추상화를 만들 수 있는 상황에서, 이 조항들은 모든 복잡성 계층에 대한 정당화를 강제합니다. 구현 계획 템플릿의 "-1단계 게이트"는 이러한 원칙을 직접적으로 강제합니다.

#### 제9조: 통합 우선 테스트

고립된 단위 테스트보다 실제 환경 테스트를 우선시합니다.

```text
테스트는 반드시 현실적인 환경을 사용해야 한다:
- 모의(mock) 객체보다 실제 데이터베이스 선호
- 스텁(stub)보다 실제 서비스 인스턴스 사용
- 구현 전 계약(contract) 테스트 의무화
```

이는 생성된 코드가 이론만이 아닌 실제 환경에서 작동함을 보장합니다.

### 템플릿을 통한 헌법 강제

구현 계획 템플릿은 구체적인 체크포인트를 통해 이러한 조항들을 실행합니다.

```markdown
### -1단계: 사전 구현 게이트
#### 단순성 게이트 (제7조)
- [ ] 3개 이하의 프로젝트를 사용하고 있는가?
- [ ] 미래를 대비한 과도한 설계는 없는가?

#### 추상화 방지 게이트 (제8조)
- [ ] 프레임워크를 직접 사용하고 있는가?
- [ ] 단일 모델 표현을 사용하는가?

#### 통합 우선 게이트 (제9조)
- [ ] 계약이 정의되었는가?
- [ ] 계약 테스트가 작성되었는가?
```

이러한 게이트는 아키텍처 원칙에 대한 컴파일 타임 체크 역할을 합니다. LLM은 게이트를 통과하거나, "복잡성 추적" 섹션에 정당한 예외를 문서화하지 않고는 진행할 수 없습니다.

### 불변의 원칙의 힘

헌법의 힘은 그 불변성에 있습니다. 구현 세부사항은 진화할 수 있지만, 핵심 원칙은 일정하게 유지됩니다. 이는 다음을 제공합니다.

1.  **시간에 따른 일관성**: 오늘 생성된 코드는 내년에 생성될 코드와 동일한 원칙을 따릅니다.
2.  **LLM 간의 일관성**: 다른 AI 모델도 아키텍처적으로 호환되는 코드를 생성합니다.
3.  **아키텍처 무결성**: 모든 기능이 시스템 설계를 훼손하는 대신 강화합니다.
4.  **품질 보증**: 테스트 우선, 라이브러리 우선, 단순성 원칙이 유지보수 가능한 코드를 보장합니다.

### 헌법의 진화

원칙은 불변이지만, 그 적용은 진화할 수 있습니다.

```text
제4조 2항: 개정 절차
이 헌법을 수정하려면 다음이 필요하다:
- 변경 이유에 대한 명시적인 문서화
- 프로젝트 유지보수자의 검토 및 승인
- 하위 호환성 평가
```

이는 안정성을 유지하면서 방법론이 학습하고 개선될 수 있도록 합니다. 헌법은 날짜가 기록된 개정안을 통해 원칙이 실제 경험을 바탕으로 어떻게 개선될 수 있는지를 보여줍니다.

### 규칙을 넘어: 개발 철학

헌법은 단순한 규칙집이 아니라, LLM이 코드 생성에 대해 어떻게 생각하는지를 형성하는 철학입니다.

- **불투명성보다 관찰 가능성**: 모든 것은 CLI 인터페이스를 통해 검사 가능해야 합니다.
- **기교보다 단순성**: 단순하게 시작하고, 필요성이 입증될 때만 복잡성을 추가합니다.
- **고립보다 통합**: 인공적인 환경이 아닌 실제 환경에서 테스트합니다.
- **모놀리스보다 모듈성**: 모든 기능은 명확한 경계를 가진 라이브러리입니다.

이러한 원칙들을 명세 및 계획 프로세스에 내장함으로써, SDD는 생성된 코드가 단지 기능적인 것을 넘어 유지보수 가능하고, 테스트 가능하며, 아키텍처적으로 건전하도록 보장합니다. 헌법은 AI를 단순한 코드 생성기에서 시스템 설계 원칙을 존중하고 강화하는 아키텍처 파트너로 변모시킵니다.

## 변혁

이는 개발자를 대체하거나 창의성을 자동화하는 것에 관한 것이 아닙니다. 기계적인 번역을 자동화함으로써 인간의 능력을 증폭시키는 것입니다. 명세, 리서치, 코드가 함께 진화하며, 각 반복이 더 깊은 이해와 의도와 구현 간의 더 나은 일치를 가져오는 긴밀한 피드백 루프를 만드는 것입니다.

소프트웨어 개발은 의도와 구현 간의 일치를 유지하기 위한 더 나은 도구가 필요합니다. SDD는 단순히 코드를 안내하는 것이 아니라 코드를 생성하는 실행 가능한 명세를 통해 이러한 일치를 달성하기 위한 방법론을 제공합니다.





## 실제 speckit 도구 구현 예시

명확한 요구사항 → 기술 설계 → 실행 가능한 작업 → 구현이라는 구조를 따르며, 소프트웨어 개발의 품질과 일관성을 높이는 데 초점을 둡니다.

---

### 1. `/speckit.constitution`  
**목적**: 프로젝트의 **핵심 원칙**, **개발 가이드라인**, **의사결정 기준**을 문서화합니다.  
이것은 프로젝트의 “헌법” 역할을 하며, 나중에 기술 선택이나 설계 논쟁이 있을 때 참조됩니다.

**예시**:

```text
/speckit.constitution

- 모든 코드는 테스트 가능해야 하며, 단위 테스트 커버리지는 최소 80% 이상이어야 한다.
- 사용자 인터페이스는 접근성(WCAG 2.1 AA)을 준수해야 한다.
- 백엔드는 stateless 설계를 따르며, 세션은 JWT 기반으로 관리한다.
- 데이터베이스 마이그레이션은 버전 관리되고, 롤백 가능해야 한다.
- 한국어와 영어를 동시에 지원하며, 모든 문자열은 i18n 레이어를 통해 관리된다.
```

> 💡 이 단계는 프로젝트 초기에 한 번 정의되지만, 필요시 업데이트 가능합니다.

---

### 2. `/speckit.specify`  
**목적**: **무엇을 만들 것인가**에 대한 **요구사항**과 **사용자 스토리**를 명확히 정의합니다.  
기술 구현보다는 **비즈니스 가치**와 **사용자 관점**에 집중합니다.

**예시**:

```text
/speckit.specify

사용자 스토리:
- 사용자로서, 나는 로그인 없이도 게스트 모드로 앱을 사용할 수 있어야 한다.
- 관리자로서, 나는 사용자 계정을 비활성화할 수 있어야 한다.
- 사용자로서, 나는 내 프로필 사진을 업로드하고 자르기 기능을 사용할 수 있어야 한다.

비기능적 요구사항:
- 시스템은 1초 이내에 프로필 이미지 업로드 응답을 반환해야 한다.
- 모든 API는 HTTPS만 허용하며, CORS 정책은 명시적으로 설정된다.
```

> 💡 이 단계에서 모호한 요구사항(예: “빠르게 작동해야 한다”)은 `/speckit.clarify`로 사전에 해소하는 것이 좋습니다.

---

### 3. `/speckit.clarify` *(선택적, 권장됨)*  
**목적**: `/speckit.specify`에서 **모호하거나 불완전한 요구사항**을 명확히 합니다.  
질문을 통해 명세의 품질을 높입니다.

**예시**:

```text
/speckit.clarify

질문:
- “게스트 모드”에서 사용자는 어떤 데이터를 저장할 수 있나요? 로컬 스토리지만 허용되나요?
- 프로필 사진 자르기 기능은 서버에서 처리되나요, 클라이언트에서 처리되나요?
- 비활성화된 계정은 완전히 삭제되나요, 아니면 상태만 변경되나요?
```

> 💡 이 단계를 거치면 나중에 설계나 구현에서 혼선을 줄일 수 있습니다.

---

### 4. `/speckit.plan`  
**목적**: 명세를 바탕으로 **기술적 구현 계획**을 세웁니다.  
기술 스택, 아키텍처, 데이터 흐름, API 설계 등을 포함합니다.

**예시**:

```text
/speckit.plan

기술 스택:
- 프론트엔드: React + TypeScript + Vite
- 백엔드: Node.js + Express
- DB: PostgreSQL
- 인증: JWT + bcrypt
- 파일 저장: AWS S3 (프로필 이미지)

아키텍처:
- 클라이언트는 REST API를 통해 /api/v1/profile/upload 엔드포인트에 이미지 전송
- 서버는 sharp 라이브러리로 이미지 크롭 후 S3에 저장
- DB에는 S3 URL만 저장

보안:
- multipart/form-data 업로드 시 파일 타입 검증 (image/jpeg, image/png만 허용)
- 최대 파일 크기: 5MB
```

> 💡 이 단계는 개발자가 실제로 코드를 작성하기 전의 “청사진”입니다.

---

### 5. `/speckit.tasks`  
**목적**: 계획을 바탕으로 **실행 가능한 작업 목록**을 생성합니다.  
작업은 작고, 독립적이며, 검증 가능해야 합니다.

**예시**:

```text
/speckit.tasks

1. [FE] 프로필 페이지에 이미지 업로드 UI 추가 (React 컴포넌트)
2. [FE] 이미지 미리보기 및 크롭 영역 선택 기능 구현 (react-easy-crop 사용)
3. [BE] /api/v1/profile/upload 엔드포인트 생성
4. [BE] multer로 multipart/form-data 파싱 설정
5. [BE] sharp로 이미지 리사이징 및 크롭 (300x300 정사각형)
6. [BE] AWS SDK 설정 및 S3 업로드 함수 구현
7. [BE] DB에 사용자 프로필 URL 업데이트
8. [TEST] 프로필 이미지 업로드 통합 테스트 작성
```

> 💡 각 작업은 PR 단위로 분리 가능하며, CI/CD 파이프라인과 연동하기 좋습니다.

---

### 6. `/speckit.analyze` *(선택적)*  
**목적**: 생성된 명세, 계획, 작업 간의 **일관성과 커버리지**를 분석합니다.  
예: “모든 사용자 스토리가 작업으로 분해되었는가?” “보안 요구사항이 구현 계획에 반영되었는가?”

**예시 출력**:

```text
/speckit.analyze

✅ 모든 사용자 스토리는 최소 1개 이상의 작업에 매핑됨.
⚠️ “게스트 모드 데이터 저장” 관련 작업이 누락됨 → 작업 #9 추가 필요.
✅ 비기능적 요구사항(1초 응답 시간)은 성능 테스트 항목으로 포함됨.
```

> 💡 이 단계는 구현 전 품질 보증(QA)의 일환입니다.

---

### 7. `/speckit.checklist` *(선택적)*  
**목적**: 요구사항의 **완전성**, **명확성**, **일관성**을 검증하는 **커스텀 체크리스트**를 생성합니다.  
말 그대로 “영어를 위한 유닛 테스트”처럼 작동합니다.

**예시**:

```text
/speckit.checklist

[ ] 모든 사용자 스토리는 “사용자로서, 나는 ~할 수 있다” 형식인가?
[ ] 각 비기능적 요구사항은 측정 가능한 지표(예: 1초, 99.9% 가용성)를 포함하는가?
[ ] 기술 계획에서 언급된 모든 외부 서비스(S3, DB 등)는 보안 설정이 명시되었는가?
[ ] 한국어 경로 처리(예: /사용자/이미지.jpg)에 대한 테스트 케이스가 포함되었는가?
```

> 💡 특히 국제화(i18n)나 특수 환경(예: ARM64, macOS/Linux 호환성)이 중요한 경우 유용합니다.

---

### 8. `/speckit.implement`  
**목적**: 모든 작업을 **자동 또는 수동으로 실행**하여 실제 코드를 생성합니다.  
이 명령은 앞선 단계들의 산출물을 기반으로 **완전한 기능 구현**을 수행합니다.

**예시 동작**:
- 위의 `/speckit.tasks` 목록을 순차적으로 실행
- 각 작업에 대해 코드 생성, 테스트 작성, 문서화 수행
- 최종 결과: 프로필 이미지 업로드 기능이 완전히 작동하는 상태

> 💡 실제 구현은 개발자가 직접 할 수도 있고, AI 어시스턴트가 코드 스니펫을 제안할 수도 있습니다.

---

### 요약: Spec-Driven Development 워크플로우 흐름

```
constitution → specify → [clarify] → plan → tasks → [analyze] → [checklist] → implement
```

이 접근법은 **“생각하고 → 설계하고 → 검증하고 → 구현한다”**는 원칙을 따르며,  
특히 **복잡한 시스템**, **팀 협업**, **장기 유지보수**가 필요한 프로젝트에 매우 효과적입니다.

필요하시면, 실제 프로젝트(예: C++ 데몬, VS Code 디버깅 설정 등)에 이 워크플로우를 적용해 함께 진행해 드릴 수도 있습니다.

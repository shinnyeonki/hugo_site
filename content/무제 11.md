---
title: 무제 11
resource-path: 무제 11.md
keywords:
tags:
date: 2025-10-08T05:03:05+09:00
lastmod: 2025-10-19T18:30:08+09:00
---
```bash
├── build // 빌드 결과 파일 프로젝트 경로와 완전히 일치
│   ├── src
│   │   ├── binary_tree
│   │   │   ├── binary_tree.d
│   │   │   ├── binary_tree.o
│   │   |   ├── test
│   │   |   │   └── test.h
│   │   │   ├── test.d
│   │   │   ├── test.o
│   │   │   └── test // /src/binary_tree/test.cpp 를 보고 있을때 f5 를 눌러서 생기는 파일
│   │   └── data_structure
│   │       ├── data_structure.d
│   │       ├── data_structure.o
│   │       ├── test
│   │       │   └── test.h
│   │       ├── test.d
│   │       ├── test.o
│   │       └── test // /src/data_structure/test.cpp 를 보고 있을때 f5 를 눌러서 생기는 파일
│   ├── test // /test.cpp 를 보고 있을때 f5 를 눌러서 생기는 파일
│   ├── test.d
│   └── test.o
├── Makefile
├── src
│   ├── binary_tree
│   │   ├── binary_tree.cpp
│   │   ├── binary_tree.h
│   │   ├── test
│   │   │   └── test.h
│   │   ├── test.cpp
│   │   └── test2.h
│   ├── data_structure
│   │   ├── data_structure.cpp
│   │   ├── data_structure.h
│   │   ├── test
│   │   │   └── test.h
│   │   ├── test.cpp
│   │   └── test2.h
│   └── graph
└── test.cpp
```

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "(내가 만든) Build active file with Makefile",
            "type": "shell",
            "command": "make",
            "args": [ "MAIN_SRC=${relativeFile}" ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": [
                "$gcc"
            ],
            "detail": "Makefile을 사용하여 현재 활성화된 C++ 파일을 빌드합니다."
        }
    ]
}
```

```makefile
CC=<컴파일러>
CFLAGS=<컴파일 옵션>
LDFLAGS=<링크 옵션>
LDLIBS=<링크 라이브러리 목록>
OBJS=<Object 파일 목록>
TARGET=<빌드 대상 이름>
 
all: $(TARGET)
 
clean:
    rm -f *.o
    rm -f $(TARGET)
 
$(TARGET): $(OBJS)
$(CC) -o $@ $(OBJS)
```

이것은 큰 틀로 해서 확장

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(내가 만든) Launch C++ file with Makefile",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/${relativeFileDirname}/${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "lldb",
            "setupCommands": [
                {
                    "description": "gdb 또는 lldb에 자동 서식 지정 사용",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Build active file with Makefile"
        }
    ]
}
```

manual 이 존재하는 이유 => MAIN_SRC 를 넘겨서 어떤 파일을 기준으로 컴파일 하는지 알려주어야해 그리고 그것을 기준으로 컴파일
프로젝트 전체에 여러개의 main 이 존재할 수 있으므로 컴파일러 자체의 의존성 분석 기능(g++ -MM)을 활용해서 적절한 파일만 적절히 링크

> @.src/js/core/router.js

  현재 file 파라미터를
  HTML5 History API
  를 사용하여 path 기반으로 처리하고 싶은데 계획을 세워줘
  최상위 경로는 실제 raw 파일을 접근할때 필요하므로 다른 url 구조를 원해
  먼저 어떻게 url 구조를 설계할지 부터 말해줘 아직 코드는 수정하지마

✦ 안녕하세요! 현재 ?file= 쿼리 파라미터를 사용하는 URL 구조를 HTML5 History API를 활용한 경로 기반 방식으로 변경하는 계획에 대해 문의주셨군요. 최상위 경로를 다른 용도로
  사용하고 싶어하시는 점까지 고려하여 다음과 같은 URL 구조를 제안합니다.

  제안하는 URL 구조

  기존 URL 구조를 보다 의미 있고 현대적인 방식으로 개선하기 위해, 애플리케이션의 페이지를 표시하는 모든 URL에 /view/ 라는 접두사를 사용하는 것을 제안합니다.

   * 기본 경로(Base Path): /view/
       * 노트 내용을 보여주는 모든 페이지는 이 경로 아래에 위치합니다.
       * 이렇게 하면 말씀하신 대로, 웹사이트의 최상위 경로 (/)는 원본 파일(raw file) 접근 등 다른 목적으로 자유롭게 사용할 수 있습니다.
   * 파일 경로: /view/ 접두사 뒤에 표시할 파일의 경로를 그대로 사용합니다.
       * 예시: notes/project-a.md 파일을 보려면 URL은 /view/notes/project-a.md가 됩니다.
   * 부가 정보 (해시, 하이라이트 등): 제목 링크를 위한 해시(#)나 검색어 하이라이트를 위한 쿼리 파라미터는 기존 구조와 동일하게 유지합니다.
       * 예시: /view/notes/project-a.md?highlightTerm=important#section-2
   * 홈 화면 (초기 페이지): 파일이 선택되지 않은 초기 화면은 /view/ URL로 접근합니다.

  기존 구조와 새 구조 비교


  ┌────────────────────┬──────────────────────────────────────┬─────────────────────────────────────┐
  │ 상황               │ 현재 URL 구조 (?file=...)            │ 제안하는 URL 구조 (/view/...)       │
  ├────────────────────┼──────────────────────────────────────┼─────────────────────────────────────┤
  │ 노트 보기          │ /?file=notes/project-a.md            │ /view/notes/project-a.md            │
  │ 특정 제목으로 이동 │ /?file=notes/a.md#heading-1          │ /view/notes/a.md#heading-1          │
  │ 검색어 하이라이트  │ /?file=notes/a.md&highlightTerm=test │ /view/notes/a.md?highlightTerm=test │
  │ 초기 화면          │ / 또는 /?file=                       │ /view/                              │
  └────────────────────┴──────────────────────────────────────┴─────────────────────────────────────┘

  이 구조의 장점

   * 직관적인 URL: URL만 봐도 어떤 콘텐츠를 보고 있는지 명확하게 알 수 있습니다.
   * 경로 충돌 방지: 최상위 경로를 다른 목적으로 사용할 수 있도록 하여 유연성을 확보합니다.
   * 표준적인 방식: 많은 최신 단일 페이지 애플리케이션(SPA)에서 사용하는 검증된 방식입니다.

  이 URL 구조 설계에 동의하시면, 다음 단계로 이 구조를 실제로 코드에 적용하기 위한 구체적인 계획을 세워드리겠습니다.

  참고: 이 변경을 적용하려면, 개발 및 실제 운영 환경에서 /view/로 시작하는 모든 요청을 index.html 파일로 전달하도록 서버 설정 변경이 필요할 수 있습니다. 이 부분은 구현
  단계에서 다시 한번 자세히 안내해 드리겠습니다.

> 하이라이트의 경우는 프래그먼트 식별자로 처리하는 것이 더 웹에 어울려 https://example.com#:~:text=[prefix-,]textStart[,textEnd][,-suffix]
  /view/notes 로 처리하는 이유가 있어? 그냥 실제 없을 거 같은 이름의 경로로 하면 될거 같은데 어떻게 생각해
  github page 에서도 동작하게 하고 싶어 따로 웹서버 설정을 만지지 않고 처리할려면 어떻게 해야 하는 거야
  seo 친화적이고 싶은데 임시로 경로의 markdown 파일의 내용을 index.html 에 넣고 검색엔진이 인덱싱 처리를 할 수 있도록 하는 것은 어때?   전반적인 계획을 다시 제시해줘

✦ 네, 좋은 질문들입니다! 웹 표준, GitHub Pages 배포, SEO까지 고려한 덕분에 훨씬 더 완성도 높은 계획을 세울 수 있겠습니다. 주신 의견들을 모두 반영하여 전반적인 계획을 다시
  제시해 드립니다.

  새로운 계획: URL 구조, GitHub Pages 배포, SEO

  1. URL 구조: 경로 기반 및 웹 표준 하이라이트

  핵심: GitHub Pages에서 서버 설정 없이도 동작하고, 웹 표준을 최대한 활용하는 '깨끗한 URL(Clean URL)' 구조를 채택합니다.

   * 라우팅 방식: 기존의 ?file= 이나 제안했던 /view/ 대신, 파일 경로 자체를 URL 경로로 사용합니다.
       * 예시: notes/project-a.md 파일을 보기 위한 URL은 https://<username>.github.io/<repo>/notes/project-a.md가 됩니다.

   * 하이라이트 방식: 쿼리 파라미터(?highlightTerm=...) 대신, 웹 표준인 텍스트 프래그먼트(Text Fragments)를 사용합니다. 이는 브라우저가 URL의 일부로 특정 텍스트를 찾아
     하이라이트하는 기능입니다.
       * 구조: #:~:text=[접두사-,]시작텍스트[,끝텍스트][,-접미사]
       * 예시: .../notes/project-a.md#:~:text=중요한 내용

   * 최종 URL 구조 비교


  ┌───────────────────┬─────────────────────────────┬────────────────────────────────────────────────┐
  │ 상황              │ 기존                        │ 새로운 제안                                    │
  ├───────────────────┼─────────────────────────────┼────────────────────────────────────────────────┤
  │ 노트 보기         │ /?file=notes/a.md           │ /notes/a.md                                    │
  │ 특정 제목 이동    │ /?file=notes/a.md#heading-1 │ /notes/a.md#heading-1 (변경 없음, 가장 이상적) │
  │ 텍스트 하이라이트 │ /?file=notes/a.md&h=test    │ /notes/a.md#:~:text=test (웹 표준)             │
  └───────────────────┴─────────────────────────────┴────────────────────────────────────────────────┘

  2. GitHub Pages 배포 전략: '404.html' 트릭

  말씀하신 대로 GitHub Pages는 Apache의 .htaccess나 Nginx의 rewrite 같은 서버 설정을 지원하지 않습니다. 이 문제를 해결하기 위해 SPA(단일 페이지 애플리케이션)에서 널리
  사용되는 영리한 방법인 '404.html 트릭'을 사용합니다.

   * 동작 원리:
       1. 사용자가 https://.../notes/project-a.md에 접속하면, GitHub Pages 서버에는 실제로 해당 경로에 파일이 없으므로 404 Not Found 오류가 발생합니다.
       2. 이때, 서버는 우리가 미리 만들어 둔 맞춤 404.html 파일을 사용자에게 보여줍니다.
       3. 우리는 index.html의 모든 내용을 그대로 복사해서 404.html을 만듭니다.
       4. 404.html 안의 스크립트(router.js)는 현재 URL(.../notes/project-a.md)을 읽어서, 이것이 404 페이지가 아니라 특정 노트를 보여달라는 요청임을 파악합니다.
       5. 라우터는 해당 경로의 마크다운 파일을 동적으로 불러와 화면에 렌더링합니다.

   * 결과: 사용자는 404 페이지를 전혀 보지 못하고, 마치 서버가 해당 URL을 직접 처리한 것처럼 자연스럽게 노트 내용을 보게 됩니다. 이 방법으로 서버 설정 없이 '깨끗한 URL'을
     사용할 수 있습니다.

  3. SEO 전략: 정적 사이트 생성(SSG)을 통한 사전 렌더링

  검색 엔진은 JavaScript를 실행하지 않고 HTML 내용만 보는 경우가 많습니다. 이 문제를 해결하고 SEO를 극대화하기 위해, 웹사이트를 게시하기 전에 모든 마크다운 파일을 각각의 HTML
  파일로 미리 만들어두는 '정적 사이트 생성(Static Site Generation)' 방식을 도입합니다.

   * 구현 계획:
       1. 빌드 스크립트 생성: Python이나 Shell 스크립트로 build.py 같은 빌드 자동화 스크립트를 만듭니다.
       2. 스크립트의 역할:
           * 프로젝트 내의 모든 마크다운 파일 (.md)을 찾습니다.
           * 각 마크다운 파일을 HTML로 변환합니다.
           * 미리 정의된 HTML 템플릿(헤더, 푸터, 그리고 변환된 HTML 내용이 들어갈 공간)에 변환된 내용을 삽입하여 완전한 HTML 페이지를 생성합니다.
           * 생성된 HTML 파일들을 dist와 같은 배포용 폴더에 원본과 동일한 경로 구조로 저장합니다. (예: notes/a.md → dist/notes/a.md/index.html 또는 dist/notes/a.md.html)
       3. 배포: GitHub Pages의 배포 소스를 dist 폴더로 지정합니다.

   * 기대 효과:
       * 검색 엔진은 각 URL에 대해 내용이 모두 채워진 HTML 파일을 크롤링하므로 SEO가 극대화됩니다.
       * 사용자가 처음 페이지에 접속할 때는 이 정적 HTML을 먼저 받으므로 초기 로딩 속도가 매우 빠릅니다.
       * 페이지가 로드된 후에는 기존의 SPA 스크립트가 동작하여, 페이지 이동이나 검색 등 모든 상호작용을 동적으로 부드럽게 처리합니다.

  종합 실행 계획

   1. 1단계: 라우터 리팩토링 (`router.js`)
       * URL 파싱 로직을 location.search(?file=...)에서 location.pathname을 읽도록 변경합니다.
       * URL 생성 로직(navigate, updateURLOnly)이 새로운 '깨끗한 URL' 구조를 사용하도록 수정합니다.
       * 하이라이트 관련 쿼리 파라미터 로직을 제거합니다. (텍스트 프래그먼트는 브라우저가 처리)

   2. 2단계: GitHub Pages 배포 설정
       * index.html을 복사하여 404.html 파일을 생성하고 프로젝트 루트에 둡니다.

   3. 3단계 (선택적이지만 강력 추천): SEO를 위한 빌드 스크립트 작성
       * 모든 마크다운 파일을 HTML로 사전 렌더링하여 dist 폴더에 저장하는 빌드 스크립트를 작성합니다.
       * GitHub Actions를 설정하여, 코드가 변경될 때마다 이 빌드 스크립트가 자동으로 실행되고 dist 폴더의 내용이 GitHub Pages에 배포되도록 자동화할 수 있습니다.

  이 계획은 제안해주신 아이디어들을 모두 통합하여, 현대적이고 효율적이며 검색 엔진에도 친화적인 솔루션을 제공합니다. 이 계획대로 진행할까요?

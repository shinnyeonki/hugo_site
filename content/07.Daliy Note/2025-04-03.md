---
title: 2025-04-03
resource-path: 07.Daliy Note/2025-04-03.md
---
Spring Boot에서 제공하는 WebSocket을 사용하여 유저별로 하나의 WebSocket 연결을 통해 여러 개의 컨테이너와 각 컨테이너별 여러 터미널 세션을 처리하는 방법을 이벤트 기반 아키텍처로 설계해 보겠습니다. 아래는 단계별 설명과 코드입니다.

---

### 설계 개요

- **목표**: 유저별로 단일 WebSocket 연결을 유지하며, 여러 컨테이너와 각 컨테이너 내 여러 터미널 세션을 관리.
- **방법**: 
  - `WebSocketHandler`를 사용하여 WebSocket 연결을 관리.
  - 유저별 세션과 터미널 정보를 `Map` 구조로 저장.
  - JSON 기반 이벤트 메시지를 통해 클라이언트와 서버 간 상호작용 처리.
- **특징**: 
  - Docker와 통합하여 컨테이너 내 터미널 실행.
  - 인증 및 보안 포함.
  - 리소스 정리 로직 포함.

---

### 1. 의존성 설정 (pom.xml)

Spring Boot와 Docker 통합을 위해 필요한 의존성을 추가합니다. Socket.IO 대신 Spring의 WebSocket을 사용하므로 관련 의존성만 필요합니다.

```xml
<dependencies>
    <!-- Spring Boot WebSocket -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>

    <!-- Docker Java 클라이언트 -->
    <dependency>
        <groupId>com.github.docker-java</groupId>
        <artifactId>docker-java</artifactId>
        <version>3.2.13</version>
    </dependency>

    <!-- Jackson for JSON 처리 -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.12.5</version>
    </dependency>
</dependencies>
```

---

### 2. WebSocket 구성 (WebSocketConfig.java)

Spring Boot의 WebSocket을 설정하고, 인증을 위해 `HandshakeInterceptor`를 추가합니다.

```java
package org.mjuecs.mjuecs.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new TerminalWebSocketHandler(), "/terminal")
                .setAllowedOrigins("*") // CORS 설정 (운영 환경에서는 제한 필요)
                .addInterceptors(new HttpSessionHandshakeInterceptor()); // 인증 정보 전달
    }
}
```

---

### 3. WebSocket 핸들러 (TerminalWebSocketHandler.java)

유저별 WebSocket 세션을 관리하고, 이벤트를 처리하는 핵심 클래스입니다.

```java
package org.mjuecs.mjuecs.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.dockerjava.api.DockerClient;
import org.mjuecs.mjuecs.DockerClientFactory;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TerminalWebSocketHandler extends TextWebSocketHandler {

    private final Map<String, WebSocketSession> userSessions = new ConcurrentHashMap<>();
    private final Map<String, Map<String, Map<String, TerminalSession>>> userTerminalSessions = new ConcurrentHashMap<>();
    private final DockerClient dockerClient = DockerClientFactory.createClient();
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String userId = getUserIdFromSession(session);
        userSessions.put(userId, session);
        userTerminalSessions.putIfAbsent(userId, new ConcurrentHashMap<>());
        session.sendMessage(new TextMessage("{\"event\":\"connection_established\",\"userId\":\"" + userId + "\"}"));
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String payload = message.getPayload();
        JsonNode node = objectMapper.readTree(payload);
        String event = node.get("event").asText();
        String userId = getUserIdFromSession(session);
        Map<String, Map<String, TerminalSession>> containers = userTerminalSessions.get(userId);

        switch (event) {
            case "create_terminal":
                String containerId = node.get("containerId").asText();
                String terminalId = node.get("terminalId").asText();
                createTerminalSession(userId, containerId, terminalId, session);
                break;

            case "execute_command":
                containerId = node.get("containerId").asText();
                terminalId = node.get("terminalId").asText();
                String command = node.get("command").asText();
                TerminalSession termSession = containers.get(containerId).get(terminalId);
                if (termSession != null) {
                    termSession.sendCommand(command);
                }
                break;

            case "resize_screen":
                containerId = node.get("containerId").asText();
                terminalId = node.get("terminalId").asText();
                int cols = node.get("cols").asInt();
                int rows = node.get("rows").asInt();
                termSession = containers.get(containerId).get(terminalId);
                if (termSession != null) {
                    termSession.resize(cols, rows);
                }
                break;

            default:
                session.sendMessage(new TextMessage("{\"event\":\"error\",\"message\":\"Unknown event: " + event + "\"}"));
        }
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String userId = getUserIdFromSession(session);
        userSessions.remove(userId);
        userTerminalSessions.remove(userId); // 모든 터미널 세션 정리
    }

    private void createTerminalSession(String userId, String containerId, String terminalId, WebSocketSession session) throws IOException {
        Map<String, Map<String, TerminalSession>> containers = userTerminalSessions.get(userId);
        containers.putIfAbsent(containerId, new ConcurrentHashMap<>());
        Map<String, TerminalSession> terminals = containers.get(containerId);
        if (!terminals.containsKey(terminalId)) {
            TerminalSession newSession = new TerminalSession(containerId, terminalId, dockerClient, session);
            terminals.put(terminalId, newSession);
            session.sendMessage(new TextMessage("{\"event\":\"terminal_created\",\"containerId\":\"" + containerId + "\",\"terminalId\":\"" + terminalId + "\"}"));
        }
    }

    private String getUserIdFromSession(WebSocketSession session) {
        // JWT 또는 Principal을 통해 유저 ID 추출 (JwtFilter와 연계)
        return session.getPrincipal() != null ? session.getPrincipal().getName() : "anonymous";
    }
}
```

---

### 4. 터미널 세션 클래스 (TerminalSession.java)

각 터미널 세션을 관리하며 Docker와 통합합니다.

```java
package org.mjuecs.mjuecs.controller;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.command.ExecCreateCmdResponse;
import com.github.dockerjava.core.command.ExecStartResultCallback;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.nio.charset.StandardCharsets;

public class TerminalSession {

    private final String containerId;
    private final String terminalId;
    private final DockerClient dockerClient;
    private final WebSocketSession session;
    private final OutputStream stdinWriter;

    public TerminalSession(String containerId, String terminalId, DockerClient dockerClient, WebSocketSession session) throws IOException {
        this.containerId = containerId;
        this.terminalId = terminalId;
        this.dockerClient = dockerClient;
        this.session = session;

        PipedOutputStream stdinWriter = new PipedOutputStream();
        PipedInputStream stdinReader = new PipedInputStream(stdinWriter);

        ExecCreateCmdResponse exec = dockerClient.execCreateCmd(containerId)
                .withAttachStdout(true)
                .withAttachStderr(true)
                .withAttachStdin(true)
                .withTty(true)
                .withCmd("bash")
                .exec();

        dockerClient.execStartCmd(exec.getId())
                .withStdIn(stdinReader)
                .exec(new TerminalOutputCallback(session, terminalId));

        this.stdinWriter = stdinWriter;
    }

    public void sendCommand(String command) throws IOException {
        stdinWriter.write((command + "\n").getBytes(StandardCharsets.UTF_8));
        stdinWriter.flush();
    }

    public void resize(int cols, int rows) {
        // Docker API를 사용한 터미널 크기 조정 (현재는 생략, 필요 시 구현)
    }

    private class TerminalOutputCallback extends ExecStartResultCallback {
        private final WebSocketSession session;
        private final String terminalId;

        public TerminalOutputCallback(WebSocketSession session, String terminalId) {
            this.session = session;
            this.terminalId = terminalId;
        }

        @Override
        public void onNext(Frame frame) {
            String output = new String(frame.getPayload(), StandardCharsets.UTF_8);
            try {
                session.sendMessage(new TextMessage(
                    "{\"event\":\"terminal_output\",\"terminalId\":\"" + terminalId + "\",\"output\":\"" + output + "\"}"
                ));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onError(Throwable throwable) {
            try {
                session.sendMessage(new TextMessage(
                    "{\"event\":\"error\",\"message\":\"" + throwable.getMessage() + "\"}"
                ));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

### 5. 클라이언트 측 사용 예시

클라이언트는 WebSocket 연결을 통해 `/terminal` 엔드포인트에 접속하고, JSON 메시지로 이벤트를 전송합니다.

#### 연결 및 터미널 생성
```json
{"event": "create_terminal", "containerId": "cont1", "terminalId": "term1"}
```

#### 명령어 실행
```json
{"event": "execute_command", "containerId": "cont1", "terminalId": "term1", "command": "ls"}
```

#### 터미널 크기 조정
```json
{"event": "resize_screen", "containerId": "cont1", "terminalId": "term1", "cols": 80, "rows": 24}
```

#### 서버 응답 예시
```json
{"event": "terminal_output", "terminalId": "term1", "output": "file1\nfile2\n"}
```

---

### 6. 보안 및 인증

- **JWT 연계**: `JwtFilter`와 `JwtUtil`을 활용해 WebSocket 연결 시 토큰을 검증합니다.
- **Principal**: `WebSocketSession.getPrincipal()`을 통해 인증된 유저 정보를 가져옵니다.
- **SecurityConfig**: WebSocket 경로(`/terminal`)에 대한 접근 권한을 설정합니다.

#### SecurityConfig.java (예시 수정)
```java
package org.mjuecs.mjuecs.config;

import org.mjuecs.mjuecs.jwt.JwtFilter;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtFilter jwtFilter;

    public SecurityConfig(JwtFilter jwtFilter) {
        this.jwtFilter = jwtFilter;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
            .antMatchers("/terminal").authenticated()
            .anyRequest().permitAll()
            .and()
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
    }
}
```

---

### 7. 리소스 관리

- **연결 종료 시**: `afterConnectionClosed`에서 유저의 모든 터미널 세션을 정리.
- **세션 만료**: WebSocket 세션이 만료되면 자동으로 정리됨.

---

### 요약

- **구조**: 
  - `TerminalWebSocketHandler`: 유저별 WebSocket 연결과 이벤트 처리.
  - `TerminalSession`: Docker와 통합된 터미널 세션 관리.
- **이벤트**: `create_terminal`, `execute_command`, `resize_screen`, `terminal_output` 등 JSON 기반 이벤트 사용.
- **특징**: 단일 WebSocket 연결로 유저별 다중 컨테이너 및 터미널 관리 가능.

이 설계를 통해 Spring Boot의 WebSocket을 활용하여 유저별로 여러 컨테이너와 터미널 세션을 효율적으로 관리할 수 있습니다. 기존 프로젝트 구조에 맞게 `controller` 패키지에 핸들러를 배치하고, `DockerClientFactory`를 재사용했습니다. 추가적인 요구사항이 있다면 말씀해 주세요!


---
---
---


사용자별로 다중 컨테이너와 터미널 세션을 관리하기 위해 다음과 같은 계층적 구조로 서버를 설계할 수 있습니다. WebSocket(STOMP) 기반의 효율적인 세션 관리 방식을 제시합니다.

### 1. 세션 관리 계층 구조
```plaintext
UserSession (1) ──── Containers (N) ──── Terminals (N)
   │                     │                   │
   └─ userId          containerId        terminalId
                     dockerContainer     PtyProcess
                     terminalRegistry    websocketSession
```

### 2. 핵심 컴포넌트 설계
#### 2.1 세션 관리자 (SessionRegistry)
```java
@Component
public class SessionRegistry {
    private final Map<String, UserSession> sessions = new ConcurrentHashMap<>();

    public void registerSession(String userId, WebSocketSession session) {
        sessions.put(userId, new UserSession(userId, session));
    }

    public UserSession getSession(String userId) {
        return sessions.get(userId);
    }

    public void removeSession(String userId) {
        sessions.remove(userId);
    }
}

public class UserSession {
    private final String userId;
    private final WebSocketSession session;
    private final Map<String, DockerContainer> containers = new HashMap<>();

    // 생성자, getter/setter
}
```

#### 2.2 컨테이너 관리 서비스
```java
@Service
public class DockerService {
    @Autowired
    private SessionRegistry sessionRegistry;

    public void createContainer(String userId, String containerId) {
        UserSession userSession = sessionRegistry.getSession(userId);
        DockerContainer container = new DockerContainer(containerId);
        userSession.addContainer(container);
    }

    public void removeContainer(String userId, String containerId) {
        UserSession userSession = sessionRegistry.getSession(userId);
        DockerContainer removed = userSession.removeContainer(containerId);
        removed.closeAllTerminals();
    }
}
```

#### 2.3 터미널 핸들러
```java
@Component
public class TerminalHandler {
    private final Map<String, PtyProcess> terminalProcesses = new ConcurrentHashMap<>();

    public void createTerminal(String userId, String containerId, String terminalId) {
        PtyProcess process = new PtyProcessBuilder()
            .setCommand("/bin/bash")
            .start();

        terminalProcesses.put(terminalId, process);
        
        // 터미널 I/O 처리 스레드
        new Thread(() -> {
            try {
                byte[] buffer = new byte[1024];
                while (true) {
                    int read = process.getInputStream().read(buffer);
                    if (read > 0) {
                        String output = new String(buffer, 0, read);
                        sendOutput(userId, containerId, terminalId, output);
                    }
                }
            } catch (IOException e) {
                // 처리 종료
            }
        }).start();
    }

    private void sendOutput(String userId, String containerId, String terminalId, String output) {
        // STOMP를 통해 클라이언트에 전송
        simpMessagingTemplate.convertAndSendToUser(
            userId,
            "/queue/container/" + containerId + "/terminal/" + terminalId,
            new TerminalOutputEvent(output)
        );
    }
}
```

### 3. STOMP 메시지 라우팅
#### 3.1 메시지 매핑
```java
@Controller
public class WebSocketController {
    @Autowired
    private TerminalHandler terminalHandler;

    @MessageMapping("/terminal/create")
    public void createTerminal(@Header("simpSessionId") String sessionId, 
                              @Payload TerminalCreateRequest request) {
        String userId = (String) sessionRegistry.getSession(sessionId).getUser().getId();
        terminalHandler.createTerminal(userId, request.getContainerId(), request.getTerminalId());
    }

    @MessageMapping("/terminal/data")
    public void sendData(@Payload TerminalData data) {
        PtyProcess process = terminalHandler.getProcess(data.getTerminalId());
        process.getOutputStream().write(data.getInput().getBytes());
    }

    @MessageMapping("/terminal/resize")
    public void resizeTerminal(@Payload TerminalResizeRequest request) {
        PtyProcess process = terminalHandler.getProcess(request.getTerminalId());
        process.resize(request.getColumns(), request.getRows());
    }
}
```

#### 3.2 이벤트 구조
```json
// 컨테이너 생성 이벤트
{
  "type": "container_created",
  "userId": "user123",
  "containerId": "cont_001",
  "timestamp": "2024-01-01T00:00:00Z"
}

// 터미널 출력 이벤트
{
  "type": "terminal_output",
  "terminalId": "term_001",
  "output": "Welcome to Ubuntu...\n",
  "timestamp": "2024-01-01T00:00:01Z"
}
```

### 4. 보안 및 인증
```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
                if (accessor.getCommand() == StompCommand.CONNECT) {
                    String token = accessor.getFirstNativeHeader("Authorization");
                    // JWT 검증 로직
                    String userId = JwtUtil.validateToken(token);
                    accessor.setUser(new User(userId));
                }
                return message;
            }
        });
    }
}
```

### 5. 주요 플로우
1. **사용자 연결**  
   - 클라이언트가 JWT 토큰과 함께 WebSocket 연결
   - 서버에서 토큰 검증 후 UserSession 생성

2. **컨테이너 생성**  
   - 클라이언트가 `/app/container/create`로 요청
   - DockerService가 컨테이너 생성 및 세션 등록

3. **터미널 생성**  
   - 클라이언트가 `/app/terminal/create`로 요청
   - TerminalHandler가 PTY 프로세스 생성 및 I/O 스레드 시작

4. **데이터 전송**  
   - 클라이언트 입력 → `/app/terminal/data` → PTY 프로세스에 전달
   - PTY 출력 → STOMP 메시지 → 클라이언트 수신

5. **세션 종료**  
   - WebSocket 연결 해제 시 모든 컨테이너/터미널 자원 정리

### 6. 확장성 고려 사항
1. **세션 클러스터링**  
   - Redis를 사용한 세션 복제 구현
   - `@EnableRedisHttpSession` 설정 추가

2. **리소스 제한**  
   - 사용자별 컨테이너 수 제한 로직 구현
   - `ContainerLimitExceededException` 처리

3. **로그 관리**  
   - 터미널 세션 녹화 기능 추가
   - `TerminalLogRepository` 구현

이 구조는 사용자-컨테이너-터미널 간 계층적 관계를 유지하며, STOMP 메시지 라우팅을 통해 효율적인 통신을 구현합니다. 각 컴포넌트가 명확히 분리되어 있어 확장성과 유지보수성이 우수합니다.
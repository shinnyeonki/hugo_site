---
title: 무제 7
resource-path: 무제 7.md
aliases:
tags:
date: 2025-09-03T15:49:56+09:00
lastmod: 2025-10-16T10:03:19+09:00
---
```
rsync(1)                                                                                  사용자 명령어                                                                                  rsync(1)

NAME
       rsync - 빠르고, 다용도이며, 원격(및 로컬) 파일 복사 도구

SYNOPSIS
       로컬:
           rsync [OPTION...] SRC... [DEST]

       원격 셸을 통한 접근:
           가져오기 (Pull):
               rsync [OPTION...] [USER@]HOST:SRC... [DEST]
           보내기 (Push):
               rsync [OPTION...] SRC... [USER@]HOST:DEST

       rsync 데몬을 통한 접근:
           가져오기 (Pull):
               rsync [OPTION...] [USER@]HOST::SRC... [DEST]
               rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
           보내기 (Push):
               rsync [OPTION...] SRC... [USER@]HOST::DEST
               rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)

       단일 SRC 인자만 있고 DEST 인자가 없는 사용법은 파일을 복사하는 대신 소스 파일을 나열합니다.

       이 맨페이지의 온라인 버전(주제 간 상호 링크 포함)은 https://download.samba.org/pub/rsync/rsync.1 에서 확인할 수 있습니다.

DESCRIPTION
       Rsync는 빠르고 매우 다용도의 파일 복사 도구입니다. 로컬에서, 모든 원격 셸을 통해 다른 호스트로/로부터, 또는 원격 rsync 데몬으로/로부터 파일을 복사할 수 있습니다.
       이 도구는 동작의 모든 측면을 제어하고 복사할 파일 집합을 매우 유연하게 지정할 수 있는 수많은 옵션을 제공합니다.
       Rsync는 소스 파일과 대상에 있는 기존 파일 간의 차이점만 전송하여 네트워크를 통해 전송되는 데이터 양을 줄이는 델타-전송 알고리즘으로 유명합니다.
       Rsync는 백업 및 미러링에 널리 사용되며, 일상적인 사용을 위한 개선된 복사 명령어로도 활용됩니다.

       Rsync는 "빠른 검사(quick check)" 알고리즘(기본값)을 사용하여 전송해야 할 파일을 찾는데, 이 알고리즘은 크기 또는 최종 수정 시간이 변경된 파일을 찾습니다.
       (옵션으로 요청된) 다른 보존된 속성의 변경사항은 빠른 검사가 파일 데이터 업데이트가 필요 없다고 판단할 때 대상 파일에 직접 적용됩니다.

       rsync의 추가 기능 중 일부는 다음과 같습니다:

       o      링크, 장치, 소유자, 그룹 및 권한 복사 지원

       o      GNU tar와 유사한 exclude 및 exclude-from 옵션

       o      CVS가 무시하는 파일과 동일한 파일을 무시하는 CVS exclude 모드

       o      ssh 또는 rsh를 포함한 모든 투명한 원격 셸 사용 가능

       o      슈퍼유저 권한 불필요

       o      지연 시간 비용을 최소화하기 위한 파일 전송 파이프라이닝

       o      익명 또는 인증된 rsync 데몬 지원 (미러링에 이상적)

GENERAL
       Rsync는 원격 호스트로/로부터, 또는 현재 호스트의 로컬에서 파일을 복사합니다 (두 개의 원격 호스트 간 파일 복사는 지원하지 않습니다).

       rsync가 원격 시스템에 접속하는 두 가지 방법이 있습니다: 원격-셸 프로그램(예: ssh 또는 rsh)을 전송 수단으로 사용하거나, TCP를 통해 rsync 데몬에 직접 접속하는 것입니다.
       원격-셸 전송은 소스 또는 대상 경로에 호스트 사양 뒤에 단일 콜론(:) 구분자가 포함될 때 사용됩니다.
       rsync 데몬에 직접 접속하는 경우는 소스 또는 대상 경로에 호스트 사양 뒤에 이중 콜론(::) 구분자가 포함되거나, OR rsync:// URL이 지정될 때 발생합니다 (후자 규칙의 예외는 USING RSYNC-DAEMON FEATURES VIA A RE‐
       MOTE-SHELL CONNECTION 섹션 참조).

       특별한 경우로, 대상 없이 단일 소스 인자만 지정되면, 파일은 "ls -l"과 유사한 출력 형식으로 나열됩니다.

       예상대로, 소스 또는 대상 경로 모두 원격 호스트를 지정하지 않으면 로컬 복사가 발생합니다 (--list-only 옵션 참조).

       Rsync는 로컬 측을 클라이언트(client)로, 원격 측을 서버(server)로 지칭합니다. 서버와 rsync 데몬을 혼동하지 마십시오. 데몬은 항상 서버이지만, 서버는 데몬 또는 원격-셸에서 실행된 프로세스일 수 있습니다.

SETUP
       설치 지침은 README.md 파일을 참조하십시오.

       설치 후, 원격 셸을 통해 접근할 수 있는 모든 머신(및 rsync 데몬 모드 프로토콜을 사용하여 접근할 수 있는 일부 머신)에 rsync를 사용할 수 있습니다.
       원격 전송의 경우, 최신 rsync는 통신을 위해 ssh를 사용하지만, 기본적으로 rsh 또는 remsh와 같은 다른 원격 셸을 사용하도록 구성되었을 수도 있습니다.

       -e 명령줄 옵션을 사용하거나 RSYNC_RSH 환경 변수를 설정하여 원하는 원격 셸을 지정할 수도 있습니다.

       rsync는 소스 및 대상 머신 모두에 설치되어야 합니다.

USAGE
       rsync는 rcp를 사용하는 것과 동일한 방식으로 사용합니다. 소스와 대상을 지정해야 하며, 그 중 하나는 원격일 수 있습니다.

       구문을 설명하는 가장 좋은 방법은 몇 가지 예시를 드는 것입니다:

           rsync -t *.c foo:src/

       이것은 현재 디렉토리에서 패턴 *.c와 일치하는 모든 파일을 머신 foo의 src 디렉토리로 전송합니다.
       만약 파일 중 일부가 원격 시스템에 이미 존재한다면, rsync 원격-업데이트 프로토콜은 데이터의 차이점만을 전송하여 파일을 업데이트하는 데 사용됩니다.
       명령줄 와일드카드(*.c)가 파일 목록으로 확장되는 것은 rsync 자체가 아닌 셸에 의해 처리됩니다 (다른 모든 Posix-스타일 프로그램과 정확히 동일합니다).

           rsync -avz foo:src/bar /data/tmp

       이것은 머신 foo의 src/bar 디렉토리에서 로컬 머신의 /data/tmp/bar 디렉토리로 모든 파일을 재귀적으로 전송합니다.
       파일은 아카이브 모드로 전송되어 심볼릭 링크, 장치, 속성, 권한, 소유권 등이 전송 시 보존됩니다.
       또한, 압축이 사용되어 전송되는 데이터 부분의 크기를 줄입니다.

           rsync -avz foo:src/bar/ /data/tmp

       소스에 있는 후행 슬래시(trailing slash)는 대상에 추가 디렉토리 수준이 생성되는 것을 방지하도록 이 동작을 변경합니다.
       소스의 후행 /를 "이 디렉토리의 내용을 복사하라"는 의미로 생각할 수 있으며, 이는 "디렉토리 이름으로 복사하라"는 것과 대조됩니다.
       하지만 두 경우 모두 포함하는 디렉토리의 속성은 대상의 포함하는 디렉토리로 전송됩니다.
       다시 말해, 다음 명령들은 /dest/foo의 속성 설정을 포함하여 동일한 방식으로 파일을 복사합니다:

           rsync -av /src/foo /dest
           rsync -av /src/foo/ /dest/foo

       또한 호스트 및 모듈 참조는 기본 디렉토리의 내용을 복사하기 위해 후행 슬래시를 필요로 하지 않습니다. 예를 들어, 다음 두 가지 모두 원격 디렉토리의 내용을 "/dest"로 복사합니다:

           rsync -av host: /dest
           rsync -av host::module /dest

       소스 또는 대상 경로에 ':'가 없는 로컬 전용 모드로 rsync를 사용할 수도 있습니다. 이 경우, rsync는 개선된 복사 명령처럼 동작합니다.

       마지막으로, 모듈 이름을 생략하면 특정 rsync 데몬에서 사용 가능한 모든 (나열 가능한) 모듈을 나열할 수 있습니다:

           rsync somehost.mydomain.com::

COPYING TO A DIFFERENT NAME
       디렉토리를 다른 이름으로 복사하려면, 소스 디렉토리에 후행 슬래시를 사용하여 디렉토리의 내용을 원하는 대상 디렉토리에 넣으십시오:

           rsync -ai foo/ bar/

       Rsync는 단일 항목을 복사할 때 대상 파일의 이름을 사용자 정의하는 기능도 가지고 있습니다. 이에 대한 규칙은 다음과 같습니다:

       o      전송 목록은 단일 항목(파일 또는 빈 디렉토리)으로 구성되어야 합니다.

       o      대상 경로의 마지막 요소가 디렉토리로 존재해서는 안 됩니다.

       o      대상 경로가 후행 슬래시로 지정되지 않아야 합니다.

       이러한 상황에서 rsync는 대상의 단일 항목 이름을 대상 경로의 마지막 요소로 설정합니다.
       이러한 구문은 파일을 복사할 때만 사용하고, 디렉토리를 복사할 때는 위에 언급된 후행 슬래시 구문을 사용하는 것이 가장 좋습니다.

       다음 예시는 foo.c 파일을 save 디렉토리 내에서 bar.c로 복사합니다 (bar.c가 디렉토리가 아니라고 가정):

           rsync -ai src/foo.c save/bar.c

       단일 항목 복사 규칙은 사용자가 알지 못하는 사이에 단일 항목을 복사하고 존재하지 않는 대상 디렉토리를 지정할 때 (후행 슬래시 없이) 실수로 문제를 일으킬 수 있습니다.
       예를 들어, src/*.c가 하나의 파일과 일치하고 save/dir이 존재하지 않으면, 대상 파일의 이름을 save/dir로 지정하여 혼란을 줄 수 있습니다:

           rsync -ai src/*.c save/dir

       이러한 사고를 방지하려면 대상 디렉토리가 존재하는지 확인하거나 후행 슬래시를 사용하여 대상 경로를 지정하십시오:

           rsync -ai src/*.c save/dir/

SORTED TRANSFER ORDER
       Rsync는 항상 지정된 파일 이름을 내부 전송 목록으로 정렬합니다.
       이것은 동일한 이름의 디렉토리 내용을 병합하고, 중복 파일 이름을 쉽게 제거할 수 있도록 합니다.
       그러나 파일이 명령줄에 주어진 순서와 다른 순서로 전송될 때 혼란을 줄 수 있습니다.

       특정 파일을 다른 파일보다 먼저 전송해야 하는 경우, 파일을 별도의 rsync 호출로 분리하거나, --delay-updates (정렬된 전송 순서에는 영향을 주지 않지만, 최종 파일 업데이트 단계를 훨씬 빠르게 만듭니다)를 사용하는 것을 고려하십시오.

MULTI-HOST SECURITY
       Rsync는 전송에서 공유되는 파일 요청이 다양한 보안 문제로부터 보호되도록 조치를 취합니다.
       잠재적인 문제의 대부분은 수신 측에서 발생하며, rsync는 전송되는 파일 목록이 요청된 범위 내에 있도록 조치를 취합니다.

       이를 위해 rsync 3.1.2 이상 버전은 파일 목록에 전송 상단을 벗어나려는 절대 또는 상대 경로가 포함될 경우 중단됩니다.
       또한, 버전 3.2.5부터 rsync는 파일 목록에 대한 두 가지 안전 점검을 추가로 수행합니다. (1) 클라이언트가 요청한 것 외에 추가 소스 인자가 전송에 추가되지 않았는지 확인하고, (2) 파일 목록이 전송자에게 보낸 제외 규칙을 준수하는지 확인합니다.

       아직 3.2.5 클라이언트 rsync를 가지고 있지 않거나(또는 추가로 조심하고 싶은 사람들을 위해), 원격 호스트를 신뢰하지 않을 때는 원격 파일을 위한 전용 대상 디렉토리로 복사하는 것이 가장 안전합니다.
       예를 들어, 홈 디렉토리로 rsync 복사를 수행하는 대신:

           rsync -aiv host1:dir1 ~

       원격 콘텐츠를 위한 "host1-files" 디렉토리를 전용으로 사용하십시오:

           rsync -aiv host1:dir1 ~/host1-files

       자세한 내용은 --trust-sender 옵션을 참조하십시오.

       주의: rsync를 사용하여 대소문자 구별 파일 시스템에서 대소문자 무시 파일 시스템으로 파일을 복사하는 것은 특별히 안전하지 않습니다.
       이러한 복사를 수행해야 하는 경우, --no-links를 통해 심볼릭 링크를 비활성화하거나 --munge-links를 통해 심볼릭 링크의 변형을 활성화해야 합니다 (그리고 올바른 로컬 또는 원격 옵션을 사용해야 합니다).
       이는 심볼릭 링크 이름이 파일 또는 디렉토리와 겹칠 경우 rsync가 잠재적으로 위험한 작업을 수행하는 것을 방지합니다.
       그러나 모든 파일의 완전한 복사를 보장하지는 않습니다 (이름이 겹치는 경우 불가능할 수 있기 때문입니다).
       더 나은 해결책은 모든 소스 파일을 나열하고 --files-from 옵션에 전달할 안전한 파일 이름 목록을 만드는 것입니다.
       이름이 충돌하는 파일은 여러 번의 복사를 사용하여 다른 대상 디렉토리로 복사해야 합니다.

       대소문자 무시 파일 시스템에서 대소문자 무시 파일 시스템으로의 복사는 상당히 잘 작동할 수 있지만, --delete-during 또는 --delete-before 옵션이 활성화되어 있지 않으면, rsync는 수신 측의 기존 파일을 업데이트하면서 파일 이름의 대소문자를 전송자와 일치하도록 변경해야 한다는 것을 인지하지 못할 수 있습니다.

ADVANCED USAGE
       원격 호스트에서 여러 파일을 요청하는 구문은 첫 번째와 동일한 스타일로 추가 원격-호스트 인자를 지정하거나 호스트 이름을 생략하여 수행됩니다.
       예를 들어, 다음 모두 작동합니다:

           rsync -aiv host:file1 :file2 host:file{3,4} /dest/
           rsync -aiv host::modname/file{1,2} host::modname/extra /dest/
           rsync -aiv host::modname/first ::extra-file{1,2} /dest/

       데몬 연결은 한 복사 명령당 하나의 모듈만 액세스할 수 있으므로, 후속 경로의 시작이 첫 번째 경로의 모듈 이름으로 시작하지 않으면 해당 모듈 내의 경로로 간주됩니다 (예: 위에 가져온 extra-file1 및 extra-file2).

       아주 오래된 rsync 버전(2.6.9 이하)은 단일 원격-소스 인자만 허용했으므로, 일부 사람들은 대신 원격 셸이 공백 분할을 수행하여 인자를 여러 경로로 나눌 것에 의존했습니다.
       그러한 직관적이지 않은 동작은 더 이상 기본적으로 지원되지 않습니다 (하지만 아래 설명된 대로 요청할 수 있습니다).

       3.2.4부터 파일 이름은 원격 셸에 전달될 때 사용자가 제공한 문자를 보존하는 방식으로 전달됩니다.
       따라서, 이름에 공백이 있는 파일을 요청하면 원격 rsync는 해당 파일을 찾습니다:

           rsync -aiv host:'a simple file.pdf' /dest/

       원격 rsync 인자에 수동으로 추가 인용(quoting)을 적용하거나 원격 인자 분할을 요구하도록 작성된 스크립트를 사용하는 경우, rsync에게 스크립트가 추가 이스케이핑을 처리하도록 요청할 수 있습니다.
       이는 스크립트의 rsync 실행에 --old-args 옵션을 추가하거나 (새로운 rsync 필요) RSYNC_OLD_ARGS=1 및 RSYNC_PROTECT_ARGS=0을 내보내면 됩니다 (이것은 오래된 또는 새로운 rsync 버전 모두에서 작동합니다).

CONNECTING TO AN RSYNC DAEMON
       원격 셸을 전송 수단으로 사용하지 않고 rsync를 사용하는 것도 가능합니다.
       이 경우 일반적으로 TCP 포트 873을 사용하여 원격 rsync 데몬에 직접 연결합니다. (이는 당연히 데몬이 원격 시스템에서 실행 중이어야 하므로, 이에 대한 정보는 아래의 STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS 섹션을 참조하십시오.)

       이러한 방식으로 rsync를 사용하는 것은 원격 셸과 함께 사용하는 것과 동일하지만 다음을 제외합니다:

       o      단일 콜론(원격 셸) 구문 대신 이중 콜론 구문 또는 rsync:// URL 구문을 사용하십시오.

       o      "경로"의 첫 번째 요소는 실제 모듈 이름입니다.

       o      추가 원격 소스 인자는 ADVANCED USAGE에서 논의된 바와 같이 호스트 이름 및/또는 모듈 이름을 생략하는 축약된 구문을 사용할 수 있습니다.

       o      원격 데몬은 연결 시 "오늘의 메시지(message of the day)"를 출력할 수 있습니다.

       o      호스트만 지정하고 (모듈이나 경로 없이) 지정하면 데몬에서 접근 가능한 모듈 목록이 출력됩니다.

       o      원격 소스 경로를 지정했지만 대상을 지정하지 않으면 원격 데몬에서 일치하는 파일 목록이 출력됩니다.

       o      --rsh (-e) 옵션은 소켓 연결 방식에서 USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION 방식으로 연결 스타일이 변경되는 것을 방지하기 위해 생략해야 합니다.

       "src"라는 이름의 원격 모듈의 모든 파일을 복사하는 예:

           rsync -av host::src /dest

       원격 데몬의 일부 모듈은 인증을 요구할 수 있습니다. 이 경우 연결 시 암호 프롬프트가 나타납니다.
       환경 변수 RSYNC_PASSWORD를 사용하려는 암호로 설정하거나 --password-file 옵션을 사용하여 암호 프롬프트를 피할 수 있습니다.
       이는 rsync를 스크립트화할 때 유용할 수 있습니다.

       경고: 일부 시스템에서는 환경 변수가 모든 사용자에게 보일 수 있습니다. 해당 시스템에서는 --password-file 사용을 권장합니다.

       환경 변수 RSYNC_PROXY를 웹 프록시를 가리키는 hostname:port 쌍으로 설정하여 웹 프록시를 통해 연결을 설정할 수 있습니다.
       웹 프록시의 구성은 포트 873으로의 프록시 연결을 지원해야 합니다.

       또한 환경 변수 RSYNC_CONNECT_PROG를 직접 소켓 연결을 수행하는 대신 실행할 명령어로 설정하여 프로그램을 프록시로 사용하여 데몬 연결을 설정할 수 있습니다.
       이 문자열에는 rsync 명령에 지정된 호스트 이름을 나타내는 이스케이프 "%H"가 포함될 수 있습니다 (따라서 문자열에 단일 "%"가 필요한 경우 "%%"를 사용하십시오).
       예:

           export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
           rsync -av targethost1::module/src/ /dest/
           rsync -av rsync://targethost2/module/src/ /dest/

       위에 지정된 명령은 ssh를 사용하여 프록시 호스트에서 nc (netcat)를 실행하고, 모든 데이터를 대상 호스트(%H)의 포트 873 (rsync 데몬)으로 전달합니다.

       또한 RSYNC_SHELL 환경 변수가 설정되면, 해당 프로그램이 system() 호출의 기본 셸을 사용하는 대신 RSYNC_CONNECT_PROG 명령을 실행하는 데 사용됩니다.

USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION
       실제로 시스템에 새로운 소켓 연결을 허용하지 않고(원격 셸 액세스에 이미 필요한 것 외에) rsync 데몬의 다양한 기능(예: 명명된 모듈)을 사용하는 것이 유용할 때가 있습니다.
       Rsync는 원격 셸을 사용하여 호스트에 연결한 다음, 원격 사용자의 홈 디렉토리에서 구성 파일을 읽을 것으로 예상되는 단일 사용 "데몬" 서버를 스폰(spawn)하는 것을 지원합니다.
       이는 데몬 스타일 전송의 데이터를 암호화하려는 경우 유용할 수 있지만, 데몬이 원격 사용자에 의해 새로 시작되므로 chroot와 같은 기능을 사용하거나 데몬이 사용하는 uid를 변경하지 못할 수 있습니다.
       (데몬 전송을 암호화하는 또 다른 방법으로는 ssh를 사용하여 로컬 포트를 원격 머신으로 터널링하고, 해당 원격 호스트의 일반 rsync 데몬이 "localhost"에서만 연결을 허용하도록 구성하는 것을 고려하십시오.)

       사용자 관점에서, 원격-셸 연결을 통한 데몬 전송은 일반 rsync-데몬 전송과 거의 동일한 명령줄 구문을 사용하며, 유일한 예외는 --rsh=COMMAND 옵션을 사용하여 명령줄에서 원격 셸 프로그램을 명시적으로 설정해야 한다는 것입니다.
       (환경에서 RSYNC_RSH을 설정하는 것은 이 기능을 켜지 않습니다.) 예를 들어:

           rsync -av --rsh=ssh host::module /dest

       다른 원격-셸 사용자를 지정해야 하는 경우, 호스트 앞의 user@ 접두사는 rsync-user 값(사용자 기반 인증이 필요한 모듈의 경우)을 지정한다는 점을 명심하십시오.
       이는 원격-셸을 지정할 때 ssh에 '-l user' 옵션을 제공해야 함을 의미하며, 예를 들어 --rsh 옵션의 짧은 버전을 사용하는 다음과 같습니다:

           rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest

       "ssh-user"는 ssh 수준에서 사용되고, "rsync-user"는 "module"에 로그인하는 데 사용됩니다.

       이 설정에서는 시스템에 접속하는 ssh 명령에 의해 데몬이 시작됩니다 (원하는 경우 ~/.ssh/authorized_keys 파일을 통해 강제할 수 있습니다).
       그러나 데몬에 직접 접속할 때는 미리 시작되어야 합니다.

STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS
       rsync 데몬에 연결하려면 원격 시스템에 데몬이 이미 실행 중이거나 (또는 특정 포트에서 들어오는 연결에 대해 rsync 데몬을 스폰(spawn)하도록 inetd와 같은 것을 구성해야 합니다).
       들어오는 소켓 연결을 처리할 데몬을 시작하는 방법에 대한 전체 정보는 rsyncd.conf(5) 맨페이지를 참조하십시오. 이 파일은 데몬의 구성 파일이며, 데몬을 실행하는 방법에 대한 전체 세부 정보(독립형 및 inetd 구성 포함)를 포함합니다.

       전송에 원격 셸 전송을 사용하는 경우, 수동으로 rsync 데몬을 시작할 필요가 없습니다.

EXAMPLES
       다음은 rsync가 어떻게 사용될 수 있는지 보여주는 몇 가지 예시입니다.

       대용량 MS Word 파일 및 메일 폴더로 구성된 홈 디렉토리를 백업하려면, 각 사용자별 cron 작업을 사용하여 매일 다음을 실행할 수 있습니다:

           rsync -aiz . bkhost:backup/joe/

       원격 호스트에서 로컬 호스트로 일부 파일을 이동하려면 다음을 실행할 수 있습니다:

           rsync -aiv --remove-source-files rhost:/tmp/{file1,file2}.c ~/src/

OPTION SUMMARY
       다음은 rsync에서 사용 가능한 옵션에 대한 간략한 요약입니다. 각 옵션에는 이 맨페이지에서 자세한 설명이 있습니다.

       --verbose, -v            상세 정보 출력 증가
       --info=FLAGS             세분화된 정보 출력 상세도
       --debug=FLAGS            세분화된 디버그 출력 상세도
       --stderr=e|a|c           표준 오류 출력 모드 변경 (기본값: errors)
       --quiet, -q              오류가 아닌 메시지 억제
       --no-motd                데몬 모드 MOTD 억제
       --checksum, -c           수정 시간 및 크기 대신 체크섬 기반으로 건너뛰기
       --archive, -a            아카이브 모드는 -rlptgoD (--no-A,-X,-U,-N,-H)
       --no-OPTION              암시된 OPTION 끄기 (예: --no-D)
       --recursive, -r          디렉토리 재귀적으로 복사
       --relative, -R           상대 경로 이름 사용
       --no-implied-dirs        --relative 사용 시 암시된 디렉토리 전송 안 함
       --backup, -b             백업 생성 (--suffix & --backup-dir 참조)
       --backup-dir=DIR         DIR 내에 계층 구조 기반으로 백업 생성
       --suffix=SUFFIX          백업 접미사 (기본값: ~ --backup-dir 없음)
       --update, -u             수신자 측이 더 새로운 파일 건너뛰기
       --inplace                대상 파일 제자리에서 업데이트
       --append                 짧은 파일에 데이터 추가
       --append-verify          --append에 기존 데이터 체크섬 확인 포함
       --dirs, -d               재귀 없이 디렉토리 전송
       --old-dirs, --old-d      오래된 rsync와 통신할 때 --dirs처럼 작동
       --mkpath                 대상에 없는 경로 구성 요소 생성
       --links, -l              심볼릭 링크를 심볼릭 링크로 복사
       --copy-links, -L         심볼릭 링크를 참조 파일/디렉토리로 변환
       --copy-unsafe-links      "안전하지 않은" 심볼릭 링크만 변환
       --safe-links             트리 외부를 가리키는 심볼릭 링크 무시
       --munge-links            심볼릭 링크를 안전하고 사용할 수 없게 변형
       --copy-dirlinks, -k      디렉토리로의 심볼릭 링크를 참조 디렉토리로 변환
       --keep-dirlinks, -K      수신자 측의 심볼릭 링크된 디렉토리를 실제 디렉토리로 처리
       --hard-links, -H         하드 링크 보존
       --perms, -p              권한 보존
       --executability, -E      실행 권한 보존
       --chmod=CHMOD            파일 및/또는 디렉토리 권한에 영향
       --acls, -A               ACL 보존 (--perms 암시)
       --xattrs, -X             확장 속성 보존
       --owner, -o              소유자 보존 (슈퍼유저 전용)
       --group, -g              그룹 보존
       --devices                장치 파일 보존 (슈퍼유저 전용)
       --copy-devices           장치 내용을 일반 파일로 복사
       --write-devices          장치에 파일처럼 쓰기 (--inplace 암시)
       --specials               특수 파일 보존
       -D                       --devices --specials와 동일
       --times, -t              수정 시간 보존
       --atimes, -U             접근 (사용) 시간 보존
       --open-noatime           열린 파일의 atime 변경 방지
       --crtimes, -N            생성 시간 (새로움) 보존
       --omit-dir-times, -O     --times에서 디렉토리 제외
       --omit-link-times, -J    --times에서 심볼릭 링크 제외
       --super                  수신자가 슈퍼유저 활동 시도
       --fake-super             확장 속성을 사용하여 특권 속성 저장/복구
       --sparse, -S             널 시퀀스를 스파스 블록으로 전환
       --preallocate            쓰기 전에 대상 파일 미리 할당
       --dry-run, -n            변경 없이 시범 실행
       --whole-file, -W         파일 전체 복사 (델타-전송 알고리즘 없이)
       --checksum-choice=STR    체크섬 알고리즘 선택 (일명 --cc)
       --one-file-system, -x    파일 시스템 경계를 넘지 않음
       --block-size=SIZE, -B    고정된 체크섬 블록 크기 강제 적용
       --rsh=COMMAND, -e        사용할 원격 셸 지정
       --rsync-path=PROGRAM     원격 머신에서 실행할 rsync 지정
       --existing               수신자 측에 새 파일 생성 건너뛰기
       --ignore-existing        수신자 측에 이미 존재하는 파일 업데이트 건너뛰기
       --remove-source-files    전송자가 동기화된 파일 제거 (비디렉토리)
       --del                    --delete-during의 별칭
       --delete                 대상 디렉토리에서 불필요한 파일 삭제
       --delete-before          수신자가 전송 전에 삭제, 전송 중 아님
       --delete-during          수신자가 전송 중에 삭제
       --delete-delay           전송 중에 삭제 사항 찾고, 전송 후에 삭제
       --delete-after           수신자가 전송 후에 삭제, 전송 중 아님
       --delete-excluded        제외된 파일도 대상 디렉토리에서 삭제
       --ignore-missing-args    오류 없이 누락된 소스 인자 무시
       --delete-missing-args    누락된 소스 인자를 대상에서 삭제
       --ignore-errors          I/O 오류가 있더라도 삭제
       --force                  비어 있지 않더라도 디렉토리 강제 삭제
       --max-delete=NUM         NUM개 이상의 파일 삭제 금지
       --max-size=SIZE          SIZE보다 큰 파일 전송 금지
       --min-size=SIZE          SIZE보다 작은 파일 전송 금지
       --max-alloc=SIZE         메모리 할당 관련 제한 변경
       --partial                부분적으로 전송된 파일 유지
       --partial-dir=DIR        부분적으로 전송된 파일을 DIR에 저장
       --delay-updates          모든 업데이트된 파일을 마지막에 배치
       --prune-empty-dirs, -m   파일 목록에서 빈 디렉토리 체인 정리
       --numeric-ids            사용자/그룹 이름으로 uid/gid 값 매핑 안 함
       --usermap=STRING         사용자 이름 사용자 정의 매핑
       --groupmap=STRING        그룹 이름 사용자 정의 매핑
       --chown=USER:GROUP       간단한 사용자 이름/그룹 이름 매핑
       --timeout=SECONDS        I/O 타임아웃을 초 단위로 설정
       --contimeout=SECONDS     데몬 연결 타임아웃을 초 단위로 설정
       --ignore-times, -I       크기 및 시간 일치 파일 건너뛰지 않음
       --size-only              크기만 일치하는 파일 건너뛰기
       --modify-window=NUM, -@  수정 시간 비교 정확도 설정
       --temp-dir=DIR, -T       임시 파일을 DIR 디렉토리에 생성
       --fuzzy, -y              대상 파일이 없으면 유사한 파일 찾기
       --compare-dest=DIR       DIR에 상대적인 대상 파일도 비교
       --copy-dest=DIR          ... 그리고 변경되지 않은 파일의 복사본 포함
       --link-dest=DIR          변경되지 않은 파일은 DIR의 파일에 하드 링크
       --compress, -z           전송 중 파일 데이터 압축
       --compress-choice=STR    압축 알고리즘 선택 (일명 --zc)
       --compress-level=NUM     명시적으로 압축 수준 설정 (일명 --zl)
       --skip-compress=LIST     LIST에 접미사가 있는 파일 압축 건너뛰기
       --cvs-exclude, -C        CVS와 동일한 방식으로 파일 자동 무시
       --filter=RULE, -f        파일 필터링 RULE 추가
       -F                       --filter='dir-merge /.rsync-filter'와 동일
                                반복 사용 시: --filter='- .rsync-filter'
       --exclude=PATTERN        PATTERN과 일치하는 파일 제외
       --exclude-from=FILE      FILE에서 제외 패턴 읽기
       --include=PATTERN        PATTERN과 일치하는 파일 제외하지 않음
       --include-from=FILE      FILE에서 포함 패턴 읽기
       --files-from=FILE        FILE에서 소스 파일 이름 목록 읽기
       --from0, -0              모든 *-from/filter 파일은 0으로 구분됨
       --old-args               최신 인자 보호 관용구 비활성화
       --secluded-args, -s      프로토콜을 사용하여 인자를 안전하게 전송
       --trust-sender           원격 전송자의 파일 목록 신뢰
       --copy-as=USER[:GROUP]   복사 작업에 사용자 및 선택적 그룹 지정
       --address=ADDRESS        데몬으로 나가는 소켓의 바인딩 주소
       --port=PORT              이중 콜론 대체 포트 번호 지정
       --sockopts=OPTIONS       사용자 정의 TCP 옵션 지정
       --blocking-io            원격 셸에 블로킹 I/O 사용
       --outbuf=N|L|B           출력 버퍼링을 None, Line, Block으로 설정
       --stats                  파일 전송 통계 제공
       --8-bit-output, -8       출력에서 높은 비트 문자 이스케이프 안 함
       --human-readable, -h     숫자를 사람이 읽기 쉬운 형식으로 출력
       --progress               전송 중 진행 상황 표시
       -P                       --partial --progress와 동일
       --itemize-changes, -i    모든 업데이트에 대한 변경 요약 출력
       --remote-option=OPT, -M  OPT를 원격 측으로만 전송
       --out-format=FORMAT      지정된 FORMAT을 사용하여 업데이트 출력
       --log-file=FILE          지정된 FILE에 작업 내용 기록
       --log-file-format=FMT    지정된 FMT을 사용하여 업데이트 기록
       --password-file=FILE     FILE에서 데몬-액세스 암호 읽기
       --early-input=FILE       데몬의 초기 exec 입력에 FILE 사용
       --list-only              파일 복사 대신 나열
       --bwlimit=RATE           소켓 I/O 대역폭 제한
       --stop-after=MINS        MINS분 경과 후 rsync 중지
       --stop-at=y-m-dTh:m      지정된 시간에 rsync 중지
       --fsync                  모든 쓰여진 파일 fsync
       --write-batch=FILE       FILE에 일괄 업데이트 기록
       --only-write-batch=FILE  --write-batch와 유사하지만 대상 업데이트 안 함
       --read-batch=FILE        FILE에서 일괄 업데이트 읽기
       --protocol=NUM           이전 프로토콜 버전 강제 사용
       --iconv=CONVERT_SPEC     파일 이름의 문자셋 변환 요청
       --checksum-seed=NUM      블록/파일 체크섬 시드 설정 (고급)
       --ipv4, -4               IPv4 선호
       --ipv6, -6               IPv6 선호
       --version, -V            버전 및 기타 정보 출력 후 종료
       --help, -h (*)           이 도움말 표시 (* -h는 단독 사용 시에만 도움말)

       Rsync는 데몬으로 실행될 수도 있으며, 이 경우 다음 옵션이 허용됩니다:

       --daemon                 rsync 데몬으로 실행
       --address=ADDRESS        지정된 주소에 바인딩
       --bwlimit=RATE           소켓 I/O 대역폭 제한
       --config=FILE            대체 rsyncd.conf 파일 지정
       --dparam=OVERRIDE, -M    전역 데몬 구성 매개변수 재정의
       --no-detach              부모로부터 분리하지 않음
       --port=PORT              대체 포트 번호로 수신
       --log-file=FILE          "로그 파일" 설정 재정의
       --log-file-format=FMT    "로그 형식" 설정 재정의
       --sockopts=OPTIONS       사용자 정의 TCP 옵션 지정
       --verbose, -v            상세 정보 출력 증가
       --ipv4, -4               IPv4 선호
       --ipv6, -6               IPv6 선호
       --help, -h               이 도움말 표시 (--daemon과 함께 사용 시)

OPTIONS
       Rsync는 긴 옵션(이중 대시 + 단어)과 짧은 옵션(단일 대시 + 문자)을 모두 허용합니다. 사용 가능한 모든 옵션 목록은 아래에 설명되어 있습니다.
       옵션을 두 가지 이상의 방법으로 지정할 수 있는 경우, 선택 사항은 쉼표로 구분됩니다. 일부 옵션은 긴 변형만 있고 짧은 변형은 없습니다.

       옵션에 매개변수가 필요한 경우, 매개변수는 긴 변형 뒤에만 나열되어 있지만, 짧은 변형에도 지정되어야 합니다.
       매개변수를 지정할 때는 --option=param, --option param, -o=param, -o param 또는 -oparam 형식을 사용할 수 있습니다 (후자의 선택은 옵션에 짧은 변형이 있다고 가정합니다).

       매개변수는 셸의 명령줄 파싱을 통과하기 위해 어떤 식으로든 인용(quote)되어야 할 수 있습니다.
       또한 경로 이름의 선행 틸데(~)는 셸에 의해 치환되므로, 로컬 셸이 이를 확장하도록 하려면 옵션 이름과 경로 이름 사이에 공백을 사용하여 구분해야 합니다.

       --help 도움말
              rsync에서 사용 가능한 옵션에 대한 짧은 도움말 페이지를 출력하고 종료합니다.
              다른 옵션 없이 사용될 때 -h를 --help 대신 사용할 수도 있습니다 (일반적으로 --human-readable을 의미하기 때문입니다).

       --version, -V
              rsync 버전 및 기타 정보를 출력하고 종료합니다.
              반복해서 사용하면 정보가 여전히 읽기 쉬운 JSON 형식으로 출력됩니다 (클라이언트 측만).

              출력에는 컴파일된 기능 목록, 최적화 목록, 기본 체크섬 알고리즘 목록, 기본 압축 알고리즘 목록, 기본 데몬 인증 다이제스트 목록, rsync 웹 사이트 링크 및 몇 가지 다른 항목이 포함됩니다.

       --verbose, -v
              이  옵션은 전송 중에 제공되는 정보의 양을 늘립니다. 기본적으로 rsync는 조용히 작동합니다. 단일 -v는 어떤 파일이 전송되는지에 대한 정보와 마지막에 간략한 요약을 제공합니다.
              두 개의 -v 옵션은 어떤 파일이 건너뛰어지는지에 대한 정보와 마지막에 약간 더 많은 정보를 제공합니다.
              두 개 이상의 -v 옵션은 rsync를 디버깅하는 경우에만 사용해야 합니다.

              실행 종료 요약은 원격 rsync로 전송된 바이트 수(로컬 복사 시 수신 측), 원격 호스트로부터 수신된 바이트 수, 그리고 rsync 실행 전체 기간 동안 계산된 전송된 데이터의 초당 평균 바이트 수를 알려줍니다.
              두 번째 줄은 rsync가 전송을 고려한 모든 파일 크기의 합계인 총 크기(바이트 단위)를 보여줍니다.
              또한 "속도 향상(speedup)" 값도 보여주는데, 이는 총 파일 크기를 전송 및 수신된 바이트의 합계로 나눈 비율입니다 (이는 단순히 기분 좋은 "더 클수록 좋다"는 숫자입니다).
              이러한 바이트 값은 --human-readable (또는 --no-human-readable) 옵션을 사용하여 더 (또는 덜) 사람이 읽기 쉽게 만들 수 있습니다.

              최신 rsync에서 -v 옵션은 --info 및 --debug 옵션 그룹 설정과 동일합니다.
              -v 사용에 추가하거나 대신 이러한 새로운 옵션을 사용할 수 있으며, 모든 세분화된 설정은 -v의 암시된 설정을 재정의합니다.
              --info와 --debug 모두 상세도 증가에 따라 어떤 플래그가 설정되는지 정확히 알려주는 도움말 요청 방법이 있습니다.

              그러나 데몬의 "최대 상세도(max verbosity)" 설정은 데몬 측에서 다양한 개별 플래그를 설정할 수 있는 수준을 제한한다는 점을 명심하십시오.
              예를 들어, 최대값이 2이면, -vv에 의해 설정되는 값보다 높은 값으로 설정된 모든 정보 및/또는 디버그 플래그는 데몬 로깅에서 -vv 수준으로 다운그레이드됩니다.

       --info=FLAGS
              이 옵션을 사용하면 보고 싶은 정보 출력에 대해 세분화된 제어를 할 수 있습니다.
              개별 플래그 이름 뒤에는 레벨 번호가 올 수 있으며, 0은 해당 출력을 침묵시키고, 1은 기본 출력 레벨이며, 더 높은 숫자는 해당 플래그의 출력을 증가시킵니다 (더 높은 레벨을 지원하는 플래그의 경우).
              사용 가능한 모든 플래그 이름, 출력 내용 및 상세도 증가에 따라 추가되는 플래그 이름을 보려면 --info=help를 사용하십시오. 몇 가지 예시:

                  rsync -a --info=progress2 src/ dest/
                  rsync -avv --info=stats2,misc1,flist0 src/ dest/

              --info=name의 출력은 --out-format 및 --itemize-changes (-i) 옵션에 영향을 받습니다. 출력 내용 및 시기에 대한 자세한 정보는 해당 옵션을 참조하십시오.

              이 옵션은 3.1.0에 추가되었으므로, 서버 측의 오래된 rsync는 세분화된 제어 시도를 거부할 수 있습니다 (하나 이상의 플래그를 서버로 보내야 하고 서버가 이를 이해하기에는 너무 오래된 경우).
              데몬을 다룰 때 위에 언급된 "최대 상세도(max verbosity)" 주의사항도 참조하십시오.

       --debug=FLAGS
              이  옵션을 사용하면 보고 싶은 디버그 출력에 대해 세분화된 제어를 할 수 있습니다. 개별 플래그 이름 뒤에는 레벨 번호가 올 수 있으며, 0은 해당 출력을 침묵시키고, 1은 기본 출력 레벨이며, 더 높은 숫자는 해당 플래그의 출력을 증가시킵니다 (더 높은 레벨을 지원하는 플래그의 경우).
              사용 가능한 모든 플래그 이름, 출력 내용 및 상세도 증가에 따라 추가되는 플래그 이름을 보려면 --debug=help를 사용하십시오. 몇 가지 예시:

                  rsync -avvv --debug=none src/ dest/
                  rsync -avA --del --debug=del2,acl src/ dest/

              특히 I/O 및 버퍼 디버깅과 관련된 일부 디버그 메시지는 --stderr=all 옵션이 지정된 경우에만 출력됩니다.

              3.2.0부터 이 옵션은 더 이상 서버 측으로 자동 전달되지 않습니다. 이는 전송의 각 측에 대해 다른 디버그 값을 지정하고, rsync 버전 중 하나에만 존재하는 새로운 디버그 옵션을 지정할 수 있도록 하기 위함입니다.
              양쪽에 동일한 옵션을 복제하려면 괄호 확장을 사용하여 타이핑을 줄일 수 있습니다. 이는 zsh 및 bash에서 작동합니다:

                  rsync -aiv {-M,}--debug=del2 src/ dest/

       --stderr=errors|all|client
              이 옵션은 어떤 프로세스가 stderr로 출력하고 정보 메시지도 stderr로 변경되는지 제어합니다. 모드 문자열은 약어로 지정할 수 있으므로 단일 문자 값을 사용해도 됩니다. 가능한 3가지 선택은 다음과 같습니다:

              o      errors - (기본값) 모든 rsync 프로세스가 오류를 stderr로 직접 보냅니다. 프로세스가 전송의 원격 측에 있더라도 마찬가지입니다.
                     정보 메시지는 프로토콜 스트림을 통해 클라이언트 측으로 전송됩니다.
                     stderr를 사용할 수 없는 경우 (즉, 소켓을 통해 데몬에 직접 연결할 때) 오류는 프로토콜 스트림을 통해 전송되는 것으로 대체됩니다.

              o      all - 모든 rsync 메시지(정보 및 오류)가 모든 (가능한) 프로세스에서 stderr로 직접 쓰여지도록 합니다.
                     이로 인해 stderr가 라인-버퍼링되고 (원시 버퍼링 대신) 정보 및 오류 메시지를 파일 핸들별로 분할하는 기능이 사라집니다.
                     디버깅을 하거나 여러 수준의 상세도를 사용하는 경우 이 옵션은 전송 스트림이 막히는 것을 방지하여 (교착 상태 버그가 발생하는 것을 방지해야 합니다) 도움이 될 수 있습니다.
                     또한 --debug가 일부 추가 I/O 관련 메시지를 활성화하도록 허용합니다.

              o      client - 모든 rsync 메시지가 프로토콜 스트림을 통해 클라이언트 측으로 전송되도록 합니다.
                     하나의 클라이언트 프로세스가 모든 메시지를 출력하며, 오류는 stderr로, 정보 메시지는 stdout으로 출력됩니다.
                     이는 이전 rsync 버전의 기본값이었지만, 많은 전송 데이터가 메시지보다 앞에 있을 때 오류 지연을 유발할 수 있습니다.
                     오래된 rsync로 파일을 푸시하는 경우, --stderr=all을 사용하는 것이 좋습니다. 이 구문은 여러 릴리스 동안 사용되었습니다.

              이 옵션은 rsync 3.2.3에 추가되었습니다. 이 버전은 또한 비기본 설정이 원격 측으로 전달되기 시작했으며, rsync는 이전 버전과의 호환성을 위해 --msgs2stderr 및 --no-msgs2stderr 옵션을 각각 all 및 client 설정으로 나타냅니다.
              새로운 rsync는 호환성을 유지하기 위해 이러한 이전 옵션 이름을 계속 허용합니다.

       --quiet, -q
              이 옵션은 전송 중에 제공되는 정보의 양을 줄이며, 특히 원격 서버의 정보 메시지를 억제합니다. 이 옵션은 cron에서 rsync를 호출할 때 유용합니다.

       --no-motd
              이 옵션은 데몬 전송 시작 시 클라이언트가 출력하는 정보에 영향을 줍니다.
              이것은 오늘의 메시지(MOTD) 텍스트를 억제하지만, 데몬이 "rsync host::" 요청에 응답하여 보내는 모듈 목록에도 영향을 미칩니다 (rsync 프로토콜의 제한 때문입니다).
              따라서 데몬에서 모듈 목록을 요청하려면 이 옵션을 생략하십시오.

       --ignore-times, -I
              일반적으로 rsync는 이미 동일한 크기이며 동일한 수정 타임스탬프를 가진 파일을 건너뜁니다.
              이 옵션은 이 "빠른 검사" 동작을 끄고, 모든 파일이 업데이트되도록 합니다.

              이 옵션은 --ignore-existing 및 --ignore-non-existing과 비교할 때 혼란스러울 수 있습니다.
              이들은 rsync가 더 적은 파일을 전송하도록 하는 반면, 이 옵션은 rsync가 더 많은 파일을 전송하도록 합니다.

       --size-only
              이것은 전송해야 할 파일을 찾는 rsync의 "빠른 검사" 알고리즘을 수정하여, (기본적으로) 크기 또는 최종 수정 시간이 변경된 파일을 전송하는 대신 크기가 변경된 파일만 찾도록 변경합니다.
              이는 타임스탬프를 정확하게 보존하지 못할 수 있는 다른 미러링 시스템을 사용한 후 rsync를 사용하기 시작할 때 유용합니다.

       --modify-window=NUM, -@
              두 타임스탬프를 비교할 때, rsync는 타임스탬프가 modify-window 값 이하로 차이가 나는 경우 동일한 것으로 간주합니다.
              기본값은 0이며, 정수 초 단위로만 일치합니다.
              음수 값을 지정하면 (수신자가 3.1.3 버전 이상인 경우) 나노초도 고려됩니다.
              1을 지정하는 것은 MS Windows FAT 파일 시스템으로/로부터 복사할 때 유용합니다. FAT는 시간을 2초 해상도로 나타내므로 (원래 시간과 최대 1초 차이 허용) 그렇습니다.

              모든 전송의 기본값이 나노초 비교를 사용하도록 하려면, ~/.popt 파일을 생성하고 다음 줄을 추가할 수 있습니다:

                  rsync alias -a -a@-1
                  rsync alias -t -t@-1

              이것이 기본값으로 설정되면, 나노초를 무시하도록 재정의하려면 --modify-window=0 (일명 -@0)을 지정해야 합니다. 예를 들어, ext3와 ext4 사이를 복사하거나 수신 rsync가 3.1.3보다 오래된 경우에 그렇습니다.

       --checksum, -c
              이것은 rsync가 파일이 변경되었고 전송이 필요한지 확인하는 방식을 변경합니다.
              이 옵션이 없으면 rsync는 (기본적으로) 전송자와 수신자 간에 각 파일의 크기와 최종 수정 시간이 일치하는지 확인하는 "빠른 검사"를 사용합니다.
              이 옵션은 일치하는 크기를 가진 각 파일에 대해 128비트 체크섬을 비교하도록 변경합니다.
              체크섬을 생성한다는 것은 양쪽 모두 전송 중인 모든 파일의 데이터를 읽는 데 많은 디스크 I/O를 소모한다는 것을 의미하므로, 이로 인해 속도가 상당히 느려질 수 있습니다 (그리고 이는 변경된 파일을 전송하기 위해 수행될 모든 읽기 작업 전에 발생합니다).

              보내는 측은 사용 가능한 파일 목록을 생성하는 파일 시스템 스캔을 수행하는 동안 체크섬을 생성합니다.
              수신 측은 변경된 파일을 스캔할 때 체크섬을 생성하며, 해당 보내는 측 파일과 동일한 크기를 가진 모든 파일의 체크섬을 확인합니다.
              크기가 변경되었거나 체크섬이 변경된 파일은 전송 대상으로 선택됩니다.

              rsync는 항상 전송된 각 파일이 수신 측에서 올바르게 재구성되었는지 확인하기 위해 파일 전송 중 생성되는 전체 파일 체크섬을 확인하지만, 이 자동 전송 후 확인은 이 옵션의 전송 전 "이 파일을 업데이트해야 하는가?" 확인과는 관련이 없습니다.

              사용되는 체크섬은 클라이언트와 서버 간에 자동 협상되지만, --checksum-choice (--cc) 옵션 또는 해당 옵션 섹션에서 논의된 환경 변수를 사용하여 재정의할 수 있습니다.

       --archive, -a
              이것은 -rlptgoD와 동일합니다. 재귀와 거의 모든 것을 보존하려는 경우에 빠르게 지정할 수 있는 방법입니다.
              ACL(-A), 확장 속성(-X), 접근 시간(-U), 생성 시간(-N), 하드 링크 찾기 및 보존(-H)은 포함되지 않는다는 점에 유의하십시오.

              위 등가성(equivalence)의 유일한 예외는 --files-from이 지정될 때입니다. 이 경우 -r은 암시되지 않습니다.

       --no-OPTION
              옵션 이름 앞에 "no-"를 붙여 하나 이상의 암시된 옵션을 끌 수 있습니다.
              모든 긍정 옵션이 부정 옵션을 가지는 것은 아니지만, 많은 옵션이 그러하며, 여기에는 암시된 옵션을 비활성화하는 데 사용될 수 있는 옵션(--no-D, --no-perms 등)이나 다양한 상황에서 다른 기본값을 가지는 옵션(--no-whole-file, --no-blocking-io, --no-dirs 등)이 포함됩니다.
              모든 유효한 부정 옵션은 "no-" 접두사 뒤에 짧은 옵션 이름과 긴 옵션 이름을 모두 허용합니다(예: --no-R은 --no-relative와 동일합니다).

              예를 들어, --archive (-a)를 사용하고 싶지만 --owner (-o)는 사용하고 싶지 않다면, -a를 -rlptgD로 변환하는 대신 -a --no-o (일명 --archive --no-owner)를 지정할 수 있습니다.

              옵션의 순서가 중요합니다: --no-r -a를 지정하면 -r 옵션이 결국 켜지게 되며, 이는 -a --no-r과 반대입니다.
              또한 --files-from 옵션의 부작용은 위치에 영향을 받지 않습니다. 이 옵션은 여러 옵션의 기본 상태에 영향을 미치고 -a의 의미를 약간 변경합니다 (--files-from 옵션에서 자세한 내용을 참조하십시오).

       --recursive, -r
              이것은 rsync에게 디렉토리를 재귀적으로 복사하도록 지시합니다.
              단일 디렉토리 스캔을 허용하는 옵션에 대해서는 --dirs (-d)도 참조하십시오.

              전송할 파일 목록을 생성하기 위한 증분 재귀에 대한 설명은 --inc-recursive 옵션을 참조하십시오.

       --inc-recursive, --i-r
              이 옵션은 파일 스캔 시 증분 재귀를 명시적으로 활성화합니다.
              이는 --recursive 옵션을 사용하고 전송 양쪽이 rsync 3.0.0 이상을 실행 중일 때 기본적으로 활성화됩니다.

              증분 재귀는 비증분 방식보다 훨씬 적은 메모리를 사용하며, 전송을 더 빨리 시작합니다 (전체 전송 계층 구조를 스캔할 필요 없이 파일을 전송하기 시작하므로).
              소스 파일에 재귀가 활성화되어 있지 않으면 이 옵션은 효과가 없습니다.

              일부 옵션은 rsync가 전체 파일 목록을 알아야 하므로 이러한 옵션은 증분 재귀 모드를 비활성화합니다. 여기에는 다음이 포함됩니다:

              o      --delete-before (--delete의 이전 기본값)

              o      --delete-after

              o      --prune-empty-dirs

              o      --delay-updates

              --delete를 증분 재귀와 호환시키기 위해 rsync 3.0.0은 --delete-during을 기본 삭제 모드로 만들었습니다 (이는 2.6.4에 처음 추가되었습니다).

              증분 재귀의 한 가지 부작용은 재귀적으로 스캔된 디렉토리 내의 누락된 하위 디렉토리가 (기본적으로) 하위 디렉토리로 재귀하기 전에 생성된다는 것입니다.
              이러한 조기 생성 지점(비증분 재귀와 비교하여)은 rsync가 완료된 디렉토리의 수정 시간을 즉시 설정할 수 있도록 합니다 (많은 재귀적 복사가 완료될 때까지 기다릴 필요 없이).
              그러나 이러한 초기 디렉토리는 아직 완료된 모드, mtime 또는 소유권이 설정되지 않았습니다. 하위 디렉토리 복사가 실제로 시작될 때까지는 더 제한적인 권한을 가집니다.
              이러기 조기-생성 관용구는 --omit-dir-times 옵션을 사용하여 피할 수 있습니다.

              증분 재귀는 --no-inc-recursive (--no-i-r) 옵션을 사용하여 비활성화할 수 있습니다.

       --no-inc-recursive, --no-i-r
              --recursive 옵션의 새로운 증분 재귀 알고리즘을 비활성화합니다.
              이렇게 하면 rsync는 파일 전송을 시작하기 전에 전체 파일 목록을 스캔합니다.
              자세한 내용은 --inc-recursive를 참조하십시오.

       --relative, -R
              상대 경로를 사용합니다. 즉, 명령줄에 지정된 전체 경로 이름이 파일 이름의 마지막 부분만 전송되는 대신 서버로 전송됩니다.
              이는 여러 디렉토리를 동시에 전송하려는 경우에 특히 유용합니다. 예를 들어, 다음 명령을 사용했다면:

                  rsync -av /foo/bar/baz.c remote:/tmp/

              원격 머신의 /tmp/에 baz.c라는 이름의 파일이 생성됩니다. 대신 다음을 사용했다면:

                  rsync -avR /foo/bar/baz.c remote:/tmp/

              그러면 원격 머신에 /tmp/foo/bar/baz.c라는 이름의 파일이 생성되어 전체 경로가 보존됩니다.
              이러한 추가 경로 요소는 "암시된 디렉토리"(즉, 위 예시에서 "foo" 및 "foo/bar" 디렉토리)라고 불립니다.

              rsync 3.0.0부터 rsync는 이러한 암시된 디렉토리를 항상 파일 목록에 실제 디렉토리로 보냅니다.
              경로 요소가 보내는 측에서 실제로 심볼릭 링크인 경우에도 마찬가지입니다.
              이는 경로에 심볼릭 링크가 포함되어 있다는 것을 알지 못하고 파일의 전체 경로를 복사할 때 발생하는 예상치 못한 동작을 방지합니다.
              서버 측 심볼릭 링크를 복제하려면 심볼릭 링크는 경로를 통해 포함하고, 참조 디렉토리는 실제 경로를 통해 포함하십시오.
              오래된 rsync를 보내는 측에서 다루는 경우, --no-implied-dirs 옵션을 사용해야 할 수도 있습니다.

              또한 각 경로에 대해 암시된 디렉토리로 전송되는 경로 정보의 양을 제한할 수도 있습니다.
              보내는 측에 최신 rsync(2.6.7부터)가 있는 경우, 소스 경로에 점과 슬래시를 삽입할 수 있습니다:

                  rsync -avR /foo/./bar/baz.c remote:/tmp/

              그러면 원격 머신에 /tmp/bar/baz.c가 생성됩니다. (점 뒤에는 슬래시가 와야 하므로 "/foo/."는 축약되지 않습니다.)
              오래된 rsync 버전의 경우, 소스 경로를 제한하기 위해 chdir을 사용해야 합니다.
              예를 들어, 파일을 푸시할 때:

                  (cd /foo; rsync -avR bar/baz.c remote:/tmp/)

              (괄호는 두 명령을 서브 셸에 넣으므로 "cd" 명령이 향후 명령에 영향을 미치지 않습니다.)
              오래된 rsync에서 파일을 가져오는 경우, 이 구문을 사용하십시오 (단, 데몬이 아닌 전송에만 해당):

                  rsync -avR --rsync-path="cd /foo; rsync" \
                       remote:bar/baz.c /tmp/

       --no-implied-dirs
              이 옵션은 --relative 옵션의 기본 동작에 영향을 줍니다.
              이 옵션이 지정되면, 소스 이름에서 암시된 디렉토리의 속성은 전송에 포함되지 않습니다.
              이는 대상 시스템의 해당 경로 요소가 존재하는 경우 변경되지 않고 유지되며, 누락된 암시된 디렉토리는 기본 속성으로 생성됨을 의미합니다.
              이는 이러한 암시된 경로 요소가 수신 측에서 디렉토리에 대한 심볼릭 링크와 같이 큰 차이를 가질 수도 있게 합니다.

              예를 들어, 명령줄 인자 또는 files-from 항목이 rsync에게 "path/foo/file" 파일을 전송하도록 지시했고, --relative를 사용하면 "path" 및 "path/foo" 디렉토리가 암시됩니다.
              만약 "path/foo"가 대상 시스템에서 "bar"에 대한 심볼릭 링크인 경우, 수신 rsync는 일반적으로 "path/foo"를 삭제하고, 디렉토리로 다시 생성하고, 새 디렉토리로 파일을 수신합니다.
              --no-implied-dirs를 사용하면 수신 rsync는 기존 경로 요소를 사용하여 "path/foo/file"을 업데이트합니다.
              이는 파일이 결국 "path/bar"에 생성됨을 의미합니다.
              이러한 링크 보존을 달성하는 또 다른 방법은 --keep-dirlinks 옵션을 사용하는 것입니다 (이는 전송의 나머지 부분에 있는 디렉토리에 대한 심볼릭 링크에도 영향을 미칩니다).

              rsync 3.0.0보다 오래된 rsync에서 파일을 가져올 때, 보내는 측에서 요청한 경로에 심볼릭 링크가 있고 암시된 디렉토리가 일반 디렉토리로 전송되기를 원한다면 이 옵션을 사용해야 할 수도 있습니다.

       --backup, -b
              이 옵션을 사용하면 각 파일이 전송되거나 삭제될 때 기존 대상 파일의 이름이 바뀝니다.
              --backup-dir 및 --suffix 옵션을 사용하여 백업 파일이 저장될 위치와 (있다면) 어떤 접미사가 추가될지 제어할 수 있습니다.

              --backup-dir을 지정하지 않으면:

              1.     --omit-dir-times 옵션이 강제 적용됩니다.

              2.     --delete (단, --delete-excluded 없음)를 사용하면 rsync는 백업 접미사에 대한 "보호" 필터 규칙을 기존 모든 필터 끝에 추가합니다.
                     이 규칙은 이전에 백업된 파일이 삭제되는 것을 방지합니다. 규칙은 다음과 같습니다: -f "P *~".

              자신만의 필터 규칙을 제공하는 경우, 필터 목록의 더 높은 위치에 자신만의 제외/보호 규칙을 수동으로 삽입하여 효과를 발휘할 수 있는 충분히 높은 우선순위를 가지도록 해야 할 수도 있습니다 (예: 규칙에 후행 포함/제외 *가 지정된 경우 자동 추가된 규칙은 도달되지 않습니다).

       --backup-dir=DIR
              이것은 --backup 옵션을 암시하며, rsync에게 모든 백업을 수신 측의 지정된 디렉토리에 저장하도록 지시합니다.
              이는 증분 백업에 사용할 수 있습니다. --suffix 옵션을 사용하여 백업 접미사를 추가로 지정할 수 있습니다 (그렇지 않으면 지정된 디렉토리에 백업된 파일은 원래 파일 이름을 유지합니다).

              상대 경로를 지정하면 백업 디렉토리가 대상 디렉토리에 상대적이므로, 절대 경로 또는 "../"로 시작하는 경로를 지정하는 것이 좋습니다.
              rsync 데몬이 수신자인 경우, 백업 디렉토리가 모듈의 경로 계층을 벗어날 수 없으므로, 삭제하거나 그 안에 복사하지 않도록 특별히 주의하십시오.

       --suffix=SUFFIX
              이 옵션을 사용하면 --backup (-b) 옵션과 함께 사용되는 기본 백업 접미사를 재정의할 수 있습니다.
              --backup-dir이 지정되지 않은 경우 기본 접미사는 ~이며, 그렇지 않으면 빈 문자열입니다.

       --update, -u
              이것은 rsync가 대상에 존재하고 소스 파일보다 수정 시간이 더 새로운 파일을 건너뛰도록 강제합니다.
              (기존 대상 파일의 수정 시간이 소스 파일의 수정 시간과 동일하다면, 크기가 다른 경우 업데이트됩니다.)

              이는 디렉토리, 심볼릭 링크 또는 기타 특수 파일의 복사에는 영향을 미치지 않습니다.
              또한, 보내는 측과 받는 측 간의 파일 형식 차이는 날짜에 관계없이 항상 업데이트할 만큼 중요하게 간주됩니다.
              다시 말해, 소스에 디렉토리가 있고 대상에 파일이 있는 경우, 타임스탬프와 관계없이 전송이 발생합니다.

              이 옵션은 TRANSFER RULE이므로, 어떤 제외 부작용도 기대하지 마십시오.

              --inplace와 --update를 결합하기로 선택한 사람들을 위한 주의사항: 중단된 전송은 매우 최근 수정 시간을 가진 부분 파일을 수신 측에 남겨두므로, 전송을 다시 실행해도 중단된 파일이 계속 진행되지 않을 수 있습니다.
              따라서, 중단된 진행 중인 파일을 처리하기 위한 수동 단계를 구현하지 않는 한, 일반적으로 이 옵션을 --inplace와 결합하는 것을 피하는 것이 가장 좋습니다.

       --inplace
              이 옵션은 데이터 업데이트가 필요한 파일을 rsync가 전송하는 방식을 변경합니다.
              파일의 새 복사본을 생성하고 완료 시 제자리로 이동하는 기본 방식 대신, rsync는 업데이트된 데이터를 대상 파일에 직접 씁니다.

              이것은 여러 가지 효과를 가집니다:

              o      하드 링크가 끊어지지 않습니다. 이는 새 데이터가 대상 파일에 대한 다른 하드 링크를 통해서도 보이게 된다는 의미입니다.
                     또한, 다중 링크된 대상 파일에 다른 소스 파일을 복사하려고 하면 대상 데이터가 계속해서 바뀌는 "줄다리기"가 발생할 수 있습니다.

              o      사용 중인 바이너리는 업데이트할 수 없습니다 (OS가 이를 방지하거나, 데이터를 스왑인하려고 시도하는 바이너리가 오작동하거나 충돌합니다).

              o      파일의 데이터는 전송 중에 일관성 없는 상태로 유지되며, 전송이 중단되거나 업데이트에 실패하면 그 상태로 남게 됩니다.

              o      rsync가 쓸 수 없는 파일은 업데이트할 수 없습니다. 슈퍼유저는 어떤 파일이든 업데이트할 수 있지만, 일반 사용자는 파일 열기 및 쓰기 권한이 부여되어야 성공적으로 쓸 수 있습니다.

              o      대상 파일의 일부 데이터가 파일의 나중에 위치한 데이터를 복사하기 전에 덮어쓰여지면 rsync의 델타-전송 알고리즘 효율성이 저하될 수 있습니다.
                     --backup을 사용하는 경우에는 해당되지 않습니다. rsync는 백업 파일을 전송의 기본 파일로 사용하는 데 충분히 똑똑하기 때문입니다.

              경고: 이 옵션을 사용하여 다른 사용자가 액세스하는 파일을 업데이트해서는 안 되므로, 복사 시 이 옵션을 사용하기로 선택할 때는 주의하십시오.

              이 옵션은 블록 기반 변경 또는 추가된 데이터가 있는 대용량 파일을 전송하는 데 유용하며, 네트워크가 아닌 디스크에 바인딩된 시스템에서도 유용합니다.
              또한 사소한 변경만 있는 파일의 전체 내용을 복사-온-쓰기 파일 시스템 스냅샷이 분기하는 것을 방지하는 데 도움이 될 수 있습니다.

              이 옵션은 --partial을 암시하지만 (중단된 전송은 파일을 삭제하지 않으므로), --partial-dir 및 --delay-updates와 충돌합니다.
              rsync 2.6.4 이전에는 --inplace가 --compare-dest 및 --link-dest와도 호환되지 않았습니다.

       --append
              이 특별한 복사 모드는 수신 측의 기존 내용이 전송 측의 내용과 동일하다고 알려진, 크기가 계속 증가하는 파일을 효율적으로 업데이트할 때만 작동합니다.
              전송되는 모든 파일이 공유되고 증가하는 파일인지 100% 확신하지 못하는 경우 --append를 사용하는 것은 위험할 수 있습니다.
              따라서 이 기준에 맞지 않는 파일을 걸러내기 위해 필터 규칙을 사용해야 합니다.

              Rsync는 파일의 기존 내용을 확인하지 않고 (추가하는 내용만 확인) 이러한 증가하는 파일을 제자리에서 업데이트합니다.
              rsync는 수신 측에 존재하고 보내는 측의 관련 파일보다 짧지 않은 파일은 건너뜁니다 (이는 새 파일은 전송됨을 의미합니다).
              또한 전송 협상 중에 보내는 측의 파일 크기가 줄어드는 파일은 건너뜁니다 (이러한 경우 rsync는 "줄어든" 파일에 대해 경고합니다).

              파일 전송이 필요 없는 경우 파일의 내용이 아닌 속성(예: 권한, 소유권 등) 업데이트를 방해하지 않으며, 디렉토리나 비정규 파일의 업데이트에도 영향을 미치지 않습니다.

       --append-verify
              이 특별한 복사 모드는 --append와 유사하게 작동하지만, 파일의 모든 데이터가 체크섬 검증에 포함됩니다 (효율성은 떨어지지만 잠재적으로 더 안전합니다).
              전송되는 모든 파일이 공유되고 증가하는 파일인지 100% 확신하지 못하는 경우 이 옵션을 사용하는 것은 위험할 수 있습니다.
              자세한 내용은 --append 옵션을 참조하십시오.

              참고: rsync 3.0.0 이전에는 --append 옵션이 --append-verify처럼 작동했습니다. 따라서 이전 rsync와 상호 작용하는 경우 (또는 전송이 30 이전 프로토콜을 사용하는 경우) 두 append 옵션 중 하나를 지정하면 --append-verify 전송이 시작됩니다.

       --dirs, -d
              보내는 측에게 발견되는 모든 디렉토리를 포함하도록 지시합니다.
              --recursive와 달리, 디렉토리 이름이 "."으로 지정되었거나 후행 슬래시로 끝나는 경우(예: ".", "dir/.", "dir/", 등)를 제외하고는 디렉토리의 내용은 복사되지 않습니다.
              이 옵션이나 --recursive 옵션이 없으면 rsync는 발견하는 모든 디렉토리를 건너뜁니다 (그리고 각 디렉토리에 대해 해당 메시지를 출력합니다).
              --dirs와 --recursive를 모두 지정하면 --recursive가 우선합니다.

              --dirs 옵션은 --files-from 옵션 또는 --list-only 옵션(암시된 --list-only 사용 포함)에서 --recursive가 지정되지 않았을 경우 암시됩니다 (그래서 디렉토리가 목록에 보이게 됩니다).
              이를 끄고 싶다면 --no-dirs (또는 --no-d)를 지정하십시오.

              오래된 rsync가 재귀 없이 단일 디렉토리를 나열하도록 하기 위해 -r --exclude='/*/*' 해킹을 사용하도록 rsync에 지시하는 역방향 호환성 도우미 옵션인 --old-dirs (--old-d)도 있습니다.

       --mkpath
              대상 경로의 누락된 모든 경로 구성 요소를 생성합니다.

              기본적으로 rsync는 대상 경로의 마지막 구성 요소만 존재하지 않을 수 있도록 허용합니다.
              이는 대상 경로의 유효성을 검사하는 데 도움이 되기 위한 시도입니다.
              이 옵션을 사용하면 rsync는 mkdir -p $DEST_PATH가 수신 측에서 실행된 것처럼 누락된 모든 대상 경로 구성 요소를 생성합니다.

              대상 경로를 지정할 때 후행 슬래시를 포함하면 파일 목록에 단일 항목이 있더라도 전체 경로가 생성될 디렉토리 이름으로 처리됩니다.
              rsync가 최종 대상 경로 구성 요소를 디렉토리로 생성해야 할지 여부를 결정하는 방법에 대한 자세한 내용은 COPYING TO A DIFFERENT NAME 섹션을 참조하십시오.

              새로 생성된 대상 디렉토리가 보내는 측의 디렉토리와 일치하도록 하려면 --mkpath 대신 --relative (-R)를 사용해야 합니다.
              예를 들어, 다음 두 명령은 동일한 대상 트리를 생성하지만, 두 번째 명령만 "some/extra/path" 구성 요소가 보내는 측의 디렉토리와 일치하도록 보장합니다:

                  rsync -ai --mkpath host:some/extra/path/*.c some/extra/path/
                  rsync -aiR host:some/extra/path/*.c ./

       --links, -l
              각 심볼릭 링크에 대해 "비정규 파일" 경고를 시끄럽게 무시하는 대신, 전송된 파일에 심볼릭 링크를 추가합니다.
              --info=nonreg0을 지정하여 경고를 억제할 수도 있습니다.

              심볼릭 링크의 기본 처리는 수신 측에서 각 심볼릭 링크의 변경되지 않은 값을 다시 생성하는 것입니다.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --copy-links, -L
              보내는 측은 전송에서 발견된 각 심볼릭 링크를 참조 항목으로 변환하고, 심볼릭 링크 체인을 따라 참조하는 파일 또는 디렉토리로 이동합니다.
              심볼릭 링크 체인이 끊어지면 오류가 출력되고 파일은 전송에서 제외됩니다.

              이 옵션은 전송에서 심볼릭 링크가 남지 않으므로, 심볼릭 링크에 영향을 미치는 다른 옵션보다 우선합니다.

              이 옵션은 수신 측의 기존 심볼릭 링크 처리를 변경하지 않습니다. 이는 rsync 2.6.3 이전 버전과 달리 수신 측에게도 심볼릭 링크를 따르도록 지시하는 부작용이 있었던 것과 다릅니다.
              최신 rsync는 이 옵션을 원격 수신자에게 전달하지 않으므로 (보내는 측만 알면 되므로), 이 주의사항은 rsync 클라이언트가 2.6.7보다 오래된 버전(이때 -L이 수신자에게 전달되지 않게 됨)을 사용하는 경우에만 영향을 미칩니다.

              디렉토리에 대한 심볼릭 링크가 수신 측에서 실제 디렉토리로 처리되도록 해야 하는 경우 --keep-dirlinks (-K)를 참조하십시오.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --copy-unsafe-links
              이것은 rsync에게 복사된 트리 외부를 가리키는 심볼릭 링크의 참조 대상을 복사하도록 지시합니다.
              절대 심볼릭 링크도 일반 파일처럼 처리되며, --relative를 사용할 때는 소스 경로 자체에 있는 심볼릭 링크도 마찬가지입니다.

              참고로, 차단 지점은 전송의 최상단입니다. 이는 rsync가 자세한 출력에서 언급하지 않는 경로의 일부입니다.
              만약 "/src/subdir"를 "/dest/"로 복사한다면, "subdir" 디렉토리는 전송 트리 내부의 이름이지 전송의 최상단(/src)이 아니므로, 생성된 상대 심볼릭 링크가 /src 및 /dest 디렉토리 내부의 다른 이름을 참조하는 것은 합법적입니다.
              대신 "/src/subdir/" (후행 슬래시 포함)를 "/dest/subdir"로 복사한다면, "subdir" 외부의 어떤 파일에도 심볼릭 링크를 허용하지 않습니다.

              안전한 심볼릭 링크는 --links가 지정되거나 암시된 경우에만 복사됩니다. --copy-unsafe-links 옵션은 --copy-links와 결합될 때 추가적인 효과가 없습니다.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --safe-links
              이것은 수신 rsync에게 복사된 트리 외부를 가리키는 전송의 모든 심볼릭 링크를 무시하도록 지시합니다. 모든 절대 심볼릭 링크도 무시됩니다.

              이 무시는 수신 측에서 발생하므로, 보내는 측이 심볼릭 링크를 변형했더라도 (--munge-links를 사용할 때) 여전히 효과적입니다.
              심볼릭 링크가 안전하지 않은 것으로 간주되어 건너뛰어질 때, 전송에 파일이 존재하면 수신 측의 일치하는 파일이 삭제되는 것을 방지하므로 삭제에도 영향을 미칩니다.

              이 옵션은 --links (또는 --archive)와 함께 사용되어야 전송에서 심볼릭 링크가 조건부로 무시될 수 있습니다. 그 효과는 --copy-unsafe-links에 의해 재정의됩니다.

              --relative와 함께 이 옵션을 사용하면 예상치 못한 결과가 발생할 수 있습니다.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --munge-links
              이 옵션은 전송의 한쪽에만 영향을 미치며, rsync에게 파일을 수신할 때 심볼릭 링크 값을 변형하거나 파일을 보낼 때 심볼릭 링크 값을 복원하도록 지시합니다.
              변형된 값은 심볼릭 링크를 디스크에서 사용할 수 없게 만들지만, 심볼릭 링크의 원래 내용을 복구할 수 있도록 합니다.

              서버 측 rsync는 클라이언트의 지식 없이 이 옵션을 종종 활성화합니다. 예를 들어 rsync 데몬의 구성 파일에서 또는 rrsync (제한된 rsync) 스크립트에 주어진 옵션에 의해 그렇습니다.
              클라이언트 측에서 지정할 경우, 클라이언트 측이 변형된 심볼릭 링크를 가지고 있거나 필요로 한다면 옵션을 정상적으로 지정하거나, -M--munge-links를 사용하여 서버가 변형된 심볼릭 링크를 가지고 있거나 필요로 할 때 서버에 옵션을 제공하십시오.
              로컬 전송의 경우, 클라이언트가 보내는 측이므로, 옵션을 직접 지정하면 심볼릭 링크가 복원되고, 원격 옵션으로 지정하면 심볼릭 링크가 변형됩니다.

              이 옵션은 --remote-option을 통해 데몬으로 전송될 때 효과가 없습니다. 데몬은 "munge symlinks" 매개변수를 통해 변형된 심볼릭 링크를 원하는지 구성하기 때문입니다.

              심볼릭 링크 값은 전송 시 변형/복원되므로, 심볼릭 링크를 비심볼릭 링크로 변환하는 모든 옵션은 --safe-links를 제외하고 변형/복원보다 먼저 발생합니다.
              --safe-links는 수신자가 내리는 결정이므로, 변형/복원된 값을 기반으로 결정을 내립니다.
              이는 수신자가 변형을 활성화한 경우, --safe-links를 사용하면 모든 심볼릭 링크가 무시됨을 의미합니다 (모두 절대 경로이므로).

              rsync가 심볼릭 링크를 변형하는 방법은 각 값 앞에 문자열 "/rsyncd-munged/"를 붙이는 것입니다.
              이는 디렉토리가 존재하지 않는 한 링크를 사용할 수 없게 합니다.
              이 옵션이 활성화되면, rsync는 해당 경로가 디렉토리이거나 디렉토리에 대한 심볼릭 링크이면 실행을 거부합니다 (시작 시에만 확인합니다).
              제자리에서 하나 이상의 심볼릭 링크를 변형/복원하는 방법은 소스 코드의 support 디렉토리에 있는 "munge-symlinks" python 스크립트도 참조하십시오.

       --copy-dirlinks, -k
              이 옵션은 보내는 측이 디렉토리에 대한 심볼릭 링크를 실제 디렉토리처럼 처리하도록 합니다.
              이는 --copy-links를 사용할 때처럼 비디렉토리 심볼릭 링크가 영향을 받지 않도록 하려는 경우에 유용합니다.

              이 옵션이 없으면, 보내는 측이 디렉토리를 디렉토리에 대한 심볼릭 링크로 교체한 경우, 받는 측은 새 심볼릭 링크를 방해하는 모든 것을 삭제합니다.
              디렉토리 계층 구조도 포함합니다 (--force 또는 --delete가 적용 중인 한).

              수신 측에 대한 유사한 옵션은 --keep-dirlinks를 참조하십시오.

              --copy-dirlinks는 소스에 있는 디렉토리에 대한 모든 심볼릭 링크에 적용됩니다.
              지정된 몇몇 심볼릭 링크만 따르려면, 후행 슬래시와 함께 추가 소스 인자로 전달하고, --relative를 사용하여 경로가 올바르게 일치하도록 하는 트릭을 사용할 수 있습니다.
              예를 들어:

                  rsync -r --relative src/./ src/./follow-me/ dest/

              이것이 작동하는 이유는 rsync가 주어진 소스 인자에 lstat(2)를 호출하고, 후행 슬래시가 lstat(2)가 심볼릭 링크를 따르도록 하여 파일 목록에 디렉토리가 생성되고, 이는 "src/./" 스캔 중에 발견된 심볼릭 링크를 재정의하기 때문입니다.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --keep-dirlinks, -K
              이 옵션은 수신 측이 디렉토리에 대한 심볼릭 링크를 실제 디렉토리처럼 처리하도록 하지만, 보내는 측의 실제 디렉토리와 일치하는 경우에만 그렇습니다.
              이 옵션이 없으면 수신자의 심볼릭 링크는 삭제되고 실제 디렉토리로 교체됩니다.

              예를 들어, "file"을 포함하는 디렉토리 "foo"를 전송한다고 가정해 봅시다.
              그러나 "foo"는 수신자 측에서 디렉토리 "bar"에 대한 심볼릭 링크입니다.
              --keep-dirlinks가 없으면 수신자는 심볼릭 링크 "foo"를 삭제하고, 디렉토리로 다시 생성하고, 새 디렉토리로 파일을 수신합니다.
              --keep-dirlinks를 사용하면 수신자는 심볼릭 링크를 유지하고 "file"은 "bar"에 저장됩니다.

              주의할 점: --keep-dirlinks를 사용하는 경우, 복사본의 모든 심볼릭 링크를 신뢰하거나 수신 측에서 --munge-links 옵션을 활성화해야 합니다!
              신뢰할 수 없는 사용자가 실제 디렉토리에 대한 자신만의 심볼릭 링크를 생성할 수 있는 경우, 해당 사용자는 (후속 복사 시) 심볼릭 링크를 실제 디렉토리로 교체하고 심볼릭 링크가 참조하는 디렉토리의 내용에 영향을 미칠 수 있습니다.
              백업 복사의 경우, 수신 계층 구조를 수정하기 위해 심볼릭 링크 대신 바인드 마운트와 같은 것을 사용하는 것이 좋습니다.

              보내는 측에 대한 유사한 옵션은 --copy-dirlinks를 참조하십시오.

              다중 옵션 정보는 SYMBOLIC LINKS 섹션을 참조하십시오.

       --hard-links, -H
              이것은 rsync에게 소스에서 하드 링크된 파일을 찾아 대상에서 해당 파일을 함께 링크하도록 지시합니다.
              이 옵션이 없으면 소스의 하드 링크된 파일은 별개의 파일처럼 처리됩니다.

              이 옵션은 대상의 하드 링크 패턴이 소스의 패턴과 정확히 일치하도록 반드시 보장하지는 않습니다.
              대상이 추가 하드 링크로 끝날 수 있는 경우는 다음과 같습니다:

              o      대상이 불필요한 하드 링크를 포함하는 경우 (소스 파일 목록에 있는 것보다 더 많은 링크), 복사 알고리즘은 명시적으로 링크를 끊지 않습니다.
                     그러나 하나 이상의 경로에 내용 차이가 있는 경우, 일반 파일 업데이트 프로세스는 해당 추가 링크를 끊습니다 (--inplace 옵션을 사용하지 않는 한).

              o      하드 링크를 포함하는 --link-dest 디렉토리를 지정하는 경우, 대상 파일을 --link-dest 파일과 링크하는 것은 --link-dest 연결로 인해 대상의 일부 경로가 함께 링크될 수 있습니다.

              rsync는 전송 집합 내에 있는 파일 간의 하드 링크만 감지할 수 있습니다.
              rsync가 전송 외부 파일에 추가 하드 링크 연결이 있는 파일을 업데이트하면 해당 링크는 끊어집니다.
              이러한 손상을 피하기 위해 --inplace 옵션을 사용하려는 경우, 의도하지 않은 변경이 남은 하드 링크로 인해 발생하지 않도록 파일이 업데이트되는 방식을 신중하게 파악해야 합니다 (--inplace 옵션에 대한 추가 주의사항 참조).

              증분 재귀가 활성화된 경우 (--inc-recursive 참조), rsync는 계층 구조의 다른 곳에 해당 내용에 대한 다른 링크가 존재한다는 것을 발견하기 전에 누락된 하드 링크된 파일을 전송할 수 있습니다.
              이는 전송의 정확성(즉, 어떤 파일이 하드 링크되어 있는지)에는 영향을 미치지 않지만, 효율성(즉, 나중에 전송에서 하드 링크된 파일 집합의 다른 구성원에서 발견될 수 있었던 하드 링크된 파일의 새, 초기 복사본에 대한 데이터 복사)에는 영향을 미칩니다.
              이러한 비효율성을 피하는 한 가지 방법은 --no-inc-recursive 옵션을 사용하여 증분 재귀를 비활성화하는 것입니다.

       --perms, -p
              이 옵션은 수신 rsync가 대상 권한을 소스 권한과 동일하게 설정하도록 합니다. (--chmod 옵션은 rsync가 소스 권한으로 간주하는 것을 수정하는 방법을 참조하십시오.)

              이 옵션이 꺼져 있으면 권한은 다음과 같이 설정됩니다:

              o      기존 파일 (업데이트된 파일 포함)은 기존 권한을 유지하지만, --executability 옵션은 파일의 실행 권한만 변경할 수 있습니다.

              o      새 파일은 수신 프로세스의 umask 또는 대상 디렉토리의 기본 ACL을 통해 지정된 권한과 함께 소스 파일의 권한이 마스킹되어 "일반" 권한 비트가 설정되고, 새 디렉토리가 부모 디렉토리에서 setgid 비트를 상속하는 경우를 제외하고는 특수 권한 비트는 비활성화됩니다.

              따라서 --perms와 --executability가 모두 비활성화되면 rsync의 동작은 cp(1) 및 tar(1)와 같은 다른 파일 복사 유틸리티와 동일합니다.

              요약하자면: 대상 파일(기존 파일과 새 파일 모두)에 소스 권한을 부여하려면 --perms를 사용하십시오.
              새 파일에 대상 기본 권한을 부여하려면(기존 파일은 변경하지 않고), --perms 옵션이 꺼져 있는지 확인하고 --chmod=ugo=rwX를 사용하십시오(모든 비마스킹된 비트가 활성화되도록 보장합니다).
              이 후자의 동작을 더 쉽게 타이핑하고 싶다면, 다음과 같이 ~/.popt 파일에 이 줄을 추가하여 popt 별칭을 정의할 수 있습니다(다음은 -Z 옵션을 정의하며, 대상 디렉토리의 기본 그룹을 사용하기 위해 --no-g를 포함합니다):

                  rsync alias -Z --no-p --no-g --chmod=ugo=rwX

              그런 다음 이 새로운 옵션을 다음과 같은 명령에 사용할 수 있습니다:

                  rsync -avZ src/ dest/

              (주의: -a가 -Z 뒤에 오지 않도록 하십시오. 그렇지 않으면 위에 언급된 두 --no-* 옵션이 다시 활성화됩니다.)

              --perms가 꺼져 있을 때 새로 생성된 디렉토리의 대상 setgid 비트 보존은 rsync 2.6.7에 추가되었습니다.
              오래된 rsync 버전은 --perms가 꺼져 있을 때 새로 생성된 파일에 대해 세 가지 특수 권한 비트를 잘못 보존했으며, 새로 생성된 디렉토리의 대상 setgid 비트 설정을 재정의했습니다.
              기본 ACL 준수는 rsync 2.6.7용 ACL 패치에 추가되었으므로, 오래된 (또는 ACL이 활성화되지 않은) rsync는 기본 ACL이 존재하더라도 umask를 사용합니다.
              (이러한 동작에 영향을 미치는 것은 수신 rsync의 버전임을 명심하십시오.)

       --executability, -E
              이 옵션은 --perms가 활성화되지 않았을 때 rsync가 일반 파일의 실행 가능성(또는 비실행 가능성)을 보존하도록 합니다.
              일반 파일은 권한에 'x' 중 하나 이상이 켜져 있으면 실행 가능한 것으로 간주됩니다.
              기존 대상 파일의 실행 가능성이 해당 소스 파일과 다를 때, rsync는 대상 파일의 권한을 다음과 같이 수정합니다:

              o      파일을 비실행 가능하게 만들려면 rsync는 모든 'x' 권한을 끕니다.

              o      파일을 실행 가능하게 만들려면 rsync는 해당 'r' 권한이 활성화된 모든 'x' 권한을 켭니다.

              --perms가 활성화되면 이 옵션은 무시됩니다.

       --acls, -A
              이 옵션은 rsync가 대상 ACL을 소스 ACL과 동일하게 업데이트하도록 합니다. 이 옵션은 또한 --perms를 암시합니다.

              이 옵션이 제대로 작동하려면 소스 및 대상 시스템이 호환 가능한 ACL 항목을 가지고 있어야 합니다.
              호환되지 않는 ACL을 백업하고 복원하는 방법에 대해서는 --fake-super 옵션을 참조하십시오.

       --xattrs, -X
              이 옵션은 rsync가 대상 확장 속성을 소스 확장 속성과 동일하게 업데이트하도록 합니다.

              확장-속성 네임스페이스를 지원하는 시스템의 경우, 슈퍼유저가 수행하는 복사는 system.*를 제외한 모든 네임스페이스를 복사합니다.
              일반 사용자는 user.* 네임스페이스만 복사합니다.
              일반 사용자로 비-user 네임스페이스를 백업하고 복원하려면 --fake-super 옵션을 참조하십시오.

              위 이름 필터링은 x 수정자와 함께 하나 이상의 필터 옵션을 사용하여 재정의할 수 있습니다.
              xattr에 영향을 미치는 필터 규칙을 지정하면 rsync는 자체 시스템/사용자 필터링은 물론, 어떤 xattr 이름을 복사하고 어떤 이름을 삭제할 수 있는지에 대한 추가 필터링을 수행하도록 요구합니다.
              예를 들어, system 네임스페이스를 건너뛰려면 다음과 같이 지정할 수 있습니다:

                  --filter='-x system.*'

              user 네임스페이스를 제외한 모든 네임스페이스를 건너뛰려면 다음과 같이 부정-user 일치를 지정할 수 있습니다:

                  --filter='-x! user.*'

              어떤 속성도 삭제되지 않도록 하려면 모든 이름을 제외하는 수신자 전용 규칙을 지정할 수 있습니다:

                  --filter='-xr *'

              -X 옵션은 --fake-super에 사용되는 것과 같은 rsync의 특수 xattr 값을 복사하지 않습니다 (옵션을 반복하지 않는 한, 예: -XX).
              이 "모든 xattrs 복사" 모드는 --fake-super와 함께 사용할 수 없습니다.

       --chmod=CHMOD
              이 옵션은 rsync에게 전송 중인 파일의 권한에 하나 이상의 쉼표로 구분된 "chmod" 모드를 적용하도록 지시합니다.
              결과 값은 보내는 측이 파일에 제공한 권한인 것처럼 처리됩니다.
              이는 --perms가 활성화되지 않은 경우 이 옵션이 기존 파일에 영향을 미 미치지 않는 것처럼 보일 수 있다는 의미입니다.

              chmod(1) 맨페이지에 지정된 일반적인 파싱 규칙 외에도, 디렉토리에만 적용되어야 하는 항목은 'D'를 접두사로 붙여 지정할 수 있고, 파일에만 적용되어야 하는 항목은 'F'를 접두사로 붙여 지정할 수 있습니다.
              예를 들어, 다음은 모든 디렉토리가 set-gid로 표시되고, 어떤 파일도 다른 사용자가 쓸 수 없으며, 둘 다 사용자-쓰기 가능하고 그룹-쓰기 가능하며, 모든 비트에 걸쳐 일관된 실행 가능성을 갖도록 보장합니다:

                  --chmod=Dg+s,ug+w,Fo-w,+X

              8진수 모드 숫자 사용도 허용됩니다:

                  --chmod=D2775,F664

              여러 --chmod 옵션을 지정하는 것도 합법적입니다. 각 추가 옵션은 만들 변경 목록에 단순히 추가됩니다.

              결과 권한 값이 전송 중인 파일에 어떻게 적용될 수 있는지에 대한 내용은 --perms 및 --executability 옵션을 참조하십시오.

       --owner, -o
              이 옵션은 rsync가 대상 파일의 소유자를 소스 파일과 동일하게 설정하도록 하지만, 수신 rsync가 슈퍼유저로 실행되는 경우에만 그렇습니다 (--super 및 --fake-super 옵션도 참조).
              이 옵션이 없으면 새 파일 및/또는 전송된 파일의 소유자는 수신 측의 호출 사용자로 설정됩니다.

              소유권 보존은 기본적으로 일치하는 이름을 연결하지만, 일부 상황에서는 ID 번호를 사용하는 것으로 대체될 수 있습니다 (--numeric-ids 옵션에서 자세한 내용을 참조하십시오).

       --group, -g
              이 옵션은 rsync가 대상 파일의 그룹을 소스 파일과 동일하게 설정하도록 합니다.
              수신 프로그램이 슈퍼유저로 실행되지 않거나 (--no-super가 지정된 경우) 수신 측의 호출 사용자가 구성원인 그룹만 보존됩니다.
              이 옵션이 없으면 그룹은 수신 측의 호출 사용자의 기본 그룹으로 설정됩니다.

              그룹 정보 보존은 기본적으로 일치하는 이름을 연결하지만, 일부 상황에서는 ID 번호를 사용하는 것으로 대체될 수 있습니다 (--numeric-ids 옵션에서 자세한 내용을 참조하십시오).

       --devices
              이 옵션은 rsync가 문자 및 블록 장치 파일을 원격 시스템으로 전송하여 이러한 장치를 다시 생성하도록 합니다.
              수신 rsync가 슈퍼유저로 실행되지 않는 경우, rsync는 장치 파일 생성을 조용히 건너뜁니다 (--super 및 --fake-super 옵션도 참조).

              기본적으로 rsync는 이 옵션이 설정되지 않았을 때 발견되는 각 장치 파일에 대해 "비정규 파일 건너뛰기" 경고를 생성합니다.
              --info=nonreg0을 지정하여 경고를 억제할 수 있습니다.

       --specials
              이 옵션은 rsync가 명명된 소켓 및 FIFO와 같은 특수 파일을 전송하도록 합니다.
              수신 rsync가 슈퍼유저로 실행되지 않는 경우, rsync는 특수 파일 생성을 조용히 건너뜁니다 (--super 및 --fake-super 옵션도 참조).

              기본적으로 rsync는 이 옵션이 설정되지 않았을 때 발견되는 각 특수 파일에 대해 "비정규 파일 건너뛰기" 경고를 생성합니다.
              --info=nonreg0을 지정하여 경고를 억제할 수 있습니다.

       -D     -D 옵션은 "--devices --specials"와 동일합니다.

       --copy-devices
              이것은 rsync에게 보내는 측의 장치를 일반 파일처럼 처리하도록 지시하여, 일반 대상 파일로 (또는 --write-devices도 지정된 경우 다른 장치로) 복사할 수 있도록 합니다.

              이 옵션은 rsync 데몬에 의해 기본적으로 거부됩니다.

       --write-devices
              이것은 rsync에게 받는 측의 장치를 일반 파일처럼 처리하도록 지시하여, 파일 데이터를 장치에 쓸 수 있도록 합니다.

              이 옵션은 --inplace 옵션을 암시합니다.

              특히 rsync를 root로 실행할 때 전송의 받는 측에 어떤 장치가 있는지 알아야 하므로 이 옵션을 사용할 때 주의해야 합니다.

              이 옵션은 rsync 데몬에 의해 기본적으로 거부됩니다.

       --times, -t
              이것은 rsync에게 파일과 함께 수정 시간을 전송하고 원격 시스템에서 업데이트하도록 지시합니다.
              이 옵션을 사용하지 않으면 수정되지 않은 파일을 제외하는 최적화가 효과적일 수 없습니다.
              다시 말해, -t (또는 -a)가 없으면 다음 전송은 --ignore-times (-I)를 사용한 것처럼 동작하여 모든 파일이 업데이트됩니다 (비록 rsync의 델타-전송 알고리즘은 파일이 실제로 변경되지 않았다면 업데이트를 상당히 효율적으로 만들겠지만, -t를 사용하는 것이 훨씬 좋습니다).

              전송 프로토콜 30 또는 31을 사용하는 최신 rsync는 최대 8바이트를 사용하여 수정 시간을 전달합니다.
              rsync가 이전 프로토콜을 사용하도록 강제되면 (아마도 원격 rsync가 3.0.0보다 오래되었기 때문에) 4바이트를 사용하여 수정 시간을 전달합니다.
              3.2.7 이전에는 이러한 짧은 값들이 1901년 12월 13일부터 2038년 1월 19일까지의 날짜 범위를 전달할 수 있었습니다.
              3.2.7부터 이러한 4바이트 값은 이제 1970년 1월 1일부터 2106년 2월 7일까지의 날짜 범위를 전달합니다.
              1970년 이전 날짜의 파일이 있다면, 날짜의 전체 범위를 전달할 수 있도록 rsync 실행 파일을 업그레이드했는지 확인하십시오.

       --atimes, -U
              이것은 rsync에게 대상 파일의 접근(사용) 시간을 소스 파일과 동일하게 설정하도록 지시합니다.

              반복해서 사용하면 --open-noatime 옵션도 설정됩니다.
              이는 파일을 전송한 후 rsync를 한 번 더 실행할 필요 없이 보내는 시스템과 받는 시스템이 전송된 파일에 대해 동일한 접근 시간을 가지도록 돕습니다.

              일부 오래된 rsync 버전(3.2.0 이전)은 이 옵션을 반복할 때 --open-noatime을 암시하지 않는 사전 릴리스 --atimes 패치로 빌드되었을 수 있다는 점에 유의하십시오.

       --open-noatime
              이것은 rsync에게 O_NOATIME 플래그(이를 지원하는 시스템에서)로 파일을 열어 전송 중인 파일의 접근 시간을 변경하지 않도록 지시합니다.
              운영 체제가 O_NOATIME 플래그를 지원하지 않으면 rsync는 이 옵션을 조용히 무시합니다.
              또한 일부 파일 시스템은 O_NOATIME 플래그가 설정되지 않아도 읽기 접근 시 atime 업데이트를 피하도록 마운트된다는 점에 유의하십시오.

       --crtimes, -N
              이것은 rsync에게 대상 파일의 생성 시간(새로움)을 소스 파일과 동일하게 설정하도록 지시합니다.

       --omit-dir-times, -O
              이것은 rsync에게 수정, 접근 및 생성 시간을 보존할 때 디렉토리를 생략하도록 지시합니다.
              NFS가 수신 측에서 디렉토리를 공유하는 경우 -O를 사용하는 것이 좋습니다.
              이 옵션은 --backup을 --backup-dir 없이 사용하면 추론됩니다.

              이 옵션은 또한 --inc-recursive 섹션에서 논의된 바와 같이 증분 재귀가 활성화되었을 때 누락된 하위 디렉토리의 조기 생성을 피하는 부작용이 있습니다.

       --omit-link-times, -J
              이것은 rsync에게 수정, 접근 및 생성 시간을 보존할 때 심볼릭 링크를 생략하도록 지시합니다.

       --super
              이것은 수신 rsync가 슈퍼유저가 실행한 것이 아니더라도 슈퍼유저 활동을 시도하도록 지시합니다.
              이러한 활동에는 다음이 포함됩니다: --owner 옵션을 통한 사용자 보존, --group 옵션을 통한 모든 그룹 보존(현재 사용자의 그룹뿐만 아니라), --devices 옵션을 통한 장치 복사.
              이것은 슈퍼유저가 아니어도 그러한 활동을 허용하는 시스템에 유용하며, 수신 측이 슈퍼유저로 실행되지 않는 경우 오류를 얻는 데도 유용합니다.
              슈퍼유저 활동을 끄려면 슈퍼유저는 --no-super를 사용할 수 있습니다.

       --fake-super
              이 옵션이 활성화되면 rsync는 특수 확장 속성(필요에 따라 각 파일에 첨부됨)을 통해 특권 속성을 저장/복원하여 슈퍼유저 활동을 시뮬레이션합니다.
              여기에는 파일의 소유자 및 그룹(기본값이 아닌 경우), 파일의 장치 정보(장치 및 특수 파일은 빈 텍스트 파일로 생성됨), 실제 파일에 설정되지 않을 권한 비트(예: 실제 파일은 안전을 위해 u-s,g-s,o-t를 가짐) 또는 소유자의 접근을 제한하는 권한 비트(실제 슈퍼유저는 항상 파일에 접근/변경할 수 있으므로, 우리가 생성하는 파일은 항상 생성 사용자가 접근/변경할 수 있음)가 포함됩니다.
              이 옵션은 ACL(--acls가 지정된 경우) 및 비-사용자 확장 속성(--xattrs가 지정된 경우)도 처리합니다.

              이것은 슈퍼유저를 사용하지 않고 데이터를 백업하고, 호환되지 않는 시스템의 ACL을 저장하는 좋은 방법입니다.

              --fake-super 옵션은 옵션이 사용된 측에만 영향을 미칩니다. 원격-셸 연결의 원격 측에 영향을 미치려면 --remote-option (-M) 옵션을 사용하십시오:

                  rsync -av -M--fake-super /src/ host:/dest/

              로컬 복사의 경우, 이 옵션은 소스 및 대상 모두에 영향을 미칩니다.
              로컬 복사에서 이 옵션을 대상 파일에만 활성화하려면 -M--fake-super를 지정하십시오.
              로컬 복사에서 이 옵션을 소스 파일에만 활성화하려면 --fake-super를 -M--super와 결합하십시오.

              이 옵션은 --super 및 --no-super 모두에 의해 재정의됩니다.

              데몬의 rsyncd.conf 파일에 있는 fake super 설정도 참조하십시오.

       --sparse, -S
              스파스 파일을 효율적으로 처리하여 대상에서 공간을 덜 차지하도록 합니다.
              --inplace와 결합하면 일부 커널 버전 및/또는 파일 시스템 유형 조합에서는 생성된 파일이 스파스 블록으로 끝나지 않을 수 있습니다.
              --whole-file이 적용되는 경우(예: 로컬 복사의 경우) rsync가 업데이트된 버전을 쓰기 전에 파일을 잘라내므로 항상 작동합니다.

              rsync 3.1.3 이전 버전은 --sparse와 --inplace의 조합을 거부한다는 점에 유의하십시오.

       --preallocate
              이것은 수신자에게 데이터를 파일에 쓰기 전에 각 대상 파일을 최종 크기로 할당하도록 지시합니다.
              Rsync는 Linux의 fallocate(2) 시스템 호출 또는 Cygwin의 posix_fallocate(3)가 제공하는 실제 파일 시스템 수준의 사전 할당 지원만 사용하며, 각 블록에 널 바이트를 쓰는 느린 glibc 구현은 사용하지 않습니다.

              이 옵션이 없으면 큰 파일은 파일 시스템에서 완전히 연속적이지 않을 수 있지만, 이 옵션을 사용하면 rsync가 더 느리게 복사될 수 있습니다.
              대상이 익스텐트(extent)를 지원하는 파일 시스템(예: ext4, xfs, NTFS 등)이 아니면 이 옵션은 전혀 긍정적인 효과를 내지 못할 수 있습니다.

              --sparse와 결합하면, 할당된 데이터에 구멍을 생성하는 커널 버전 및 파일 시스템 유형이 지원하는 경우에만 파일에 스파스 블록(할당된 널 바이트 시퀀스 대신)이 생성됩니다.

       --dry-run, -n
              이것은 rsync가 변경 사항을 만들지 않는 시범 실행을 수행하도록 합니다 (실제 실행과 대부분 동일한 출력을 생성합니다).
              가장 일반적으로 --verbose (-v) 및/또는 --itemize-changes (-i) 옵션과 함께 사용하여 rsync 명령이 실제로 실행되기 전에 무엇을 할지 확인하는 데 사용됩니다.

              --itemize-changes의 출력은 드라이 런과 후속 실제 실행에서 정확히 동일해야 합니다 (의도적인 속임수 및 시스템 호출 실패 제외).
              만약 동일하지 않다면 버그입니다. 다른 출력은 대부분 변경되지 않아야 하지만, 일부 영역에서 다를 수 있습니다.
              특히, 드라이 런은 파일 전송을 위한 실제 데이터를 보내지 않으므로, --progress는 효과가 없고, "전송된 바이트", "수신된 바이트", "리터럴 데이터", "일치하는 데이터" 통계가 너무 작으며, "속도 향상" 값은 파일 전송이 필요 없는 실행과 동일합니다.

       --whole-file, -W
              이 옵션은 rsync의 델타-전송 알고리즘을 비활성화하여, 전송되는 모든 파일이 통째로 보내지도록 합니다.
              소스와 대상 머신 간의 대역폭이 디스크 대역폭보다 높은 경우 (특히 "디스크"가 실제로 네트워크 파일 시스템인 경우) 이 옵션을 사용하면 전송이 더 빨라질 수 있습니다.
              이는 소스와 대상이 모두 로컬 경로로 지정될 때의 기본값이지만, 일괄 쓰기(batch-writing) 옵션이 적용되지 않는 경우에만 해당합니다.

       --no-whole-file, --no-W
              로컬 전송에 대해 기본적으로 전체 파일 업데이트가 활성화된 경우 이를 비활성화합니다.
              이는 일반적으로 rsync 속도를 늦추지만, 대상 파일에 대한 쓰기를 최소화하려는 경우(--inplace와 결합 시) 또는 체크섬 기반 업데이트 알고리즘을 테스트하는 데 유용할 수 있습니다.

              --whole-file 옵션도 참조하십시오.

       --checksum-choice=STR, --cc=STR
              이 옵션은 체크섬 알고리즘을 재정의합니다.
              하나의 알고리즘 이름이 지정되면, 전송 체크섬과 ( --checksum이 지정되었다고 가정하면) 전송 전 체크섬 모두에 사용됩니다.
              두 개의 쉼표로 구분된 이름이 제공되면, 첫 번째 이름은 전송 체크섬에 영향을 미치고, 두 번째 이름은 전송 전 체크섬(-c)에 영향을 미칩니다.

              사용할 수 있는 체크섬 옵션은 다음과 같습니다:

              o      auto (기본 자동 선택)

              o      xxh128

              o      xxh3

              o      xxh64 (일명 xxhash)

              o      md5

              o      md4

              o      sha1

              o      none

              rsync --version을 실행하여 자신의 버전에 컴파일된 기본 체크섬 목록을 확인하십시오 (위 목록과 다를 수 있습니다).

              첫 번째 (또는 유일한) 이름에 "none"이 지정되면, --whole-file 옵션이 강제 적용되고 전송된 데이터에 대한 체크섬 검증이 수행되지 않습니다.
              두 번째 (또는 유일한) 이름에 "none"이 지정되면, --checksum 옵션을 사용할 수 없습니다.

              "auto" 옵션은 기본값이며, rsync는 클라이언트와 서버 간의 협상에 따라 알고리즘을 선택합니다:

              전송의 양쪽이 최소 3.2.0 버전인 경우, rsync는 클라이언트의 선택 목록에 있는 첫 번째 알고리즘 중에서 서버의 선택 목록에도 있는 것을 선택합니다.
              공통 체크섬 선택이 발견되지 않으면 rsync는 오류로 종료됩니다.
              원격 rsync가 너무 오래되어 체크섬 협상을 지원하지 않으면, 프로토콜 버전에 따라 값이 선택됩니다 (프로토콜 기간에 따라 MD5와 다양한 MD4 버전 중 하나를 선택합니다).

              기본 순서는 환경 변수 RSYNC_CHECKSUM_LIST를 허용되는 체크섬 이름의 공백으로 구분된 목록으로 설정하여 사용자 정의할 수 있습니다.
              문자열에 "&" 문자가 포함된 경우 "클라이언트 문자열 & 서버 문자열"로 분리되고, 그렇지 않으면 동일한 문자열이 둘 다에 적용됩니다.
              문자열(또는 문자열 부분)에 공백이 아닌 문자가 없으면 기본 체크섬 목록이 사용됩니다.
              유효하지 않은 이름만 있는 목록은 협상 실패로 이어집니다.

              --checksum-choice 옵션을 사용하면 이 환경 목록이 재정의됩니다.

       --one-file-system, -x
              이것은 rsync에게 재귀할 때 파일 시스템 경계를 넘지 않도록 지시합니다.
              이는 사용자가 여러 파일 시스템에서 복사할 항목을 지정하는 능력을 제한하지 않고, 사용자가 지정한 각 디렉토리 계층 구조 내에서 rsync의 재귀만 제한하며, 삭제 시 수신 측에서도 유사한 재귀를 제한합니다.
              또한 rsync는 동일한 장치에 대한 "바인드" 마운트를 동일한 파일 시스템에 있는 것으로 처리한다는 점을 명심하십시오.

              이 옵션을 반복하면 rsync는 모든 마운트 지점 디렉토리를 복사에서 제외합니다.
              그렇지 않으면, 발견되는 각 마운트 지점에 빈 디렉토리를 포함합니다 (마운트된 디렉토리의 속성을 사용하며, 기본 마운트 지점 디렉토리의 속성은 접근할 수 없습니다).

              rsync가 심볼릭 링크를 축소하도록 지시받은 경우 (--copy-links 또는 --copy-unsafe-links를 통해), 다른 장치에 대한 디렉토리 심볼릭 링크는 마운트 지점처럼 처리됩니다.
              비디렉토리 심볼릭 링크는 이 옵션의 영향을 받지 않습니다.

       --ignore-non-existing, --existing
              이것은 rsync에게 대상에 아직 존재하지 않는 파일(디렉토리 포함) 생성을 건너뛰도록 지시합니다.
              이 옵션을 --ignore-existing 옵션과 결합하면 어떤 파일도 업데이트되지 않습니다 (이는 불필요한 파일만 삭제하려는 경우 유용할 수 있습니다).

              이 옵션은 TRANSFER RULE이므로, 어떤 제외 부작용도 기대하지 마십시오.

       --ignore-existing
              이것은 rsync에게 대상에 이미 존재하는 파일 업데이트를 건너뛰도록 지시합니다 (기존 디렉토리는 무시하지 않으므로, 아무것도 수행되지 않을 것입니다).
              --ignore-non-existing도 참조하십시오.

              이 옵션은 TRANSFER RULE이므로, 어떤 제외 부작용도 기대하지 마십시오.

              이 옵션은 중단된 백업 실행을 계속해야 할 때 --link-dest 옵션을 사용하여 백업을 수행하는 사람들에게 유용할 수 있습니다.
              --link-dest 실행이 새 디렉토리 계층으로 복사되므로 (제대로 사용될 때), --ignore-existing을 사용하면 이미 처리된 파일이 수정되지 않도록 보장합니다 (하드 링크된 파일의 권한 변경을 방지합니다).
              이는 이 옵션이 대상 계층 자체의 기존 파일만 본다는 것을 의미합니다.

              --info=skip2가 사용될 때 rsync는 "FILENAME exists (INFO)" 메시지를 출력하며, 여기서 INFO는 "type change", "sum change" (-c 필요), "file change" (빠른 검사 기반), "attr change", 또는 "uptodate" 중 하나를 나타냅니다.
              --info=skip1 (2개의 -v 옵션으로도 암시됨)을 사용하면 INFO 접미사 없이 exists 메시지를 출력합니다.

       --remove-source-files
              이것은 rsync에게 전송의 일부이며 수신 측에서 성공적으로 복제된 파일 (비디렉토리 의미)을 보내는 측에서 제거하도록 지시합니다.

              이 옵션은 정지(quiescent)된 소스 파일에만 사용해야 합니다.
              특정 디렉토리에 나타나는 파일을 다른 호스트로 이동하는 데 이 옵션을 사용하는 경우, 완성된 파일이 소스 디렉토리에 직접 쓰이는 것이 아니라 소스 디렉토리로 이름이 변경되도록 하십시오.
              이렇게 하면 rsync가 아직 완전히 쓰여지지 않은 파일을 전송할 가능성을 막을 수 있습니다.
              파일을 먼저 다른 디렉토리에 쓸 수 없다면, rsync가 아직 완성되지 않은 파일을 전송하는 것을 피할 수 있는 명명 관용구(예: 파일이 쓰여질 때 "foo.new"로 이름 지정, 완료되면 "foo"로 이름 변경, 그리고 rsync 전송에 --exclude='*.new' 옵션 사용)를 사용해야 합니다.

              3.1.0부터 rsync는 파일의 크기 또는 수정 시간이 변경되지 않은 경우 보내는 측에서의 제거를 건너뛰고 (오류를 출력합니다).

              3.2.6부터 로컬 rsync 복사는 사용자가 실수로 소스 및 대상 디렉토리를 동일한 경로로 지정한 경우와 같이, 수신자가 방금 확인한 파일을 보내는 측이 제거하지 않도록 합니다.

       --delete
              이것은 rsync에게 수신 측에서 불필요한 파일(보내는 측에 없는 파일)을 삭제하도록 지시하지만, 동기화되는 디렉토리에 대해서만 그렇습니다.
              와일드카드를 사용하여 디렉토리의 내용(예: "dir/*")을 지정하지 않고 rsync에게 전체 디렉토리(예: "dir" 또는 "dir/")를 보내도록 요청해야 합니다.
              와일드카드는 셸에 의해 확장되고 rsync는 개별 파일을 전송하도록 요청받기 때문입니다.
              전송에서 제외된 파일도 --delete-excluded 옵션을 사용하거나 규칙을 보내는 측에서만 일치하도록 표시하지 않으면 삭제에서 제외됩니다 (FILTER RULES 섹션의 포함/제외 수정자 참조).

              rsync 2.6.7 이전에는 이 옵션이 --recursive가 활성화되지 않으면 효과가 없었습니다.
              2.6.7부터는 --dirs (-d)가 활성화될 때도 삭제가 발생하지만, 내용이 복사되는 디렉토리에 대해서만 그렇습니다.

              이 옵션은 잘못 사용하면 위험할 수 있습니다!
              --dry-run (-n) 옵션을 사용하여 어떤 파일이 삭제될 것인지 먼저 확인하는 것이 매우 좋습니다.

              보내는 측에서 I/O 오류가 감지되면 대상의 파일 삭제가 자동으로 비활성화됩니다.
              이는 보내는 측의 일시적인 파일 시스템 오류(예: NFS 오류)가 대상의 대량 파일 삭제를 유발하는 것을 방지하기 위함입니다.
              --ignore-errors 옵션으로 이를 재정의할 수 있습니다.

              --delete 옵션은 --delete-WHEN 옵션 중 하나와 충돌 없이 결합될 수 있으며, --delete-excluded와도 결합될 수 있습니다.
              그러나 --delete-WHEN 옵션 중 어느 것도 지정되지 않은 경우, rsync 3.0.0 이상과 통신할 때는 --delete-during 알고리즘을, 오래된 rsync와 통신할 때는 --delete-before 알고리즘을 선택합니다.
              --delete-delay 및 --delete-after도 참조하십시오.

       --delete-before
              전송 시작 전에 수신 측에서 파일 삭제를 수행하도록 요청합니다. 파일 삭제에 대한 자세한 내용은 --delete (암시됨)를 참조하십시오.

              전송 전에 삭제하는 것은 파일 시스템 공간이 부족하여 불필요한 파일을 제거하는 것이 전송을 가능하게 하는 데 도움이 될 때 유용합니다.
              그러나 전송 시작 전에 지연이 발생하며, 이 지연으로 인해 전송이 타임아웃될 수 있습니다 (--timeout이 지정된 경우).
              또한 rsync가 전송의 모든 파일을 한 번에 메모리로 스캔해야 하는 오래된 비증분 재귀 알고리즘을 사용하도록 강제합니다 (--recursive 참조).

       --delete-during, --del
              전송 중에 수신 측에서 파일 삭제를 점진적으로 수행하도록 요청합니다.
              디렉토리별 삭제 스캔은 각 디렉토리가 업데이트를 위해 검사되기 직전에 수행되므로, 더 효율적인 --delete-before처럼 작동하며, 디렉토리별 필터 파일이 업데이트되기 전에 삭제를 수행합니다.
              이 옵션은 rsync 버전 2.6.4에 처음 추가되었습니다. 파일 삭제에 대한 자세한 내용은 --delete (암시됨)를 참조하십시오.

       --delete-delay
              수신 측에서 파일 삭제가 전송 중에 계산된 후 (--delete-during처럼) 전송 완료 후에 제거되도록 요청합니다.
              이는 --delay-updates 및/또는 --fuzzy와 결합할 때 유용하며, --delete-after를 사용하는 것보다 효율적입니다 (그러나 --delete-after는 모든 업데이트가 완료된 후 별도의 패스에서 삭제를 계산하므로 다르게 작동할 수 있습니다).
              제거된 파일 수가 내부 버퍼를 초과하면 수신 측에 이름을 저장할 임시 파일이 생성됩니다 (열려 있는 동안 제거되므로 전송 중에는 보이지 않습니다).
              임시 파일 생성이 실패하면 rsync는 --delete-after를 사용하는 것으로 대체하려고 시도합니다 (그러나 --recursive가 증분 스캔을 수행하는 경우에는 불가능합니다).
              파일 삭제에 대한 자세한 내용은 --delete (암시됨)를 참조하십시오.

       --delete-after
              전송이 완료된 후에 수신 측에서 파일 삭제를 수행하도록 요청합니다.
              이는 전송의 일부로 새로운 디렉토리별 병합 파일을 보내고 해당 제외가 현재 전송의 삭제 단계에 영향을 미치도록 하려는 경우에 유용합니다.
              또한 rsync가 전송의 모든 파일을 한 번에 메모리로 스캔해야 하는 오래된 비증분 재귀 알고리즘을 사용하도록 강제합니다 (--recursive 참조).
              파일 삭제에 대한 자세한 내용은 --delete (암시됨)를 참조하십시오.

              전송이 끝날 때 삭제가 발생하기를 원하는 사람들에게 더 빠른 선택일 수 있는 --delete-delay 옵션도 참조하십시오.

       --delete-excluded
              이 옵션은 불확정적인 제외/포함 규칙을 수신자의 삭제에 영향을 미치지 않는 서버 측 규칙으로 전환합니다.

              기본적으로 제외 또는 포함은 서버 측 효과(서버의 파일 목록을 생성할 때 파일을 "숨기거나" "표시함")와 수신자 측 효과(삭제가 발생할 때 파일을 "보호하거나" "위험에 노출시킴")를 모두 가집니다.
              어떤 측에서 실행될지 지정하는 수정자가 없는 모든 규칙은 대신 서버 측 규칙으로만 처리되어 규칙의 "보호" 효과를 피합니다.

              이 옵션이 지정되더라도 규칙에 전송자와 수신자 수정자 문자(예: -f'-sr foo')가 모두 주어지면 규칙은 여전히 양쪽에 적용될 수 있습니다.
              수신자 측 보호/위험 규칙은 삭제를 제한하기 위해 명시적으로 지정될 수도 있습니다.
              이것은 많은 -f'- foo' 규칙을 -f'-s foo' (일명 -f'H foo') 규칙으로 편집하는 수고를 덜어줍니다 (해당 포함 규칙은 말할 것도 없습니다).

              자세한 내용은 FILTER RULES 섹션을 참조하십시오. 삭제에 대한 자세한 내용은 --delete (암시됨)를 참조하십시오.

       --ignore-missing-args
              rsync가 명시적으로 요청된 소스 파일(예: 명령줄 인자 또는 --files-from 항목)을 처음 처리할 때, 파일을 찾을 수 없으면 일반적으로 오류가 발생합니다.
              이 옵션은 해당 오류를 억제하고 파일을 전송하려고 시도하지 않습니다.
              이는 파일이 처음에 존재한다고 발견되었지만 나중에 더 이상 존재하지 않는 경우의 후속 파일 사라짐 오류에는 영향을 미치지 않습니다.

       --delete-missing-args
              이 옵션은 (암시된) --ignore-missing-args 옵션의 동작을 한 단계 더 나아갑니다: 각 누락된 인자는 수신 측의 해당 대상 파일에 대한 삭제 요청이 됩니다 (존재하는 경우).
              대상 파일이 비어 있지 않은 디렉토리인 경우, --force 또는 --delete가 적용되어야만 성공적으로 삭제됩니다.
              그 외에는 이 옵션은 다른 유형의 삭제 처리와는 무관합니다.

              누락된 소스 파일은 --list-only 출력에서 "*missing" 항목으로 표시되는 특수 파일-목록 항목으로 표현됩니다.

       --ignore-errors
              I/O 오류가 있을 때도 파일을 삭제하도록 --delete에게 지시합니다.

       --force
              이 옵션은 rsync에게 비어 있지 않은 디렉토리를 비디렉토리로 교체할 때 삭제하도록 지시합니다.
              이는 삭제가 활성화되어 있지 않을 때만 관련됩니다 (--delete에서 자세한 내용을 참조하십시오).

              오래된 rsync 버전 참고: --force는 --delete-after를 사용할 때도 필요했으며, --recursive 옵션도 활성화되지 않으면 작동하지 않았습니다.

       --max-delete=NUM
              이것은 rsync에게 NUM개 이상의 파일이나 디렉토리를 삭제하지 않도록 지시합니다.
              이 제한을 초과하면 나머지 모든 삭제는 전송이 끝날 때까지 건너뛰어집니다.
              마지막에 rsync는 경고(건너뛴 삭제 수 포함)를 출력하고 오류 코드 25로 종료합니다 (더 중요한 다른 오류 조건이 발생하지 않은 경우).

              버전 3.0.0부터 --max-delete=0을 지정하여 대상에 있는 모든 불필요한 파일에 대한 경고를 받을 수 있지만 아무것도 제거하지는 않습니다.
              오래된 클라이언트는 이것을 "무제한"으로 해석했으므로, 클라이언트 버전을 모르는 경우, 어떤 삭제도 허용되지 않도록 지정하는 역방향 호환성 방법으로 덜 명확한 --max-delete=-1을 사용할 수 있습니다 (그러나 아주 오래된 버전은 제한을 초과했을 때 경고하지 않았습니다).

       --max-size=SIZE
              이것은 rsync에게 지정된 SIZE보다 큰 파일은 전송하지 않도록 지시합니다.
              숫자 값 뒤에 단위 문자열을 붙이거나, 접미사 없이 바이트를 지정할 수 있습니다.
              --max-size=1.5m와 같이 분수 값을 단위와 함께 자유롭게 사용하십시오.

              이 옵션은 TRANSFER RULE이므로, 어떤 제외 부작용도 기대하지 마십시오.

              단위 문자열의 첫 글자는 B (바이트), K (킬로), M (메가), G (기가), T (테라), P (페타)일 수 있습니다.
              문자열이 단일 문자이거나 "ib"가 추가된 경우 (예: "G" 또는 "GiB") 단위는 1024의 배수입니다.
              "B"로 끝나는 두 글자 접미사 (예: "kb")를 사용하면 1000의 배수 단위가 됩니다.
              문자열의 문자는 원하는 대로 대소문자를 혼합할 수 있습니다.

              마지막으로, 문자열이 "+1" 또는 "-1"로 끝나면 지정된 방향으로 1바이트만큼 오프셋됩니다.
              가능한 가장 큰 값은 일반적으로 8192P-1입니다.

              예: --max-size=1.5mb-1은 1499999 바이트이고, --max-size=2g+1은 2147483649 바이트입니다.

              rsync 3.1.0 이전 버전은 --max-size=0을 허용하지 않았다는 점에 유의하십시오.

       --min-size=SIZE
              이것은 rsync에게 지정된 SIZE보다 작은 파일은 전송하지 않도록 지시합니다.
              이는 작고 쓸모없는 파일을 전송하지 않는 데 도움이 될 수 있습니다.
              SIZE 및 기타 정보에 대한 설명은 --max-size 옵션을 참조하십시오.

              rsync 3.1.0 이전 버전은 --min-size=0을 허용하지 않았다는 점에 유의하십시오.

       --max-alloc=SIZE
              기본적으로 rsync는 개별 malloc/realloc을 약 1GB로 제한합니다.
              대부분의 사람들에게 이 제한은 잘 작동하며 프로토콜 오류로 인해 rsync가 엄청난 양의 메모리를 요청하는 것을 방지합니다.
              그러나 전송할 파일이 수백만 개, 서버 메모리가 매우 많고, 전송을 여러 부분으로 나누고 싶지 않다면, 할당당 제한을 더 크게 늘릴 수 있으며 rsync는 더 많은 메모리를 소비할 것입니다.

              이것은 할당된 총 메모리 크기에 대한 제한이 아니라는 점을 명심하십시오.
              각 개별 할당에 대한 건전성 검사 값입니다.

              SIZE를 지정하는 방법에 대한 설명은 --max-size 옵션을 참조하십시오. 접미사가 제공되지 않으면 기본값은 바이트입니다.

              3.2.3부터 0 값은 제한 없음(no limit)을 지정합니다.

              환경 변수 RSYNC_MAX_ALLOC을 이 옵션이 지원하는 SIZE 값과 동일하게 사용하여 기본값을 설정할 수 있습니다.
              원격 rsync가 --max-alloc 옵션을 이해하지 못하는 경우, --max-alloc=1g를 지정하여 환경 값을 재정의할 수 있습니다.
              이렇게 하면 rsync는 원격 측으로 옵션을 보내지 않습니다 ( "1G"가 기본값이기 때문입니다).

       --block-size=SIZE, -B
              이것은 rsync의 델타-전송 알고리즘에 사용되는 블록 크기를 고정된 값으로 강제합니다.
              일반적으로 업데이트되는 각 파일의 크기에 따라 선택됩니다.
              자세한 내용은 기술 보고서를 참조하십시오.

              3.2.3부터 SIZE는 --max-size 옵션에 자세히 설명된 접미사와 함께 지정될 수 있습니다.
              이전 버전은 바이트 수만 허용했습니다.

       --rsh=COMMAND, -e
              이 옵션을 사용하면 로컬 rsync 복사본과 원격 rsync 복사본 간의 통신에 사용할 대체 원격 셸 프로그램을 선택할 수 있습니다.
              일반적으로 rsync는 기본적으로 ssh를 사용하도록 구성되지만, 로컬 네트워크에서는 rsh를 사용하는 것을 선호할 수 있습니다.

              이 옵션이 [user@]host::module/path와 함께 사용되면, 원격 셸 COMMAND는 원격 호스트에서 rsync 데몬을 실행하는 데 사용되며, 모든 데이터는 실행 중인 원격 rsync 데몬에 대한 직접 소켓 연결을 통하는 대신 해당 원격 셸 연결을 통해 전송됩니다.
              위의 USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION 섹션을 참조하십시오.

              rsync 3.2.0부터, 데몬 연결이 원격-셸 연결을 통해 이루어질 때 RSYNC_PORT 환경 변수가 설정됩니다.
              기본 데몬 포트가 가정되면 0으로 설정되거나, --port 옵션 또는 rsync:// URL의 비어 있지 않은 포트 값을 통해 지정된 rsync 포트 값으로 설정됩니다.
              이를 통해 스크립트는 비기본 포트가 요청되는지 여부를 식별하여, SSL 또는 stunnel 도우미 스크립트가 기본 또는 대체 포트에 연결하는 것과 같은 작업을 수행할 수 있도록 합니다.

              COMMAND가 단일 인자로 rsync에 제시되는 한, COMMAND에서 명령줄 인자가 허용됩니다.
              명령과 인자를 서로 분리하려면 공백(탭 또는 다른 공백 문자 아님)을 사용해야 하며, 인자 내 공백을 보존하기 위해 단일 또는 이중 따옴표를 사용할 수 있습니다 (단, 역슬래시는 안 됨).
              단일 따옴표로 묶인 문자열 내에서 단일 따옴표를 두 번 사용하면 단일 따옴표가 됩니다. 이중 따옴표도 마찬가지입니다 (어떤 따옴표를 셸이 파싱하고 어떤 따옴표를 rsync가 파싱하는지 주의해야 합니다).
              몇 가지 예시:

                  -e 'ssh -p 2234'
                  -e 'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"'

              (ssh 사용자는 .ssh/config 파일에서 사이트별 연결 옵션을 사용자 정의할 수도 있습니다.)

              RSYNC_RSH 환경 변수를 사용하여 원격 셸 프로그램을 선택할 수도 있으며, 이 변수는 -e와 동일한 범위의 값을 허용합니다.

              이 옵션에 영향을 받는 --blocking-io 옵션도 참조하십시오.

       --rsync-path=PROGRAM
              원격 머신에서 rsync를 시작하기 위해 실행할 프로그램을 지정하는 데 사용합니다.
              rsync가 기본 원격 셸의 경로에 없는 경우(예: --rsync-path=/usr/local/bin/rsync) 종종 사용됩니다.
              PROGRAM은 셸의 도움을 받아 실행되므로, rsync가 통신에 사용하는 표준 입력 및 표준 출력을 손상시키지 않는 한 모든 프로그램, 스크립트 또는 명령 시퀀스가 될 수 있습니다.

              한 가지 까다로운 예는 --relative 옵션과 함께 사용하기 위해 원격 머신에서 다른 기본 디렉토리를 설정하는 것입니다.
              예를 들어:

                  rsync -avR --rsync-path="cd /a/b && rsync" host:c/d /e/

       --remote-option=OPTION, -M
              이 옵션은 전송의 한쪽에만 특정 효과를 제한하려는 고급 상황에 사용됩니다.
              예를 들어, --log-file=FILE 및 --fake-super를 원격 시스템에 전달하려면 다음과 같이 지정하십시오:

                  rsync -av -M --log-file=foo -M--fake-super src/ dest/

              옵션이 일반적으로 양쪽에 영향을 미치지만, 로컬 측에만 영향을 미치도록 하려면 원격 측에 해당 옵션의 부정을 보내십시오.
              예:

                  rsync -av -x -M--no-x src/ dest/

              이 옵션을 사용할 때는 주의하십시오. rsync가 소켓을 통해 다음에 어떤 데이터를 예상해야 하는지에 대해 다른 개념을 갖게 하는 옵션을 토글할 수 있으며, 이는 알 수 없는 방식으로 실패하게 만들 것입니다.

              전달하려는 원격 옵션마다 별도의 -M 옵션을 사용해야 합니다.
              오래된 rsync 버전에서는 remote-option 인자에 공백이 있으면 별도의 원격 인자로 분할될 수 있었지만, 최신 rsync에서는 --old-args를 사용해야 합니다.

              로컬 전송을 수행할 때 "로컬" 측은 전송자이고 "원격" 측은 수신자입니다.

              popt 옵션 파싱 라이브러리의 일부 버전에는 짧은 옵션 문자 옆에 등호가 있는 인자(--log-file=/tmp/foo와 같은)를 사용할 수 없게 하는 버그가 있다는 점에 유의하십시오.
              이 버그가 popt 버전에 영향을 미치는 경우, rsync에 포함된 popt 버전을 사용할 수 있습니다.

       --cvs-exclude, -C
              이것은 시스템 간에 전송하고 싶지 않은 광범위한 파일을 제외하는 데 유용한 약식입니다.
              CVS와 유사한 알고리즘을 사용하여 파일을 무시해야 하는지 여부를 결정합니다.

              제외 목록은 다음 항목을 제외하도록 초기화됩니다 (이 초기 항목은 소멸성으로 표시됩니다 -- FILTER RULES 섹션 참조):

                  RCS  SCCS  CVS  CVS.adm  RCSLOG cvslog.*  tags TAGS .make.state .nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej .del-* *.a *.olb *.o *.obj *.so *.exe *.Z *.elc
                  *.ln core .svn/ .git/ .hg/ .bzr/

              그런 다음, $HOME/.cvsignore에 나열된 파일이 목록에 추가되고, CVSIGNORE 환경 변수에 나열된 모든 파일이 추가됩니다 (모든 cvsignore 이름은 공백으로 구분됩니다).

              마지막으로, .cvsignore 파일과 동일한 디렉토리에 있고 그 안에 나열된 패턴 중 하나와 일치하는 모든 파일은 무시됩니다.
              rsync의 필터/제외 파일과 달리, 이러한 패턴은 공백으로 분할됩니다.
              자세한 내용은 cvs(1) 매뉴얼을 참조하십시오.

              -C를 자신만의 --filter 규칙과 결합하는 경우, 이러한 CVS 제외는 명령줄에서 -C가 어디에 배치되었는지와 관계없이 자신만의 규칙 끝에 추가된다는 점을 유의해야 합니다.
              이것은 명시적으로 지정한 규칙보다 우선순위가 낮다는 의미입니다.
              이러한 CVS 제외가 필터 규칙에 삽입되는 위치를 제어하려면, 명령줄 옵션으로 -C를 생략하고 --filter=:C 및 --filter=-C 조합을 사용해야 합니다 (명령줄에서 또는 다른 규칙과 함께 필터 파일에 ":C" 및 "-C" 규칙을 넣어서).
              첫 번째 옵션은 .cvsignore 파일에 대한 디렉토리별 스캔을 켭니다.
              두 번째 옵션은 위에 언급된 CVS 제외를 한 번 가져옵니다.

       --filter=RULE, -f
              이 옵션을 사용하면 전송할 파일 목록에서 특정 파일을 선택적으로 제외하는 규칙을 추가할 수 있습니다.
              이것은 재귀적 전송과 함께 사용할 때 가장 유용합니다.

              명령줄에서 원하는 만큼 많은 --filter 옵션을 사용하여 제외할 파일 목록을 만들 수 있습니다.
              필터에 공백이 포함되어 있으면 셸이 규칙을 rsync에 단일 인자로 전달하도록 반드시 인용(quote)하십시오.
              아래 텍스트에는 규칙과 그 인자를 구분하는 공백 대신 밑줄을 사용할 수 있다는 내용도 언급되어 있습니다.

              이 옵션에 대한 자세한 정보는 FILTER RULES 섹션을 참조하십시오.

       -F     -F 옵션은 명령에 두 가지 --filter 규칙을 추가하는 약식입니다. 처음 사용될 때는 다음 규칙의 약식입니다:

                  --filter='dir-merge /.rsync-filter'

              이것은 rsync에게 계층 구조에 흩어져 있는 디렉토리별 .rsync-filter 파일을 찾아 전송 중인 파일을 필터링하는 데 그 규칙을 사용하도록 지시합니다.
              -F를 반복하면 다음 규칙의 약식입니다:

                  --filter='exclude .rsync-filter'

              이것은 .rsync-filter 파일 자체를 전송에서 필터링합니다.

              이 옵션들이 어떻게 작동하는지에 대한 자세한 정보는 FILTER RULES 섹션을 참조하십시오.

       --exclude=PATTERN
              이 옵션은 --filter 옵션의 단순화된 형태로, 제외 규칙을 지정하며 일반 필터 규칙의 전체 규칙 파싱 구문을 허용하지 않습니다.
              이는 -f'- PATTERN'을 지정하는 것과 동일합니다.

              이 옵션에 대한 자세한 정보는 FILTER RULES 섹션을 참조하십시오.

       --exclude-from=FILE
              이 옵션은 --exclude 옵션과 관련이 있지만, 제외 패턴(줄당 하나)이 포함된 FILE을 지정합니다.
              파일의 빈 줄은 무시되며, ';' 또는 '#'으로 시작하는 전체 줄 주석도 무시됩니다 (이러한 문자를 포함하는 파일 이름 규칙은 영향을 받지 않습니다).

              줄이 "- " (대시, 공백) 또는 "+ " (플러스, 공백)으로 시작하면, 규칙 유형이 명시적으로 제외 또는 포함으로 지정된 것입니다.
              이러한 접두사가 없는 모든 규칙은 제외로 간주됩니다.

              줄이 단지 "!"로 구성되면, 추가 규칙을 추가하기 전에 현재 필터 규칙이 지워집니다.

              FILE이 '-'이면 목록은 표준 입력에서 읽힙니다.

       --include=PATTERN
              이 옵션은 --filter 옵션의 단순화된 형태로, 포함 규칙을 지정하며 일반 필터 규칙의 전체 규칙 파싱 구문을 허용하지 않습니다.
              이는 -f'+ PATTERN'을 지정하는 것과 동일합니다.

              이 옵션에 대한 자세한 정보는 FILTER RULES 섹션을 참조하십시오.

       --include-from=FILE
              이 옵션은 --include 옵션과 관련이 있지만, 포함 패턴(줄당 하나)이 포함된 FILE을 지정합니다.
              파일의 빈 줄은 무시되며, ';' 또는 '#'으로 시작하는 전체 줄 주석도 무시됩니다 (이러한 문자를 포함하는 파일 이름 규칙은 영향을 받지 않습니다).

              줄이 "- " (대시, 공백) 또는 "+ " (플러스, 공백)으로 시작하면, 규칙 유형이 명시적으로 제외 또는 포함으로 지정된 것입니다.
              이러한 접두사가 없는 모든 규칙은 포함으로 간주됩니다.

              줄이 단지 "!"로 구성되면, 추가 규칙을 추가하기 전에 현재 필터 규칙이 지워집니다.

              FILE이 '-'이면 목록은 표준 입력에서 읽힙니다.

       --files-from=FILE
              이 옵션을 사용하면 전송할 파일의 정확한 목록을 지정할 수 있습니다 (지정된 FILE 또는 표준 입력에서 '-'로 읽음).
              또한 rsync의 기본 동작을 조정하여 지정된 파일과 디렉토리만 더 쉽게 전송할 수 있도록 합니다:

              o      --relative (-R) 옵션이 암시됩니다. 이는 파일의 각 항목에 대해 지정된 경로 정보를 보존합니다 (--no-relative 또는 --no-R을 사용하여 끄고 싶다면).

              o      --dirs (-d) 옵션이 암시됩니다. 이는 목록에 지정된 디렉토리를 시끄럽게 건너뛰는 대신 대상에 생성합니다 (--no-dirs 또는 --no-d를 사용하여 끄고 싶다면).

              o      --archive (-a) 옵션의 동작은 --recursive (-r)를 암시하지 않으므로, 원한다면 명시적으로 지정하십시오.

              o      이러한 부작용은 rsync의 기본 상태를 변경하므로, 명령줄에서 --files-from 옵션의 위치는 다른 옵션이 파싱되는 방식에 영향을 미치지 않습니다 (예: -a는 --files-from 앞이나 뒤에서 동일하게 작동하며, --no-R 및 다른 모든 옵션도 마찬가지입니다).

              FILE에서 읽은 파일 이름은 모두 소스 디렉토리에 상대적입니다.
              선행 슬래시는 제거되며 ".." 참조는 소스 디렉토리보다 상위로 이동할 수 없습니다.
              예를 들어, 이 명령을 살펴보십시오:

                  rsync -a --files-from=/tmp/foo /usr remote:/backup

              만약 /tmp/foo에 "bin" (또는 "/bin")이라는 문자열이 포함되어 있다면, /usr/bin 디렉토리가 원격 호스트에 /backup/bin으로 생성됩니다.
              만약 "bin/" (후행 슬래시 주의)이 포함되어 있다면, 디렉토리의 즉각적인 내용도 전송됩니다 (파일에 명시적으로 언급할 필요 없이 -- 이것은 버전 2.6.4부터 시작되었습니다).
              두 경우 모두, -r 옵션이 활성화된 경우, 해당 디렉토리의 전체 계층 구조도 전송됩니다 ( -r은 --files-from과 함께 명시적으로 지정되어야 하며, -a에 의해 암시되지 않는다는 점을 명심하십시오.
              또한 (기본적으로 활성화된) -r 옵션의 효과는 파일에서 읽은 경로 정보만 복제하는 것이며, 소스-지정 경로(이 경우 /usr)의 복제를 강제하지는 않습니다).

              또한, --files-from 파일은 파일 앞에 "host:"를 지정하면 로컬 호스트 대신 원격 호스트에서 읽을 수 있습니다 (호스트는 전송의 한쪽 끝과 일치해야 합니다).
              간단히, ":" 접두사만 지정하여 "전송의 원격 끝을 사용하라"는 의미로 사용할 수 있습니다. 예를 들어:

                  rsync -a --files-from=:/path/file-list src:/ /tmp/copy

              이것은 원격 "src" 호스트에 있는 /path/file-list 파일에 지정된 모든 파일을 복사합니다.

              --iconv 및 --secluded-args 옵션이 지정되고 --files-from 파일 이름이 한 호스트에서 다른 호스트로 전송되는 경우, 파일 이름은 보내는 호스트의 문자셋에서 받는 호스트의 문자셋으로 번역됩니다.

              참고: --files-from 입력에서 파일 목록을 정렬하면 rsync의 효율성이 향상됩니다. 인접 항목 간에 공유되는 경로 요소를 다시 방문하는 것을 피할 수 있기 때문입니다.
              입력이 정렬되지 않으면 일부 경로 요소(암시된 디렉토리)가 여러 번 스캔될 수 있으며, rsync는 파일 목록 요소로 변환된 후 결국 중복을 제거합니다.

       --from0, -0
              이것은 rsync에게 파일에서 읽는 규칙/파일 이름이 NL, CR 또는 CR+LF가 아닌 널('\0') 문자로 끝난다고 알려줍니다.
              이는 --exclude-from, --include-from, --files-from 및 --filter 규칙에 지정된 모든 병합 파일에 영향을 미칩니다.
              --cvs-exclude에는 영향을 미치지 않습니다 ( .cvsignore 파일에서 읽은 모든 이름은 공백으로 분할되기 때문입니다).

       --old-args
              이 옵션은 rsync에게 원격 측의 인자 값이 의도치 않은 단어 분할이나 기타 오해로부터 보호하려는 시도를 중단하도록 지시합니다.
              또한 클라이언트가 빈 인자를 오류를 생성하는 대신 "."으로 처리하도록 허용합니다.

              최신 rsync의 기본값은 "셸-활성" 문자(공백 포함)가 원격 셸로 전송되는 인자에서 역슬래시로 이스케이프되는 것입니다.
              와일드카드 문자 *, ?, [, & ]는 파일 이름 인자에서는 이스케이프되지 않지만 (여러 파일 이름으로 확장될 수 있도록 허용), --usermap과 같은 옵션 인자에서는 보호됩니다.

              파일 이름에서 이전 스타일 인자 분할을 사용하려는 스크립트가 있다면 이 옵션을 한 번 지정하십시오.
              원격 셸에 역슬래시 이스케이프에 문제가 있다면 이 옵션을 두 번 지정하십시오.

              RSYNC_OLD_ARGS 환경 변수를 통해서도 이 설정을 제어할 수 있습니다.
              이 변수가 "1" 값이라면 rsync는 단일 옵션 설정으로 기본값이 지정됩니다.
              "2" (또는 그 이상) 값이라면 rsync는 반복 옵션 설정으로 기본값이 지정됩니다.
              "0"이라면 기본 이스케이프 동작을 얻게 됩니다.
              환경 변수는 항상 수동으로 지정된 긍정 또는 부정 옵션에 의해 재정의됩니다 (부정은 --no-old-args입니다).

              이 옵션은 원격 전송자가 요청하지 않은 추가 최상위 항목을 파일 목록에 포함하지 않도록 보장하는 3.2.5에 추가된 추가 안전 점검도 비활성화합니다.
              원격 셸이 인자를 해석할 때 어떤 이름을 예상해야 할지 확실히 알 수 없으므로 이 부작용은 필요합니다.

              이 옵션은 --secluded-args 옵션과 충돌합니다.

       --secluded-args, -s
              이 옵션은 모든 파일 이름과 대부분의 옵션을 프로토콜을 통해 원격 rsync로 보냅니다 (원격 셸 명령줄이 아님).
              이는 원격 셸이 이들을 수정하는 것을 방지합니다. 와일드카드는 셸 대신 rsync에 의해 원격 호스트에서 확장됩니다.

              이는 3.2.4에 추가된 인자의 기본 역슬래시 이스케이핑과 유사합니다 (--old-args 참조).
              즉, 공백 분할 및 원치 않는 특수 문자 부작용과 같은 것을 방지합니다.
              그러나 오래된 rsync 버전(3.0.0 이전)과 호환되지 않고, 안전을 위해 모든 옵션 값을 검사하려는 제한된 셸에 의해 거부될 수 있다는 단점이 있습니다.

              이 옵션은 인자의 문자셋이 원격 호스트에 맞게 변환되어야 하는 경우, 원격 셸이 기본 역슬래시 이스케이프 방식과 호환되지 않는 경우, 또는 대부분의 옵션과 인자가 원격 셸의 명령줄을 우회하도록 하려는 다른 이유가 있는 경우에 유용합니다.

              이 옵션을 --iconv와 결합하면 원격 측과 관련된 인자는 로컬 문자셋에서 원격 문자셋으로 번역됩니다.
              번역은 와일드카드가 확장되기 전에 발생합니다. --files-from 옵션도 참조하십시오.

              RSYNC_PROTECT_ARGS 환경 변수를 통해서도 이 설정을 제어할 수 있습니다.
              이 변수가 0이 아닌 값을 가지면 이 설정은 기본적으로 활성화되고, 그렇지 않으면 기본적으로 비활성화됩니다.
              어떤 상태든 이 옵션의 수동으로 지정된 긍정 또는 부정 버전으로 재정의됩니다 (--no-s 및 --no-secluded-args는 부정 버전입니다).
              이 환경 변수는 0이 아닌 RSYNC_OLD_ARGS 내보내기로도 재정의됩니다.

              이 옵션은 --old-args 옵션과 충돌합니다.

              이 옵션은 이전에 --protect-args (3.2.6 이전)라고 불렸으며, 그 이전 이름도 여전히 사용할 수 있습니다 (그러나 -s로 지정하는 것이 항상 가장 쉽고 호환성이 높습니다).

       --trust-sender
              이 옵션은 로컬 클라이언트가 원격 전송자가 생성한 파일 목록에 대해 수행하는 두 가지 추가 유효성 검사(--multi-host-security 섹션에 자세히 설명됨)를 비활성화합니다.
              이 옵션은 전송자가 파일 목록에 악의적인 것을 넣지 않을 것이라고 신뢰하는 경우에만 사용해야 합니다 (수정된 rsync, 수정된 셸 또는 유사한 조작을 통해 발생할 수 있습니다).

              일반적으로 rsync 클라이언트(버전 3.2.5 기준)는 원격 rsync에서 파일을 가져올 때 두 가지 추가 유효성 검사를 실행합니다:

              o      전송 상단에 추가 인자 항목이 추가되지 않았는지 확인합니다.

              o      파일 목록의 항목 중 제외되었어야 할 이름이 없는지 확인합니다 (필터 규칙이 지정된 경우).

              다양한 옵션은 유효성 검사와 충돌하는 경우 이러한 확인 중 하나 또는 둘 다를 비활성화할 수 있습니다. 예를 들어:

              o      디렉토리별 필터 파일을 사용하면 서버만 아는 필터 규칙을 읽으므로 필터 검사가 비활성화됩니다.

              o      --old-args 옵션을 사용하면 전송자가 요청된 인자를 조작할 수 있으므로 인자 검사가 비활성화됩니다.

              o      서버 측에서 files-from 목록을 읽으면 클라이언트가 인자 목록을 알 수 없으므로 인자 검사가 비활성화됩니다.

              o      --read-batch를 사용하면 배치 파일의 내용이 생성될 때 이미 확인되었으므로 두 검사 모두 비활성화됩니다.

              이  옵션은 추가 패턴 일치가 대규모 전송에서 속도를 늦출 때 성능이 낮은 클라이언트 서버에 도움이 될 수 있습니다.
              또한 신뢰할 수 있는 전송자로부터의 전송에 대한 검증 로직의 현재 알려지지 않은 버그를 해결하는 데 사용될 수도 있습니다.

              이 옵션을 사용할 때는 MULTI-HOST SECURITY 섹션에서 설명된 대로 전용 대상 디렉토리를 지정하는 것이 좋습니다.

       --copy-as=USER[:GROUP]
              이 옵션은 rsync에게 복사 작업에 USER와 (콜론 뒤에 지정된 경우) GROUP을 사용하도록 지시합니다.
              이는 rsync를 실행하는 사용자가 사용자 변경 권한을 가지고 있는 경우에만 작동합니다.
              그룹이 지정되지 않으면 사용자의 기본 그룹이 사용됩니다.

              이 옵션은 루트 권한으로 실행되는 rsync가 실시간 변경이 발생할 수 있는 디렉토리로/로부터 실행될 때 시스템 파일에 대한 루트 수준 읽기 또는 쓰기 작업이 불가능하도록 보장하여 위험을 줄이는 데 도움이 될 수 있습니다.
              대신 rsync 전체를 지정된 사용자로 실행할 수도 있지만, 때로는 루트 수준 호스트 액세스 자격 증명을 사용해야 할 때가 있으므로, 이 옵션을 사용하면 원격-셸 또는 데몬 연결이 설정된 후 rsync가 작업의 복사 부분에 대해 루트 권한을 포기할 수 있습니다.

              이 옵션은 전송이 로컬인 경우를 제외하고는 전송의 한쪽에만 영향을 미칩니다. 로컬인 경우에는 양쪽에 영향을 미칩니다.
              원격 측에 영향을 미치려면 -M--copy-as=joe와 같이 --remote-option을 사용하십시오.
              로컬 전송의 경우, lsh (또는 lsh.sh) 지원 파일은 "localhost:" 또는 "lh:" 호스트-지정을 설정할 필요 없이 원격 셸을 사용하지 않고도 지정할 수 있는 로컬-셸 도우미 스크립트를 제공합니다.
              이를 통해 호스트-지정을 사용하는 전송 측에 영향을 미치는 원격 옵션을 지정할 수 있습니다 (호스트 이름 "lh"를 사용하면 원격 디렉토리가 사용자의 홈 디렉토리로 재정의되는 것을 피할 수 있습니다).

              예를 들어, 다음 rsync는 로컬 파일을 사용자 "joe"로 씁니다:

                  sudo rsync -aiv --copy-as=joe host1:backups/joe/ /home/joe/

              이렇게 하면 모든 파일이 사용자 "joe"의 소유가 되고, 그룹은 해당 사용자가 사용할 수 있는 그룹으로 제한되며, joe 사용자가 경로를 시기적절하게 악용하여 joe 사용자가 변경 권한이 없는 파일을 변경하는 것이 불가능해집니다.

              다음 명령은 "joe" 사용자로 "dest/" 디렉토리로 로컬 복사를 수행합니다 (PATH에 support/lsh가 설치되어 있다고 가정):

                  sudo rsync -aive lsh -M--copy-as=joe src/ lh:dest/

       --temp-dir=DIR, -T
              이 옵션은 rsync에게 수신 측에서 전송된 파일의 임시 복사본을 만들 때 DIR을 스크래치 디렉토리로 사용하도록 지시합니다.
              기본 동작은 각 임시 파일을 해당 대상 파일과 동일한 디렉토리에 만드는 것입니다.
              rsync 3.1.1부터 지정된 DIR 내의 임시 파일 이름은 추가 점(.)으로 접두사가 붙지 않습니다 (하지만 여전히 임의의 접미사가 추가됩니다).

              이 옵션은 대부분 수신 디스크 파티션에 전송에서 가장 큰 파일의 복사본을 보관할 충분한 여유 공간이 없는 경우에 사용됩니다.
              이 경우 (즉, 스크래치 디렉토리가 다른 디스크 파티션에 있는 경우) rsync는 수신된 각 임시 파일의 이름을 해당 대상 파일 위에 덮어쓸 수 없으며, 대신 제자리로 복사해야 합니다.
              rsync는 파일을 대상 파일 위에 복사하여 이를 수행합니다.
              이는 이 복사 중에 대상 파일에 잘린 데이터가 포함됨을 의미합니다.
              이러한 방식으로 수행되지 않으면 (대상 파일이 먼저 제거되고, 데이터가 로컬로 대상 디렉토리의 임시 파일로 복사된 다음, 제자리로 이름이 변경되더라도) 이전 파일이 디스크 공간을 계속 차지할 수 있고 (누군가 파일을 열어둔 경우), 따라서 디스크에 새 버전을 동시에 저장할 충분한 공간이 없을 수 있습니다.

              디스크 공간 부족 이외의 이유로 이 옵션을 사용하는 경우, --delay-updates 옵션과 결합하는 것을 고려할 수 있습니다.
              이 옵션은 복사된 모든 파일이 대상 계층 구조의 하위 디렉토리에 배치되어 전송이 끝날 때까지 기다리도록 보장합니다.
              대상 파티션에 도착하는 모든 파일을 복제할 충분한 공간이 없는 경우, rsync에게 디스크 공간에 대해 지나치게 걱정하지 않아도 된다고 알리는 또 다른 방법은 상대 경로와 함께 --partial-dir 옵션을 사용하는 것입니다.
              이는 rsync에게 대상 계층의 하위 디렉토리에 단일 파일의 복사본을 저장해도 괜찮다고 알립니다.
              rsync는 partial-dir을 스테이징 영역으로 사용하여 복사된 파일을 가져온 다음, 거기서부터 제자리로 이름을 변경합니다.
              (절대 경로와 함께 --partial-dir을 지정하는 것은 이러한 부작용이 없습니다.)

       --fuzzy, -y
              이 옵션은 rsync에게 누락된 대상 파일에 대한 기준 파일을 찾도록 지시합니다.
              현재 알고리즘은 대상 파일과 동일한 디렉토리에서 동일한 크기와 수정 시간을 가진 파일 또는 유사한 이름의 파일을 찾습니다.
              찾으면 rsync는 퍼지 기준 파일을 사용하여 전송 속도를 높이려고 합니다.

              옵션을 반복하면 --compare-dest, --copy-dest 또는 --link-dest를 통해 지정된 일치하는 대체 대상 디렉토리에서도 퍼지 스캔이 수행됩니다.

              --delete 옵션을 사용하면 잠재적인 퍼지 일치 파일이 제거될 수 있으므로, 이를 방지해야 하는 경우 --delete-after를 사용하거나 일부 파일 이름 제외를 지정하십시오.

       --compare-dest=DIR
              이 옵션은 rsync에게 전송을 수행할 때 (파일이 대상 디렉토리에 없는 경우) 대상 머신의 DIR을 대상 파일을 비교할 추가 계층 구조로 사용하도록 지시합니다.
              DIR에서 보내는 측의 파일과 동일한 파일이 발견되면, 해당 파일은 대상 디렉토리로 전송되지 않습니다.
              이는 이전 백업에서 변경된 파일만으로 구성된 스파스 백업을 생성하는 데 유용합니다.
              이 옵션은 일반적으로 비어 있는 (또는 새로 생성된) 디렉토리로 복사할 때 사용됩니다.

              버전 2.6.4부터 여러 --compare-dest 디렉토리를 제공할 수 있으며, 이 경우 rsync는 정확한 일치를 찾기 위해 지정된 순서대로 목록을 검색합니다.
              속성만 다른 일치 항목이 발견되면 로컬 복사본이 생성되고 속성이 업데이트됩니다.
              일치 항목이 발견되지 않으면 전송 속도를 높이기 위해 DIR 중 하나에서 기준 파일이 선택됩니다.

              DIR이 상대 경로인 경우, 대상 디렉토리에 상대적입니다.
              --copy-dest 및 --link-dest도 참조하십시오.

              참고: 버전 3.1.0부터 rsync는 대상 계층 구조가 비어 있지 않은 경우, 비교-대상 계층 구조 중 하나에서 정확한 일치 항목이 발견되면 파일을 제거합니다 (최종 결과가 새 복사본과 더 가깝게 일치하도록 함).

       --copy-dest=DIR
              이 옵션은 --compare-dest처럼 작동하지만, rsync는 DIR에서 발견된 변경되지 않은 파일을 로컬 복사를 사용하여 대상 디렉토리로 복사합니다.
              이는 기존 파일을 손상시키지 않고 새로운 대상으로 전송을 수행한 다음, 모든 파일이 성공적으로 전송되면 즉시 전환(flash-cutover)을 수행하는 데 유용합니다.

              여러 --copy-dest 디렉토리를 제공할 수 있으며, rsync는 변경되지 않은 파일을 찾기 위해 지정된 순서대로 목록을 검색합니다.
              일치 항목이 발견되지 않으면 전송 속도를 높이기 위해 DIR 중 하나에서 기준 파일이 선택됩니다.

              DIR이 상대 경로인 경우, 대상 디렉토리에 상대적입니다.
              --compare-dest 및 --link-dest도 참조하십시오.

       --link-dest=DIR
              이 옵션은 --copy-dest처럼 작동하지만, 변경되지 않은 파일은 DIR에서 대상 디렉토리로 하드 링크됩니다.
              파일이 링크되려면 보존된 모든 속성(예: 권한, 경우에 따라 소유권)이 동일해야 합니다. 예:

                  rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/

              파일이 링크되지 않는다면 속성을 다시 확인하십시오.
              또한 rsync의 제어 밖에서 강제되는 속성이 없는지 확인하십시오. 예를 들어, root를 단일 사용자로 압축하는 마운트 옵션이나 일반적인 소유권으로 이동식 드라이브를 마운트하는 경우(OS X의 "이 볼륨의 소유권 무시" 옵션과 같은).

              버전 2.6.4부터 여러 --link-dest 디렉토리를 제공할 수 있으며, 이 경우 rsync는 정확한 일치를 찾기 위해 지정된 순서대로 목록을 검색합니다 (이러한 디렉토리는 20개로 제한됩니다).
              속성만 다른 일치 항목이 발견되면 로컬 복사본이 생성되고 속성이 업데이트됩니다.
              일치 항목이 발견되지 않으면 전송 속도를 높이기 위해 DIR 중 하나에서 기준 파일이 선택됩니다.

              이 옵션은 비어 있는 대상 계층 구조로 복사할 때 가장 잘 작동합니다.
              기존 파일의 속성이 수정될 수 있으며, 이는 하드 링크를 통해 대체 대상 파일에 영향을 미칠 수 있기 때문입니다.
              또한, 변경 사항을 항목화하는 것이 다소 복잡해질 수 있습니다.
              버전 3.1.0 이전에는 대상 파일이 이미 존재할 때 대체 디렉토리에서 정확한 일치 항목이 발견되지 않았습니다(대상으로 링크되지도 않았습니다).

              이 옵션을 --ignore-times와 결합하면 rsync는 어떤 파일도 링크하지 않습니다.
              파일을 전송하는 대신 동일한 파일을 함께 링크하는 것을 대체 수단으로만 사용하고, 파일 업데이트 후 추가 검사로는 사용하지 않기 때문입니다.

              DIR이 상대 경로인 경우, 대상 디렉토리에 상대적입니다.
              --compare-dest 및 --copy-dest도 참조하십시오.

              rsync 2.6.1 이전 버전에는 --owner (-o)가 지정되었을 때 (또는 암시되었을 때) 비-슈퍼유저에 대해 --link-dest가 제대로 작동하지 않을 수 있는 버그가 있었습니다.
              이 버그를 해결하려면 오래된 rsync로 보낼 때 -o 옵션을 피하거나 (--no-o를 사용하십시오).

       --compress, -z
              이 옵션을 사용하면 rsync는 파일 데이터를 대상 머신으로 보낼 때 압축하여 전송되는 데이터 양을 줄입니다.
              이는 느린 연결에서 유용합니다.

              Rsync는 여러 압축 방법을 지원하며, --compress-choice (--zc) 옵션을 사용하여 선택을 강제하지 않는 한 자동으로 하나를 선택합니다.

              rsync --version을 실행하여 자신의 버전에 컴파일된 기본 압축 목록을 확인하십시오.

              전송의 양쪽이 최소 3.2.0 버전인 경우, rsync는 클라이언트의 선택 목록에 있는 첫 번째 알고리즘 중에서 서버의 선택 목록에도 있는 것을 선택합니다.
              공통 압축 선택이 발견되지 않으면 rsync는 오류로 종료됩니다.
              원격 rsync가 너무 오래되어 체크섬 협상을 지원하지 않으면, 해당 목록은 "zlib"라고 가정됩니다.

              기본 순서는 환경 변수 RSYNC_COMPRESS_LIST를 허용되는 압축 이름의 공백으로 구분된 목록으로 설정하여 사용자 정의할 수 있습니다.
              문자열에 "&" 문자가 포함된 경우 "클라이언트 문자열 & 서버 문자열"로 분리되고, 그렇지 않으면 동일한 문자열이 둘 다에 적용됩니다.
              문자열(또는 문자열 부분)에 공백이 아닌 문자가 없으면 기본 압축 목록이 사용됩니다.
              알려지지 않은 압축 이름은 목록에서 제거되지만, 유효하지 않은 이름만 있는 목록은 협상 실패로 이어집니다.

              일부 오래된 rsync 버전은 -z 옵션을 거부하고 -zz 사용을 요구하도록 구성되었습니다.
              이는 압축 라이브러리가 기본 zlib 압축 방식과 호환되지 않았기 때문입니다.
              rsync 서버가 불평하며 -zz를 지정하도록 지시하지 않는 한, 이 이상한 점은 일반적으로 무시해도 됩니다.

       --compress-choice=STR, --zc=STR
              이 옵션은 --compress가 사용될 때 발생하는 압축 알고리즘의 자동 협상을 재정의하는 데 사용할 수 있습니다.
              "none"이 지정되지 않은 한 --compress를 암시하며, "none"이 지정되면 --no-compress를 암시합니다.

              사용할 수 있는 압축 옵션은 다음과 같습니다:

              o      zstd

              o      lz4

              o      zlibx

              o      zlib

              o      none

              rsync --version을 실행하여 자신의 버전에 컴파일된 기본 압축 목록을 확인하십시오 (위 목록과 다를 수 있습니다).

              --old-compress 또는 --new-compress라는 옵션에 대한 오류가 표시되는 경우, 이는 rsync가 --compress-choice=zlib 또는 --compress-choice=zlibx 옵션을 더 많은 rsync 버전이 이해하는 역방향 호환 방식으로 보내려고 시도하는 것입니다.
              이 오류는 서버의 오래된 rsync 버전이 압축 유형을 강제하는 것을 허용하지 않음을 나타냅니다.

              "zlibx" 압축 알고리즘은 압축 스트림에서 일치하는 데이터를 제외한 "zlib" 알고리즘입니다 (외부 zlib 구현과 더 호환되도록 시도하기 위함입니다).

       --compress-level=NUM, --zl=NUM
              기본값으로 두는 대신 사용할 압축 수준을 명시적으로 설정합니다 (--compress, -z 참조).
              선택된 수준이 적용 중인 압축 알고리즘에 대해 "압축 안 함" 수준이 아닌 한 --compress 옵션이 암시됩니다 (예: zlib 압축은 수준 0을 "해제"로 처리합니다).

              수준 값은 적용되는 체크섬에 따라 다릅니다.
              rsync는 기본적으로 체크섬 선택을 협상하므로 (원격 rsync가 충분히 최신인 경우), 이 옵션을 --compress-choice (--zc) 옵션과 결합하는 것이 좋습니다.
              (어떤 선택이 적용되는지 확실하지 않은 경우). 예를 들어:

                  rsync -aiv --zc=zstd --zl=22 host:src/ dest/

              zlib 및 zlibx 압축의 경우 유효한 값은 1에서 9까지이며 기본값은 6입니다.
              --zl=0을 지정하면 압축이 꺼지고, --zl=-1을 지정하면 기본 수준인 6이 선택됩니다.

              zstd 압축의 경우 유효한 값은 -131072에서 22까지이며 기본값은 3입니다. 0을 지정하면 기본값인 3이 선택됩니다.

              lz4 압축의 경우 수준이 없으므로 값은 항상 0입니다.

              너무 크거나 너무 작은 값을 지정하면 해당 숫자는 유효한 값으로 조용히 제한됩니다.
              이를 통해 --zl=999999999와 같이 지정하여 어떤 알고리즘이 선택되든 최대 압축 수준을 얻을 수 있습니다.

              적용 중인 압축 수준을 알고 싶다면 --debug=nstr을 지정하여 "negotiated string" 결과를 확인하십시오.
              이는 "Client compress: zstd (level 3)"와 같이 보고됩니다 (적용 중인 체크섬 선택과 함께).

       --skip-compress=LIST
              참고: 현재 어떤 압축 방법도 파일별 압축 변경을 지원하지 않으므로 이 옵션은 효과가 없습니다.

              가능한 한 적게 압축될 파일 접미사 목록을 재정의합니다.
              Rsync는 파일의 접미사에 따라 파일별로 압축 수준을 설정합니다.
              압축 알고리즘에 "해제(off)" 수준이 있는 경우 해당 파일에 대해서는 압축이 수행되지 않습니다.
              스트리밍 수준을 즉시 변경하는 것을 지원하는 다른 알고리즘은 일치하는 파일에 대해 CPU 사용량을 최대한 줄이기 위해 수준이 최소화됩니다.

              LIST는 슬래시(/)로 구분된 하나 이상의 파일 접미사(점 없이)여야 합니다.
              어떤 파일도 건너뛰지 않도록 빈 문자열을 지정할 수 있습니다.

              간단한 문자 클래스 일치가 지원됩니다: 각 클래스는 대괄호 안에 문자 목록으로 구성되어야 합니다 (예: "[:alpha:]"와 같은 특수 클래스는 지원되지 않으며, '-'는 특수 의미가 없습니다).

              별표(*)와 물음표(?) 문자는 특수 의미가 없습니다.

              다음은 건너뛸 6개의 접미사를 지정하는 예입니다 (5개 규칙 중 1개가 2개의 접미사와 일치하기 때문입니다):

                  --skip-compress=gz/jpg/mp[34]/7z/bz2

              이 rsync 버전의 skip-compress 목록에 있는 기본 파일 접미사는 다음과 같습니다:

                  3g2 3gp 7z aac ace apk avi bz2 deb dmg ear f4v flac flv gpg gz iso jar jpeg jpg lrz lz lz4 lzma lzo m1a m1v m2a m2ts m2v m4a m4b m4p m4r m4v mka mkv mov mp1 mp2  mp3  mp4  mpa
                  mpeg  mpg  mpv mts odb odf odg odi odm odp ods odt oga ogg ogm ogv ogx opus otg oth otp ots ott oxt png qt rar rpm rz rzip spx squashfs sxc sxd sxg sxm sxw sz tbz tbz2 tgz tlz
                  ts txz tzo vob war webm webp xz z zip zst

              이 목록은 한 가지 상황을 제외하고는 사용자 정의한 --skip-compress 목록으로 대체됩니다.
              데몬 rsync로부터의 복사는 건너뛴 접미사를 압축하지 않는 파일 목록에 추가합니다 (그리고 해당 목록은 다른 기본값으로 구성될 수 있습니다).

       --numeric-ids
              이 옵션을 사용하면 rsync는 사용자 및 그룹 이름을 사용하는 대신 숫자 그룹 및 사용자 ID를 전송하고 양쪽에서 매핑합니다.

              기본적으로 rsync는 파일에 어떤 소유권을 부여할지 결정하기 위해 사용자 이름과 그룹 이름을 사용합니다.
              특수 uid 0 및 특수 그룹 0은 --numeric-ids 옵션이 지정되지 않았더라도 사용자/그룹 이름으로 매핑되지 않습니다.

              사용자 또는 그룹이 소스 시스템에 이름이 없거나 대상 시스템에 일치하는 이름이 없으면, 소스 시스템의 숫자 ID가 대신 사용됩니다.
              chroot 설정이 rsync가 사용자 및 그룹의 이름을 조회하는 능력에 어떻게 영향을 미치는지, 그리고 이에 대해 무엇을 할 수 있는지에 대한 몇 가지 의견은 rsyncd.conf 맨페이지의 use chroot 설정을 참조하십시오.

       --usermap=STRING, --groupmap=STRING
              이 옵션은 수신 측에서 다른 값으로 매핑되어야 하는 사용자 및 그룹을 지정할 수 있도록 합니다.
              STRING은 쉼표로 구분된 하나 이상의 FROM:TO 값 쌍입니다.
              전송자로부터의 일치하는 FROM 값은 수신자로부터의 TO 값으로 대체됩니다.
              FROM 및 TO 값에 사용자 이름 또는 사용자 ID를 지정할 수 있으며, FROM 값은 와일드카드 문자열일 수도 있습니다.
              이것은 전송자의 이름과 일치합니다 (와일드카드는 ID 번호와 일치하지 않지만, 아래에서 '*'가 모든 것을 일치시키는 이유를 참조하십시오).
              포함 범위: LOW-HIGH를 통해 ID 번호 범위를 지정할 수도 있습니다. 예를 들어:

                  --usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr

              목록의 첫 번째 일치 항목이 사용됩니다.
              단일 --usermap 옵션을 사용하여 모든 사용자 매핑을 지정하고, 단일 --groupmap 옵션을 사용하여 모든 그룹 매핑을 지정해야 합니다.

              사용자 0 및 그룹 0에 대한 보내는 측의 이름은 받는 측으로 전송되지 않으므로, 이 값은 0을 사용하여 일치시키거나, 받는 측에서 사용 중인 이름(일반적으로 "root")을 사용해야 합니다.
              다른 모든 FROM 이름은 보내는 측에서 사용 중인 이름과 일치합니다.
              모든 TO 이름은 받는 측에서 사용 중인 이름과 일치합니다.

              보내는 측에 이름이 없는 모든 ID는 일치 목적을 위해 빈 이름을 가진 것으로 처리됩니다.
              이를 통해 "*" 또는 빈 이름을 사용하여 일치시킬 수 있습니다. 예를 들어:

                  --usermap=:nobody --groupmap=*:nobody

              --numeric-ids 옵션이 사용될 때, 보내는 측은 어떤 이름도 보내지 않으므로 모든 ID는 빈 이름을 가진 것으로 처리됩니다.
              이는 이름 없는 ID를 다른 값으로 매핑하려면 숫자 FROM 값을 지정해야 함을 의미합니다.

              --usermap 옵션이 작동하려면 수신자는 슈퍼유저로 실행되어야 합니다 (--super 및 --fake-super 옵션도 참조).
              --groupmap 옵션이 작동하려면 수신자는 해당 그룹을 설정할 권한이 있어야 합니다.

              rsync 3.2.4부터 --usermap 옵션은 --owner (-o) 옵션을 암시하며, --groupmap 옵션은 --group (-g) 옵션을 암시합니다 (매핑 옵션이 작동하려면 rsync가 해당 옵션을 활성화해야 하므로).

              오래된 rsync 클라이언트는 와일드카드 문자에 대한 불만을 피하기 위해 -s를 사용해야 할 수도 있지만, 최신 rsync는 이를 자동으로 처리합니다.

       --chown=USER:GROUP
              이 옵션은 모든 파일이 USER가 소유하고 GROUP에 속하도록 강제합니다.
              이는 --usermap 및 --groupmap을 직접 사용하는 것보다 간단한 인터페이스이지만, 내부적으로 해당 옵션을 사용하여 구현되므로 혼합하여 사용할 수 없습니다.
              USER 또는 GROUP이 비어 있으면 생략된 사용자/그룹에 대한 매핑은 발생하지 않습니다.
              GROUP이 비어 있으면 후행 콜론을 생략할 수 있지만, USER가 비어 있으면 선행 콜론을 제공해야 합니다.

              "--chown=foo:bar"를 지정하는 것은 "--usermap=*:foo --groupmap=*:bar"를 지정하는 것과 정확히 동일하며, 더 쉽습니다 (그리고 동일한 암시된 --owner 및/또는 --group 옵션을 가집니다).

              오래된 rsync 클라이언트는 와일드카드 문자에 대한 불만을 피하기 위해 -s를 사용해야 할 수도 있지만, 최신 rsync는 이를 자동으로 처리합니다.

       --timeout=SECONDS
              이 옵션을 사용하면 최대 I/O 타임아웃을 초 단위로 설정할 수 있습니다.
              지정된 시간 동안 데이터가 전송되지 않으면 rsync가 종료됩니다.
              기본값은 0이며, 이는 타임아웃이 없음을 의미합니다.

       --contimeout=SECONDS
              이 옵션은 rsync가 rsync 데몬에 연결하는 데 성공할 때까지 기다릴 시간을 설정할 수 있도록 합니다.
              타임아웃에 도달하면 rsync는 오류로 종료됩니다.

       --address=ADDRESS
              기본적으로 rsync는 rsync 데몬에 연결할 때 와일드카드 주소에 바인딩합니다.
              --address 옵션을 사용하면 특정 IP 주소(또는 호스트 이름)에 바인딩하도록 지정할 수 있습니다.

              --address 옵션의 데몬 버전도 참조하십시오.

       --port=PORT
              이것은 기본값 873 대신 사용할 대체 TCP 포트 번호를 지정합니다.
              이는 이중 콜론(::) 구문을 사용하여 rsync 데몬에 연결할 때만 필요합니다 (URL 구문에는 URL의 일부로 포트를 지정하는 방법이 있기 때문입니다).

              --port 옵션의 데몬 버전도 참조하십시오.

       --sockopts=OPTIONS
              이 옵션은 시스템을 최대한 튜닝하는 것을 좋아하는 사람들에게 끝없는 재미를 제공할 수 있습니다.
              전송 속도를 높이거나(또는 늦출 수 있는) 모든 종류의 소켓 옵션을 설정할 수 있습니다.
              설정할 수 있는 일부 옵션에 대한 자세한 내용은 setsockopt() 시스템 호출 맨페이지를 참조하십시오.
              기본적으로 특수 소켓 옵션은 설정되지 않습니다.
              이것은 원격 rsync 데몬에 대한 직접 소켓 연결에만 영향을 미칩니다.

              --sockopts 옵션의 데몬 버전도 참조하십시오.

       --blocking-io
              이것은 rsync에게 원격 셸 전송을 시작할 때 블로킹 I/O를 사용하도록 지시합니다.
              원격 셸이 rsh 또는 remsh인 경우, rsync는 기본적으로 블로킹 I/O를 사용하며, 그렇지 않으면 논블로킹 I/O를 사용합니다. (ssh는 논블로킹 I/O를 선호합니다.)

       --outbuf=MODE
              이것은 출력 버퍼링 모드를 설정합니다.
              모드는 None (일명 Unbuffered), Line, 또는 Block (일명 Full)이 될 수 있습니다.
              모드의 경우 한 글자만 지정할 수 있으며, 대소문자를 구분하지 않습니다.

              이 옵션의 주요 용도는 rsync의 출력이 파일이나 파이프로 전달될 때 전체 버퍼링을 라인 버퍼링으로 변경하는 것입니다.

       --itemize-changes, -i
              각  파일에 적용되는 변경 사항, 속성 변경 사항을 포함한 간단한 항목별 목록을 요청합니다. 이것은 --out-format='%i %n%L'을 지정하는 것과 정확히 동일합니다.
              옵션을 반복하면 변경되지 않은 파일도 출력되지만, 수신 rsync가 2.6.7 버전 이상인 경우에만 그렇습니다 (이전 rsync 버전에서는 -vv를 사용할 수 있지만, 이는 다른 상세 메시지 출력도 켭니다).

              "%i" 이스케이프는 11글자의 암호 같은 출력을 가집니다. 일반적인 형식은 YXcstpoguax와 같으며, Y는 수행되는 업데이트 유형으로 대체되고, X는 파일 유형으로 대체되며, 다른 글자는 수정될 수 있는 속성을 나타냅니다.

              Y를 대체하는 업데이트 유형은 다음과 같습니다:

              o      A <는 파일이 원격 호스트로 전송되고 있음을 의미합니다 (보냄).

              o      A >는 파일이 로컬 호스트로 전송되고 있음을 의미합니다 (받음).

              o      A c는 항목에 대한 로컬 변경/생성이 발생하고 있음을 의미합니다 (예: 디렉토리 생성 또는 심볼릭 링크 변경 등).

              o      A h는 항목이 다른 항목에 대한 하드 링크임을 의미합니다 (--hard-links 필요).

              o      A .는 항목이 업데이트되지 않고 있음을 의미합니다 (하지만 속성이 수정될 수 있음).

              o      A *는 항목별 출력 영역의 나머지 부분에 메시지가 포함되어 있음을 의미합니다 (예: "deleting").

              X를 대체하는 파일 유형은 다음과 같습니다: 파일의 경우 f, 디렉토리의 경우 d, 심볼릭 링크의 경우 L, 장치의 경우 D, 특수 파일(예: 명명된 소켓 및 FIFO)의 경우 S.

              문자열의 다른 글자는 파일의 일부 속성이 변경되었는지 여부를 나타내며, 다음과 같습니다:

              o      "." - 속성이 변경되지 않았습니다.

              o      "+" - 파일이 새로 생성되었습니다.

              o      " " - 모든 속성이 변경되지 않았습니다 (모든 점이 공백으로 바뀝니다).

              o      "?" - 변경 사항을 알 수 없습니다 (원격 rsync가 오래된 경우).

              o      문자는 속성이 업데이트되고 있음을 나타냅니다.

              각 문자와 관련된 속성은 다음과 같습니다:

              o      c는 일반 파일의 체크섬이 다르거나 (--checksum 필요) 심볼릭 링크, 장치 또는 특수 파일의 값이 변경되었음을 의미합니다.
                     rsync 3.0.1 이전 버전으로 파일을 보내는 경우, 이 변경 플래그는 체크섬이 다른 일반 파일에만 나타납니다.

              o      s는 일반 파일의 크기가 다르며 파일 전송에 의해 업데이트될 것임을 의미합니다.

              o      t는 수정 시간이 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--times 필요).
                     대체 값 T는 수정 시간이 전송 시간으로 설정됨을 의미합니다.
                     이는 파일/심볼릭 링크/장치가 --times 없이 업데이트될 때, 그리고 심볼릭 링크가 변경되고 수신자가 시간을 설정할 수 없을 때 발생합니다.
                     (참고: rsync 3.0.0 클라이언트를 사용할 때, 이 시간 설정 실패에 대해 적절한 T 플래그 대신 s 플래그가 t와 결합된 것을 볼 수 있습니다.)

              o      p는 권한이 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--perms 필요).

              o      o는 소유자가 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--owner 및 슈퍼유저 권한 필요).

              o      g는 그룹이 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--group 및 그룹 설정 권한 필요).

              o

                     o      u|n|b는 다음 정보를 나타냅니다:

                            u  접근(사용) 시간이 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--atimes 필요)

                     o      n 생성 시간(새로움)이 다르며 전송자의 값으로 업데이트되고 있음을 의미합니다 (--crtimes 필요)

                     o      b 접근 시간과 생성 시간 모두 업데이트되고 있음을 의미합니다

              o      a는 ACL 정보가 변경되고 있음을 의미합니다.

              o      x는 확장 속성 정보가 변경되고 있음을 의미합니다.

              또 다른 출력이 가능합니다: 파일을 삭제할 때, "%i"는 제거되는 각 항목에 대해 "*deleting" 문자열을 출력합니다 (충분히 최신 rsync와 통신하여 삭제를 상세 메시지로 출력하는 대신 로그에 기록하는 경우).

       --out-format=FORMAT
              이것은 rsync 클라이언트가 사용자에게 업데이트별로 정확히 무엇을 출력할지 지정할 수 있도록 합니다.
              형식은 퍼센트(%) 문자로 시작하는 내장된 단일 문자 이스케이프 시퀀스를 포함하는 텍스트 문자열입니다.
              --info=name 또는 -v가 지정되면 "%n%L"의 기본 형식이 가정됩니다 (이는 파일 이름과, 항목이 링크인 경우 가리키는 위치만 알려줍니다).
              가능한 이스케이프 문자의 전체 목록은 rsyncd.conf 맨페이지의 log format 설정을 참조하십시오.

              --out-format 옵션을 지정하면 --info=name 옵션이 암시됩니다.
              이 옵션은 상당한 방식으로 업데이트되는 각 파일, 디렉토리 등을 언급합니다 (전송된 파일, 재구성된 심볼릭 링크/장치, 또는 터치된 디렉토리).
              또한, 항목별 변경 이스케이프(%i)가 문자열에 포함된 경우 (예: --itemize-changes 옵션이 사용된 경우), 이름 로깅은 어떤 식으로든 변경된 모든 항목을 언급하도록 증가합니다 (수신 측이 최소 2.6.4 버전인 한).
              "%i" 출력에 대한 설명은 --itemize-changes 옵션을 참조하십시오.

              rsync는 파일 전송 전에 out-format 문자열을 출력합니다. 단, 전송 통계 이스케이프 중 하나가 요청된 경우에는 파일 전송이 끝날 때 로깅이 수행됩니다.
              이 후반 로깅이 적용되고 --progress도 지정되면, rsync는 진행 정보 앞에 전송 중인 파일의 이름도 출력합니다 (물론 out-format 출력 뒤에).

       --log-file=FILE
              이 옵션은 rsync가 수행하는 작업을 파일에 기록하도록 합니다.
              이는 데몬이 수행하는 로깅과 유사하지만, 클라이언트 측 및/또는 비데몬 전송의 서버 측에 대해 요청할 수 있습니다.
              클라이언트 옵션으로 지정하면, 기본 형식인 "%i %n%L"로 전송 로깅이 활성화됩니다.
              이를 재정의하려면 --log-file-format 옵션을 참조하십시오.

              다음은 원격 측에서 발생하는 일을 기록하도록 요청하는 명령의 예시입니다:

                  rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/

              연결이 예기치 않게 종료되는 이유를 디버깅해야 할 때 매우 유용합니다.

              --log-file 옵션의 데몬 버전도 참조하십시오.

       --log-file-format=FORMAT
              이것은 --log-file 옵션으로 지정된 파일에 어떤 업데이트별 로깅이 기록될지 정확히 지정할 수 있도록 합니다 (--log-file 옵션도 이 옵션이 효과를 가지려면 지정되어야 합니다).
              빈 문자열을 지정하면 업데이트된 파일은 로그 파일에 언급되지 않습니다.
              가능한 이스케이프 문자의 목록은 rsyncd.conf 맨페이지의 log format 설정을 참조하십시오.

              --log-file이 지정되고 이 옵션이 지정되지 않은 경우 사용되는 기본 FORMAT은 '%i %n%L'입니다.

              --log-file-format 옵션의 데몬 버전도 참조하십시오.

       --stats
              이것은 rsync에게 파일 전송에 대한 자세한 통계 집합을 출력하도록 지시하여, 데이터에 대한 rsync의 델타-전송 알고리즘이 얼마나 효과적인지 알 수 있도록 합니다.
              이 옵션은 0 또는 1개의 -v 옵션과 결합하면 --info=stats2와 동일하며, 2개 이상의 -v 옵션과 결합하면 --info=stats3와 동일합니다.

              현재 통계는 다음과 같습니다:

              o      Number of files (파일 수)는 디렉토리, 심볼릭 링크 등을 포함한 모든 "파일"(일반적인 의미에서)의 개수입니다.
                     총 개수 뒤에는 파일 유형별 개수 목록이 표시됩니다 (총 개수가 0이 아닌 경우).
                     예: "(reg: 5, dir: 3, link: 2, dev: 1, special: 1)"는 일반 파일, 디렉토리, 심볼릭 링크, 장치 및 특수 파일의 총 개수를 나열합니다.
                     값이 0인 경우 목록에서 완전히 생략됩니다.

              o      Number of created files (생성된 파일 수)는 생성된 (업데이트된 것과 반대되는) "파일"(일반적인 의미에서)의 개수입니다.
                     총 개수 뒤에는 파일 유형별 개수 목록이 표시됩니다 (총 개수가 0이 아닌 경우).

              o      Number of deleted files (삭제된 파일 수)는 삭제된 "파일"(일반적인 의미에서)의 개수입니다.
                     총 개수 뒤에는 파일 유형별 개수 목록이 표시됩니다 (총 개수가 0이 아닌 경우).
                     이 줄은 삭제가 적용 중일 때만 출력되며, 프로토콜 31이 사용 중일 때만 출력됩니다 (rsync 3.1.x의 기본값).

              o      Number of regular files transferred (전송된 일반 파일 수)는 rsync의 델타-전송 알고리즘을 통해 업데이트된 일반 파일의 개수입니다.
                     이는 디렉토리, 심볼릭 링크 등을 포함하지 않습니다. rsync 3.1.0부터 이 제목에 "regular"라는 단어가 추가되었습니다.

              o      Total file size (총 파일 크기)는 전송에서 모든 파일 크기의 총합입니다.
                     이는 디렉토리나 특수 파일의 크기는 계산하지 않지만, 심볼릭 링크의 크기는 포함합니다.

              o      Total transferred file size (총 전송 파일 크기)는 전송된 파일만의 모든 파일 크기의 총합입니다.

              o      Literal data (리터럴 데이터)는 업데이트된 파일을 재구성하기 위해 수신자에게 보내야 했던 일치하지 않는 파일 업데이트 데이터의 양입니다.

              o      Matched data (일치하는 데이터)는 업데이트된 파일을 재구성할 때 수신자가 로컬에서 얻은 데이터의 양입니다.

              o      File list size (파일 목록 크기)는 전송자가 수신자에게 보낼 때 파일 목록 데이터의 크기였습니다.
                     이는 rsync가 목록을 보낼 때 중복 데이터를 압축하기 때문에 파일 목록의 메모리 내 크기보다 작습니다.

              o      File list generation time (파일 목록 생성 시간)은 전송자가 파일 목록을 생성하는 데 소요된 시간(초)입니다.
                     이것이 존재하려면 보내는 측에 최신 rsync가 필요합니다.

              o      File list transfer time (파일 목록 전송 시간)은 전송자가 수신자에게 파일 목록을 보내는 데 소요된 시간(초)입니다.

              o      Total bytes sent (총 보낸 바이트)는 rsync가 클라이언트 측에서 서버 측으로 보낸 모든 바이트의 개수입니다.

              o      Total bytes received (총 받은 바이트)는 rsync가 클라이언트 측에서 서버 측으로부터 수신한 비메시지 바이트의 총 개수입니다.
                     "비메시지" 바이트는 서버가 우리에게 보낸 상세 메시지의 바이트를 계산하지 않는다는 의미이며, 이는 통계를 더 일관성 있게 만듭니다.

       --8-bit-output, -8
              이것은 rsync에게 모든 높은 비트 문자를 현재 로케일에서 유효한지 테스트하고 유효하지 않은 문자를 이스케이프하려고 시도하는 대신, 출력에서 이스케이프되지 않은 채로 두도록 지시합니다.
              이 옵션 설정과 관계없이 모든 제어 문자(탭은 제외)는 항상 이스케이프됩니다.

              2.6.7부터 시작된 이스케이프 관용구는 리터럴 역슬래시(\)와 해시(#)를 출력한 다음 정확히 3개의 8진수 숫자를 출력하는 것입니다.
              예를 들어, 새 줄은 "\#012"로 출력됩니다. 파일 이름에 있는 리터럴 역슬래시는 해시와 3개의 숫자(0-9)가 뒤따르지 않는 한 이스케이프되지 않습니다.

       --human-readable, -h
              숫자를 사람이 읽기 쉬운 형식으로 출력합니다. 가능한 수준은 3가지입니다:

              1.     세 자리마다 구분 기호(소수점이 마침표 또는 쉼표로 표시되는지에 따라 쉼표 또는 마침표)를 사용하여 숫자를 출력합니다.

              2.     1000 단위로 숫자를 출력합니다 (더 큰 단위에는 문자 접미사 사용 -- 아래 참조).

              3.     1024 단위로 숫자를 출력합니다.

              기본값은 사람이 읽기 쉬운 수준 1입니다. 각 -h 옵션은 수준을 1씩 증가시킵니다.
              --no-human-readable (--no-h) 옵션을 지정하여 수준을 0으로 낮출 수 있습니다 (순수 숫자로 출력).

              수준 2와 3에서 추가되는 단위 문자는 다음과 같습니다: K (킬로), M (메가), G (기가), T (테라), P (페타).
              예를 들어, 1234567바이트 파일은 수준 2에서 1.23M으로 출력됩니다 (마침표가 로컬 소수점이라고 가정).

              하위 호환성 참고: rsync 3.1.0 이전 버전은 사람이 읽기 쉬운 수준 1을 지원하지 않으며, 기본적으로 수준 0을 사용합니다.
              따라서 하나 또는 두 개의 -h 옵션을 지정하는 것은 하나 이상의 -h 옵션 이전에 --no-h 옵션을 지정하지 않는 한 이전 및 새 버전에서 유사한 방식으로 작동합니다.
              한 가지 차이점에 대해서는 --list-only 옵션을 참조하십시오.

       --partial
              기본적으로 rsync는 전송이 중단되면 부분적으로 전송된 파일을 삭제합니다.
              어떤 경우에는 부분적으로 전송된 파일을 유지하는 것이 더 바람직합니다.
              --partial 옵션을 사용하면 rsync는 부분 파일을 유지하도록 지시하여 후속 파일 전송을 훨씬 빠르게 할 수 있습니다.

       --partial-dir=DIR
              이 옵션은 --partial 옵션의 동작을 수정하는 동시에 이 옵션이 활성화되도록 암시합니다.
              이 향상된 부분 파일 방식은 부분적으로 전송된 모든 파일을 대상 파일로 직접 쓰는 대신 지정된 DIR에 저장합니다.
              다음 전송 시 rsync는 이 디렉토리에서 발견된 파일을 데이터로 사용하여 전송 재개 속도를 높이고, 역할을 다하면 삭제합니다.

              --whole-file이 지정되었거나 (또는 암시되었을 때), 업데이트되는 파일에 대해 발견된 partial-dir 파일은 단순히 제거됩니다 (rsync는 rsync의 델타-전송 알고리즘을 사용하지 않고 파일을 보내기 때문입니다).

              Rsync는 DIR이 누락된 경우 생성하지만, 마지막 디렉토리만 생성하며 전체 경로는 생성하지 않습니다.
              이는 상대 경로(예: "--partial-dir=.rsync-partial")를 사용하여 rsync가 필요할 때 대상 파일의 디렉토리에 부분 디렉토리를 생성한 다음, 부분 파일이 삭제될 때 다시 제거하도록 하는 것을 쉽게 만듭니다.
              이 디렉토리 제거는 상대 경로에 대해서만 수행됩니다. 절대 경로는 partial-dir 작업 전용 디렉토리로 예상되기 때문입니다.

              partial-dir 값이 절대 경로가 아닌 경우, rsync는 기존 모든 제외 규칙 끝에 제외 규칙을 추가합니다.
              이것은 보내는 측에 존재할 수 있는 partial-dir 파일 전송을 방지하고, 수신 측에서 partial-dir 항목이 시기적절하게 삭제되는 것을 방지합니다.
              예: 위 --partial-dir 옵션은 다른 필터 규칙 끝에 이와 동등한 "소멸성" 제외 규칙을 추가합니다: -f '-p .rsync-partial/'

              자신만의 제외 규칙을 제공하는 경우, 다음 이유로 인해 partial-dir에 대한 자신만의 제외/숨김/보호 규칙을 추가해야 할 수도 있습니다:

              4.     자동 추가된 규칙이 다른 규칙의 끝에서는 효과적이지 않을 수 있거나,

              5.     rsync의 제외 선택을 재정의하고 싶을 수 있기 때문입니다.

              예를 들어, rsync가 남아 있는 partial-dir을 정리하도록 하려면 --delete-after를 지정하고 "위험" 필터 규칙을 추가해야 합니다. 예: -f 'R .rsync-partial/'.
              --delete-before 또는 --delete-during 사용은 현재 실행 중에 rsync가 남아 있는 partial-dir 데이터를 사용할 필요가 없는 경우가 아니면 피하십시오.

              중요: --partial-dir은 다른 사용자가 쓸 수 없어야 합니다. 그렇지 않으면 보안 위험이 있습니다! 예: "/tmp"는 피하십시오!

              RSYNC_PARTIAL_DIR 환경 변수에 partial-dir 값을 설정할 수도 있습니다.
              환경에 이것을 설정하는 것은 부분 전송이 활성화되도록 강제하지 않지만, --partial이 지정되었을 때 부분 파일이 어디로 가는지에 영향을 미칩니다.
              예를 들어, --progress와 함께 --partial-dir=.rsync-tmp를 사용하는 대신, 환경에 RSYNC_PARTIAL_DIR=.rsync-tmp를 설정하고 -P 옵션을 사용하여 부분 전송에 .rsync-tmp 디렉토리 사용을 켤 수 있습니다.
              --partial 옵션이 이 환경 값을 찾지 않는 유일한 경우는 다음과 같습니다:

              6.     --inplace가 지정되었을 때 (--inplace는 --partial-dir과 충돌하므로), 그리고

              7.     --delay-updates가 지정되었을 때 (아래 참조).

              최신 rsync가 partial-dir의 파일 전송을 재개할 때, 해당 부분 파일은 이제 또 다른 임시 파일 복사본을 만드는 대신 제자리에서 업데이트됩니다 (따라서 dest + partial + tmp 대신 dest + tmp에서 최대화됩니다).
              이는 전송의 양쪽 끝이 최소 버전 3.2.0이어야 합니다.

              데몬-구성의 "refuse options" 설정 목적상, --partial-dir은 --partial을 암시하지 않습니다.
              이는 --partial 옵션의 거부가 부분 전송으로 대상 파일을 덮어쓰는 것을 허용하지 않으면서도 --partial-dir이 제공하는 더 안전한 관용구를 허용할 수 있도록 하기 위함입니다.

       --delay-updates
              이 옵션은 각 업데이트된 파일의 임시 파일을 전송이 끝날 때까지 보류 디렉토리에 넣은 다음, 모든 파일의 이름이 순식간에 제자리로 변경되도록 합니다.
              이는 파일 업데이트를 좀 더 원자적으로 만들기 위한 시도입니다.
              기본적으로 파일은 각 파일의 대상 디렉토리 내에 .~tmp~라는 디렉토리에 배치되지만, --partial-dir 옵션을 지정한 경우 해당 디렉토리가 대신 사용됩니다.
              .~tmp~ 디렉토리가 전송에서 제외되는 방법과 rsync가 남아 있을 수 있는 오래된 .~tmp~ 디렉토리를 정리하도록 하려면 --partial-dir 섹션의 설명을 참조하십시오.
              --inplace 및 --append와 충돌합니다.

              이 옵션은 끝에서 반복할 수 있도록 전체 파일 목록이 메모리에 있어야 하므로 --no-inc-recursive를 암시합니다.

              이 옵션은 수신 측에서 더 많은 메모리(전송된 파일당 1비트)를 사용하며, 업데이트된 모든 파일의 추가 복사본을 저장할 수 있는 충분한 여유 디스크 공간이 수신 측에 필요합니다.
              또한 --partial-dir에 절대 경로를 사용해서는 안 됩니다. 다음 경우를 제외하고는:

              8.     전송되는 파일 중 이름이 같은 파일이 있을 가능성이 전혀 없을 때 (경로가 절대 경로인 경우 모든 업데이트된 파일이 단일 디렉토리에 배치되므로), 그리고

              9.     계층 구조에 마운트 지점이 없을 때 (지연된 업데이트가 제자리로 이름이 변경되지 않으면 실패하므로).

              "atomic-rsync" python 스크립트도 "support" 하위 디렉토리에 있습니다. 이 스크립트는 훨씬 더 원자적인 업데이트 알고리즘을 사용합니다 (--link-dest 및 파일의 병렬 계층 구조 사용).

       --prune-empty-dirs, -m
              이 옵션은 수신 rsync에게 파일 목록에서 빈 디렉토리, 비디렉토리 자식이 없는 중첩된 디렉토리를 포함하여 제거하도록 지시합니다.
              이는 보내는 rsync가 포함/제외/필터 규칙을 사용하여 파일 계층 구조를 재귀적으로 스캔할 때 쓸모없는 디렉토리가 많이 생성되는 것을 방지하는 데 유용합니다.

              이 옵션은 TRANSFER_RULES를 사용하는 경우 수신 측에 빈 디렉토리를 남길 수도 있습니다.

              파일 목록이 실제로 정리되고 있기 때문에 이 옵션은 삭제가 활성화되었을 때 어떤 디렉토리가 삭제될지에도 영향을 미칩니다.
              그러나 제외된 파일 및 디렉토리가 소스 파일을 숨기고 대상 파일을 보호하는 두 가지 이유로 기존 항목이 삭제되는 것을 방지할 수 있다는 점을 명심하십시오.
              이를 피하는 방법에 대해서는 소멸성 필터 규칙 옵션을 참조하십시오.

              글로벌 "보호" 필터를 사용하여 파일 목록에서 특정 빈 디렉토리가 정리되는 것을 방지할 수 있습니다.
              예를 들어, 이 옵션은 "emptydir" 디렉토리가 파일 목록에 유지되도록 보장합니다:

                  --filter 'protect emptydir/'

              다음은 계층 구조에 있는 모든 .pdf 파일을 복사하고, .pdf 파일을 보관하는 데 필요한 대상 디렉토리만 생성하며, 대상의 불필요한 파일 및 디렉토리가 제거되도록 하는 예시입니다 (비디렉토리를 숨기는 필터가 제외 대신 사용됨을 주의하십시오):

                  rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest

              불필요한 대상 파일을 제거하고 싶지 않다면, --include='*/' --exclude='*'라는 더 오래된 옵션이 hide-filter 대신 잘 작동할 것입니다 (더 자연스럽게 느껴진다면).

       --progress
              이 옵션은 rsync에게 전송 진행 상황을 보여주는 정보를 출력하도록 지시합니다.
              이는 지루한 사용자에게 볼거리를 제공합니다.
              최신 rsync에서는 --info=flist2,name,progress를 지정하는 것과 동일하지만, 해당 정보 플래그에 대한 사용자 제공 설정이 우선합니다 (예: --info=flist0 --progress).

              rsync가 일반 파일을 전송하는 동안, 다음과 같은 진행 상황 줄을 업데이트합니다:

                  782448  63%  110.64kB/s    0:00:04

              이 예시에서 수신자는 보내는 측 파일의 782448바이트 또는 63%를 재구성했으며, 초당 110.64킬로바이트의 속도로 재구성되고 있으며, 현재 속도가 유지되면 4초 후에 전송이 완료될 것입니다.

              rsync의 델타-전송 알고리즘이 사용 중인 경우 이러한 통계는 오해의 소지가 있을 수 있습니다.
              예를 들어, 보내는 측 파일이 기준 파일과 추가 데이터로 구성된 경우, 수신자가 리터럴 데이터에 도달하면 보고된 속도가 극적으로 떨어질 수 있으며, 파일의 일치하는 부분을 완료할 때 수신자가 예상한 것보다 전송 완료 시간이 훨씬 오래 걸릴 수 있습니다.

              파일 전송이 완료되면 rsync는 진행 상황 줄을 다음과 같은 요약 줄로 바꿉니다:

                  1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)

              이 예시에서 파일의 총 길이는 1,238,099바이트였고, 전체 파일의 평균 전송 속도는 완료하는 데 걸린 8초 동안 초당 146.38킬로바이트였습니다.
              이것은 현재 rsync 세션 동안 일반 파일의 5번째 전송이었고, 파일 목록의 총 396개 파일 중 수신자가 확인해야 할 파일은 169개 남아 있습니다 (최신 상태인지 여부를 확인하기 위해).

              증분 재귀 스캔에서 rsync는 스캔이 끝날 때까지 파일 목록의 총 파일 수를 알지 못하지만, 스캔 중에 파일을 전송하기 시작하므로 목록의 전체 크기를 알 때까지 "to-chk" 대신 "ir-chk"(증분 재귀 확인) 텍스트가 포함된 줄을 표시합니다.
              따라서 "ir-chk"를 보면 파일 목록의 총 파일 수가 계속 증가할 것임을 알 수 있습니다 (그리고 그럴 때마다 확인해야 할 파일 수는 목록에 추가된 파일 수만큼 증가합니다).

       -P     -P 옵션은 "--partial --progress"와 동일합니다. 그 목적은 중단될 수 있는 긴 전송에 대해 이 두 옵션을 지정하는 것을 훨씬 쉽게 만드는 것입니다.

              전체 전송을 기반으로 통계를 출력하는 --info=progress2 옵션도 있습니다.
              파일 이름 없이 이 플래그를 사용하십시오 (예: -v를 피하거나 --info=name0을 지정하십시오).
              화면을 많은 이름으로 스크롤하지 않고 전송이 어떻게 진행되고 있는지 보고 싶다면. (--info=progress2를 사용하기 위해 --progress 옵션을 지정할 필요는 없습니다.)

              마지막으로, SIGINFO 또는 SIGVTALRM 신호를 rsync에 보내면 즉시 진행 보고서를 받을 수 있습니다.
              BSD 시스템에서는 Ctrl+T를 입력하여 SIGINFO가 생성됩니다 (Linux는 현재 SIGINFO 신호를 지원하지 않습니다).
              클라이언트 측 프로세스가 이러한 신호 중 하나를 받으면 단일 진행 보고서를 출력하기 위한 플래그를 설정하고, 현재 파일 전송이 완료될 때 출력됩니다 (따라서 신호가 도착할 때 큰 파일이 처리 중이면 약간의 시간이 걸릴 수 있습니다).
              파일 이름이 출력된 후 (필요한 경우) --info=progress2 형식의 진행 정보가 출력됩니다.
              3개의 rsync 프로세스 중 어느 것이 클라이언트 프로세스인지 모르는 경우, 모든 프로세스에 신호를 보내도 괜찮습니다 (비클라이언트 프로세스는 신호를 무시합니다).

              주의: 오래된 rsync (3.2.0 이전)에 SIGVTALRM을 보내면 종료됩니다.

       --password-file=FILE
              이 옵션을 사용하면 파일 또는 표준 입력(-)을 통해 rsync 데몬에 액세스할 때 암호를 제공할 수 있습니다.
              파일은 첫 줄에 암호만 포함해야 합니다 (다른 모든 줄은 무시됩니다).
              FILE이 전 세계적으로 읽을 수 있거나 root로 실행되는 rsync 명령이 root 소유가 아닌 파일을 발견하면 rsync는 오류와 함께 종료됩니다.

              이 옵션은 ssh와 같은 원격 셸 전송에 암호를 제공하지 않습니다.
              이를 수행하는 방법은 원격 셸의 설명서를 참조하십시오.
              원격 셸을 전송으로 사용하여 rsync 데몬에 액세스할 때, 이 옵션은 원격 셸이 인증을 마친 후에만 적용됩니다 (즉, 데몬의 구성 파일에도 암호를 지정한 경우).

       --early-input=FILE
              이 옵션을 사용하면 rsync가 "early exec" 스크립트의 표준 입력으로 최대 5K의 데이터를 보낼 수 있습니다.
              이 데이터의 한 가지 가능한 용도는 스크립트에 암호화된 파일 시스템을 마운트하는 데 사용할 수 있는 비밀을 제공하는 것입니다 ("post-xfer exec" 스크립트에서 마운트 해제해야 합니다).

              데몬은 최소 3.2.1 버전이어야 합니다.

       --list-only
              이  옵션은 소스 파일이 전송되는 대신 나열되도록 합니다. 이 옵션은 단일 소스 인자가 있고 대상이 지정되지 않은 경우 추론되므로, 주요 용도는 다음과 같습니다:

              10.     대상 인자를 포함하는 복사 명령을 파일 목록 명령으로 전환하거나,

              11.     두 개 이상의 소스 인자를 지정할 수 있도록 합니다. 참고: 대상을 반드시 포함하십시오.

              주의: 와일드카드가 있는 소스 인자는 셸에 의해 여러 인자로 확장되므로, 이 옵션을 추론하기 위해 단일 와일드카드 인자를 지정하는 것은 안전하지 않습니다. 안전한 예시는 다음과 같습니다:

                  rsync -av --list-only foo* dest/

              이 옵션은 항상 다음과 유사한 출력 형식을 사용합니다:

                  drwxrwxr-x          4,096 2022/09/30 12:53:11 support
                  -rw-rw-r--             80 2005/01/11 10:37:37 support/Makefile

              이 출력 스타일에 영향을 미치는 유일한 옵션은 (3.1.0 기준) --human-readable (-h) 옵션입니다.
              기본값은 숫자 구분 기호가 있는 바이트 수(14자 너비 열)로 크기를 출력하는 것입니다.
              하나 이상의 -h 옵션을 지정하면 크기가 단위 접미사와 함께 출력됩니다.
              숫자 구분 기호가 없는 이전 스타일 바이트 수 크기(11자 너비 열)를 원하면 --no-h를 사용하십시오.

              호환성 참고: rsync 2.6.3 이하 버전에서 원격 파일 목록을 요청할 때 비재귀적 목록을 요청하면 오류가 발생할 수 있습니다.
              이는 파일 목록이 --recursive 없이 --dirs 옵션을 암시하고, 오래된 rsync에는 해당 옵션이 없기 때문입니다.
              이 문제를 피하려면 --no-dirs 옵션을 지정하거나 (디렉토리 내용을 확장할 필요가 없는 경우), 재귀를 켜고 하위 디렉토리 내용을 제외하십시오: -r --exclude='/*/*'.

       --bwlimit=RATE
              이 옵션은 소켓을 통해 전송되는 데이터의 최대 전송 속도를 초당 단위로 지정할 수 있도록 합니다.
              RATE 값 뒤에는 크기 승수를 나타내는 문자열을 붙일 수 있으며, 분수 값일 수도 있습니다 (예: --bwlimit=1.5m).
              접미사가 지정되지 않으면 값은 1024바이트 단위로 가정됩니다 (마치 "K" 또는 "KiB"가 추가된 것처럼).
              사용 가능한 모든 접미사에 대한 설명은 --max-size 옵션을 참조하십시오.
              0 값은 제한 없음을 지정합니다.

              하위 호환성을 위해 속도 제한은 가장 가까운 KiB 단위로 반올림되므로, 초당 1024바이트보다 작은 속도는 불가능합니다.

              Rsync는 소켓을 통해 데이터를 블록 단위로 기록하며, 이 옵션은 rsync가 쓰는 블록의 크기를 제한하고 요청된 제한에서 평균 전송 속도를 유지하려고 합니다.
              rsync가 데이터 블록을 쓰고 평균 속도를 준수하기 위해 잠시 대기하는 경우 일부 버스티니스(burstiness)가 나타날 수 있습니다.

              내부적인 데이터 버퍼링으로 인해 --progress 옵션은 데이터 전송 속도를 정확하게 반영하지 못할 수 있습니다.
              일부 파일은 데이터가 빠르게 버퍼링될 때 빠르게 전송되는 것처럼 보일 수 있고, 다른 파일은 출력 버퍼 플러싱이 발생할 때 매우 느리게 전송되는 것처럼 보일 수 있기 때문입니다.
              이것은 향후 버전에서 수정될 수 있습니다.

              --bwlimit 옵션의 데몬 버전도 참조하십시오.

       --stop-after=MINS, (--time-limit=MINS)
              이 옵션은 rsync에게 지정된 시간이 경과하면 복사를 중지하도록 지시합니다.

              최대한의 유연성을 위해 rsync는 이 옵션을 원격 rsync에 통신하지 않습니다.
              연결의 한쪽이 지정된 대로 종료하는 것으로 충분하기 때문입니다.
              이를 통해 연결의 한쪽만 이 옵션을 지원하는 경우에도 사용할 수 있습니다.
              필요하다면 --remote-option (-M)을 사용하여 원격 측에 시간 제한을 알릴 수 있습니다.

              --time-limit 버전의 이 옵션은 더 이상 사용되지 않습니다.

       --stop-at=y-m-dTh:m
              이 옵션은 rsync에게 지정된 시간에 복사를 중지하도록 지시합니다.
              날짜 및 시간은 로컬 시간대에서 연-월-일Th시:분 (예: 2000-12-31T23:59)의 숫자 형식으로 완전히 지정할 수 있습니다.
              날짜 숫자를 대시 대신 슬래시로 구분해도 됩니다.

              값은 또한 2자리 연도를 지정하거나 다양한 값을 생략하는 등 여러 가지 방식으로 축약될 수 있습니다.
              모든 경우에 이 값은 제공된 정보와 일치하는 다음 가능한 시간 지점으로 간주됩니다.
              값이 현재 시간 또는 과거 시간을 지정하면 rsync는 오류와 함께 종료됩니다.

              예를 들어, "1-30"은 다음 1월 30일 (로컬 자정)을 지정하고, "14:00"은 다음 오후 2시를 지정하며, "1"은 다음 달 1일 자정을 지정하고, "31"은 다음 달 중 31일에 멈출 수 있는 다음 달을 지정하며, ":59"는 시간당 다음 59분을 지정합니다.

              최대한의 유연성을 위해 rsync는 이 옵션을 원격 rsync에 통신하지 않습니다.
              연결의 한쪽이 지정된 대로 종료하는 것으로 충분하기 때문입니다.
              이를 통해 연결의 한쪽만 이 옵션을 지원하는 경우에도 사용할 수 있습니다.
              필요하다면 --remote-option (-M)을 사용하여 원격 측에 시간 제한을 알릴 수 있습니다.
              원격 호스트가 로컬 호스트와 다른 기본 시간대를 가질 수 있다는 점을 명심하십시오.

       --fsync
              수신 측에서 각 완료된 파일을 fsync하도록 합니다.
              이는 전송 속도를 늦출 수 있지만, 중요한 파일을 업데이트할 때 안심할 수 있도록 도움이 됩니다.

       --write-batch=FILE
              나중에 --read-batch로 다른 동일한 대상에 적용할 수 있는 파일을 기록합니다.
              자세한 내용은 "BATCH MODE" 섹션을 참조하고, --only-write-batch 옵션도 참조하십시오.

              이 옵션은 협상된 체크섬 및 압축 목록을 재정의하며 항상 구식 md5/md4/zlib 선택을 기반으로 선택을 협상합니다.
              더 현대적인 선택을 원한다면 --checksum-choice (--cc) 및/또는 --compress-choice (--zc) 옵션을 사용하십시오.

       --only-write-batch=FILE
              --write-batch처럼 작동하지만, 배치를 생성할 때 대상 시스템에 업데이트를 수행하지 않습니다.
              이를 통해 다른 수단을 통해 변경 사항을 대상 시스템으로 전송한 다음, --read-batch를 통해 변경 사항을 적용할 수 있습니다.

              배치 파일을 휴대용 미디어에 직접 쓰는 것이 자유롭다는 점에 유의하십시오.
              만약 이 미디어가 전송이 끝나기 전에 용량을 채우면, 해당 부분 전송을 대상에 적용하고 전체 프로세스를 반복하여 나머지 변경 사항을 얻을 수 있습니다 (다중 업데이트 주기가 진행되는 동안 부분적으로 업데이트된 대상 시스템이 있어도 괜찮다면).

              또한 원격 시스템에 변경 사항을 푸시할 때만 대역폭을 절약할 수 있습니다.
              이는 배치된 데이터를 보내는 측에서 배치 파일로 전환하여 수신자에게 유선을 통해 흐르도록 할 필요 없이 만들 수 있기 때문입니다 (가져올 때, 보내는 측이 원격에 있으므로 배치를 쓸 수 없습니다).

       --read-batch=FILE
              FILE에 저장된 모든 변경 사항을 적용합니다. FILE은 이전에 --write-batch에 의해 생성된 파일입니다.
              FILE이 '-'이면 배치 데이터는 표준 입력에서 읽힙니다.
              자세한 내용은 "BATCH MODE" 섹션을 참조하십시오.

       --protocol=NUM
              이전 프로토콜 버전을 강제로 사용합니다.
              이는 이전 버전의 rsync와 호환되는 배치 파일을 생성하는 데 유용합니다.
              예를 들어, rsync 2.6.4가 --write-batch 옵션과 함께 사용되지만, rsync 2.6.3이 --read-batch 옵션을 실행하는 데 사용될 예정이라면, 배치 파일 생성 시 "--protocol=28"을 사용하여 배치 파일에서 이전 프로토콜 버전이 사용되도록 강제해야 합니다 (읽기 시스템의 rsync를 업그레이드할 수 없다고 가정할 때).

       --iconv=CONVERT_SPEC
              Rsync는 이 옵션을 사용하여 문자셋 간에 파일 이름을 변환할 수 있습니다.
              CONVERT_SPEC으로 "."을 사용하면 rsync에게 로케일 설정을 통해 기본 문자셋을 찾도록 지시합니다.
              또는 --iconv=LOCAL,REMOTE와 같이 쉼표로 구분된 로컬 및 원격 문자셋을 순서대로 지정하여 변환할 내용을 완전히 지정할 수 있습니다. 예를 들어 --iconv=utf8,iso88591.
              이 순서는 파일을 푸시하든 풀링하든 옵션이 동일하게 유지되도록 보장합니다.
              마지막으로, --no-iconv 또는 CONVERT_SPEC으로 "-"를 지정하여 모든 변환을 끌 수 있습니다.
              이 옵션의 기본 설정은 사이트별로 다르며, RSYNC_ICONV 환경 변수를 통해서도 영향을 받을 수 있습니다.

              로컬 iconv 라이브러리가 지원하는 문자셋 이름 목록을 보려면 "iconv --list"를 실행하십시오.

              --secluded-args (-s) 옵션을 지정하면 rsync는 명령줄에 지정된 파일 이름 중 원격 호스트로 전송되는 파일 이름을 번역합니다.
              --files-from 옵션도 참조하십시오.

              rsync는 필터 파일(포함/제외 파일 포함)의 이름을 변환하지 않는다는 점에 유의하십시오.
              전송의 양쪽에서 일치할 수 있는 규칙을 지정하는 것은 사용자에게 달려 있습니다.
              예를 들어, 양쪽에 파일 이름 차이가 있어 처리해야 하는 경우 추가 포함/제외 규칙을 지정할 수 있습니다.

              --iconv 옵션을 허용하는 rsync 데몬에 전달할 때, 데몬은 실제로 전달하는 원격 문자셋과 관계없이 "charset" 구성 매개변수에 지정된 문자셋을 사용합니다.
              따라서 데몬 전송의 경우 로컬 문자셋만 지정해도 됩니다 (예: --iconv=utf8).

       --ipv4, -4 또는 --ipv6, -6
              rsync에게 소켓을 생성하거나 ssh를 실행할 때 IPv4/IPv6를 선호하도록 지시합니다.
              이는 rsync가 직접 제어하는 소켓, 예를 들어 rsync 데몬에 직접 연결할 때 나가는 소켓, 그리고 ssh가 원격 셸로 사용된다는 것을 rsync가 추론할 수 있을 때 ssh에 -4 또는 -6 옵션을 전달하는 것에 영향을 미칩니다.
              다른 원격 셸의 경우 "--rsh SHELL -4" 옵션 (또는 해당 셸이 사용하는 IPv4/IPv6 힌트 옵션)을 직접 지정해야 합니다.

              이 옵션의 데몬 버전도 참조하십시오.

              rsync가 IPv6 지원 없이 컴파일된 경우, --ipv6 옵션은 효과가 없습니다.
              rsync --version 출력에 "no IPv6"가 포함되어 있으면 이러한 경우입니다.

       --checksum-seed=NUM
              체크섬 시드를 정수 NUM으로 설정합니다.
              이 4바이트 체크섬 시드는 각 블록 및 MD4 파일 체크섬 계산에 포함됩니다 (더 현대적인 MD5 파일 체크섬은 시드를 사용하지 않습니다).
              기본적으로 체크섬 시드는 서버에 의해 생성되며 현재 시간()으로 기본값이 지정됩니다.
              이 옵션은 특정 체크섬 시드를 설정하는 데 사용되며, 반복 가능한 블록 체크섬을 원하는 애플리케이션이나 사용자가 더 무작위적인 체크섬 시드를 원하는 경우에 유용합니다.
              NUM을 0으로 설정하면 rsync는 체크섬 시드에 대해 기본값인 time()을 사용합니다.

DAEMON OPTIONS
       rsync 데몬을 시작할 때 허용되는 옵션은 다음과 같습니다:

       --daemon
              이것은 rsync에게 데몬으로 실행하도록 지시합니다.
              실행 중인 데몬은 host::module 또는 rsync://host/module/ 구문을 사용하여 rsync 클라이언트로 접근할 수 있습니다.

              표준 입력이 소켓인 경우 rsync는 inetd를 통해 실행 중이라고 가정하고, 그렇지 않으면 현재 터미널에서 분리되어 백그라운드 데몬이 됩니다.
              데몬은 클라이언트가 연결할 때마다 구성 파일(rsyncd.conf)을 읽고 요청에 따라 응답합니다.

              자세한 내용은 rsyncd.conf(5) 맨페이지를 참조하십시오.

       --address=ADDRESS
              기본적으로 rsync는 --daemon 옵션으로 데몬으로 실행될 때 와일드카드 주소에 바인딩합니다.
              --address 옵션을 사용하면 특정 IP 주소(또는 호스트 이름)에 바인딩하도록 지정할 수 있습니다.
              이는 --config 옵션과 함께 가상 호스팅을 가능하게 합니다.

              rsyncd.conf 맨페이지의 address 전역 옵션과 --address 옵션의 클라이언트 버전도 참조하십시오.

       --bwlimit=RATE
              이 옵션은 데몬이 소켓을 통해 보내는 데이터의 최대 전송 속도를 지정할 수 있도록 합니다.
              클라이언트는 여전히 더 작은 --bwlimit 값을 지정할 수 있지만, 더 큰 값은 허용되지 않습니다.

              몇 가지 추가 세부 사항은 --bwlimit 옵션의 클라이언트 버전을 참조하십시오.

       --config=FILE
              이것은 기본값 대신 대체 구성 파일을 지정합니다.
              이는 --daemon이 지정된 경우에만 관련됩니다.
              데몬이 원격 셸 프로그램을 통해 실행되고 원격 사용자가 슈퍼유저가 아닌 경우를 제외하고 기본값은 /etc/rsyncd.conf입니다.
              이 경우 기본값은 현재 디렉토리(일반적으로 $HOME)의 rsyncd.conf입니다.

       --dparam=OVERRIDE, -M
              이 옵션은 데몬 모드에서 rsync를 시작할 때 데몬-구성 매개변수를 설정하는 데 사용될 수 있습니다.
              이는 첫 번째 모듈 정의 이전에 전역 설정 끝에 매개변수를 추가하는 것과 동일합니다.
              매개변수 이름은 원하는 경우 공백 없이 지정할 수 있습니다. 예를 들어:

                  rsync --daemon -M pidfile=/path/rsync.pid

       --no-detach
              데몬으로 실행할 때, 이 옵션은 rsync에게 자신을 분리하여 백그라운드 프로세스가 되지 않도록 지시합니다.
              이 옵션은 Cygwin에서 서비스로 실행할 때 필요하며, daemontools 또는 AIX의 System Resource Controller와 같은 프로그램에 의해 rsync가 감독될 때도 유용할 수 있습니다.
              --no-detach는 rsync가 디버거에서 실행될 때도 권장됩니다.
              이 옵션은 rsync가 inetd 또는 sshd에서 실행될 때 효과가 없습니다.

       --port=PORT
              이것은 데몬이 기본값 873 대신 수신할 대체 TCP 포트 번호를 지정합니다.

              --port 옵션의 클라이언트 버전과 rsyncd.conf 맨페이지의 port 전역 설정도 참조하십시오.

       --log-file=FILE
              이 옵션은 rsync 데몬에게 구성 파일의 "log file" 설정 대신 주어진 로그-파일 이름을 사용하도록 지시합니다.

              --log-file 옵션의 클라이언트 버전도 참조하십시오.

       --log-file-format=FORMAT
              이 옵션은 rsync 데몬에게 구성 파일의 "log format" 설정 대신 주어진 FORMAT 문자열을 사용하도록 지시합니다.
              또한 문자열이 비어 있지 않으면 "전송 로깅"을 활성화하고, 문자열이 비어 있으면 전송 로깅을 끕니다.

              --log-file-format 옵션의 클라이언트 버전도 참조하십시오.

       --sockopts
              이것은 rsyncd.conf 파일의 소켓 옵션 설정을 재정의하며, 구문은 동일합니다.

              --sockopts 옵션의 클라이언트 버전도 참조하십시오.

       --verbose, -v
              이 옵션은 데몬이 시작 단계에서 기록하는 정보의 양을 늘립니다.
              클라이언트가 연결되면 데몬의 상세도 수준은 클라이언트가 사용한 옵션과 모듈 구성 섹션의 "max verbosity" 설정에 의해 제어됩니다.

              --verbose 옵션의 클라이언트 버전도 참조하십시오.

       --ipv4, -4 또는 --ipv6, -6
              rsync 데몬이 연결을 수신하기 위해 사용하는 수신 소켓을 생성할 때 IPv4/IPv6를 선호하도록 지시합니다.
              이 옵션 중 하나는 Linux의 오래된 버전에서 커널의 IPv6 버그를 해결하기 위해 필요할 수 있습니다 (다른 아무것도 포트를 사용하고 있지 않은데 "address already in use" 오류가 발생하면 데몬을 시작할 때 --ipv6 또는 --ipv4를 지정해 보십시오).

              이 옵션의 클라이언트 버전도 참조하십시오.

              rsync가 IPv6 지원 없이 컴파일된 경우, --ipv6 옵션은 효과가 없습니다.
              rsync --version 출력에 "no IPv6"가 포함되어 있으면 이러한 경우입니다.

       --help, -h
              --daemon 다음에 지정되면 rsync 데몬을 시작하는 데 사용할 수 있는 옵션을 설명하는 짧은 도움말 페이지를 출력합니다.

FILTER RULES
       필터 규칙은 파일 처리 방식의 여러 측면을 사용자 정의로 제어할 수 있도록 합니다:

       o      보내는 측이 전송 계층 구조를 설명하는 파일 목록에 어떤 파일을 넣을지 제어합니다.

       o      삭제 시, 파일이 전송자의 파일 목록에 없을 때 받는 측이 어떤 파일을 삭제로부터 보호할지 제어합니다.

       o      xattrs를 복사할 때 어떤 확장 속성 이름을 건너뛸지 제어합니다.

       규칙은 옵션 인자를 통해 직접 지정되거나, 하나 이상의 파일에서 읽어올 수 있습니다.
       필터-규칙 파일은 복사되는 파일 계층 구조의 일부일 수 있으며, 트리의 다른 부분에 다른 방식으로 영향을 미칠 수 있습니다.

   SIMPLE INCLUDE/EXCLUDE RULES
       먼저 포함 및 제외 규칙이 전송되는 파일에 어떤 영향을 미치는지 기본적인 사항을 다루고, 삭제 부작용은 무시하겠습니다.
       필터 규칙은 주로 rsync가 "재귀적으로" 들어가는 디렉토리의 내용에 영향을 미치지만, 인자로 지정된 전송의 최상위 항목에도 영향을 미칠 수 있습니다.

       일치하지 않는 모든 파일/디렉토리의 기본값은 전송에 포함되는 것이며, 이는 파일/디렉토리를 보내는 측의 파일 목록에 넣습니다.
       제외 규칙을 사용하면 일치하는 하나 이상의 파일/디렉토리가 보내는 측의 파일 목록에서 제외됩니다.
       포함 규칙은 너무 많은 파일과 일치하는 제외 규칙의 영향을 제한하는 데 사용될 수 있습니다.

       규칙의 순서가 중요합니다. 첫 번째로 일치하는 규칙이 적용되기 때문입니다.
       따라서, 초기 규칙이 파일을 제외하면 그 뒤에 오는 포함 규칙은 아무런 효과도 가질 수 없습니다.
       이는 포함 재정의를 의도한 제외 규칙보다 앞서 어딘가에 배치해야 한다는 것을 의미합니다.

       디렉토리가 제외되면 해당 내용과 하위 내용도 모두 제외됩니다.
       보내는 측은 어떤 내용도 전혀 스캔하지 않으므로, 불필요한 큰 하위 트리를 건너뛸 때 많은 시간을 절약할 수 있습니다.

       또한 포함/제외 규칙은 보내는 측이 재귀하는 모든 파일 및 디렉토리에 적용된다는 것을 이해하는 것이 중요합니다.
       따라서 특정 깊은 파일을 포함하려면, 해당 파일로 가는 경로에서 반드시 거쳐야 할 디렉토리 중 어느 것도 제외되지 않았는지 확인해야 합니다.
       그렇지 않으면 파일이 포함될 것으로 발견되지 않을 것입니다.
       예를 들어, "a/path" 디렉토리가 전송 인자로 주어졌고 "a/path/down/deep/wanted.txt" 파일이 전송의 일부가 되도록 하려면, 보내는 측은 파일 트리를 스캔하면서 "a/path", "a/path/down", "a/path/down/deep" 디렉토리를 제외해서는 안 됩니다.

       규칙 작업을 할 때, rsync에게 무엇이 제외/포함되고 왜 그런지 알려달라고 요청하는 것이 도움이 될 수 있습니다.
       --debug=FILTER 또는 (파일을 가져올 때) -M--debug=FILTER를 지정하면 FILTER 디버그 정보의 수준 1이 켜지고, 파일이나 디렉토리가 포함되거나 제외될 때마다 어떤 규칙과 일치했는지 메시지가 출력됩니다.
       3.2.4부터는 필터 규칙에 후행 공백이 있는 경우에도 경고합니다. "foo " (후행 공백 포함) 제외는 "foo"라는 파일을 제외하지 않기 때문입니다.

       제외 및 포함 규칙은 파일 접미사 또는 파일 이름의 일부와 같은 것을 일치시킬 수 있는 와일드카드 PATTERN MATCHING RULES (셸 와일드카드와 유사)를 지정할 수 있습니다.

       규칙은 파일 이름 뒤에 후행 슬래시를 붙여 디렉토리에만 영향을 미치도록 제한할 수 있습니다.

   SIMPLE INCLUDE/EXCLUDE EXAMPLE
       보내는 측에 다음 파일 트리가 생성되었다고 가정합니다:

           mkdir x/
           touch x/file.txt
           mkdir x/y/
           touch x/y/file.txt
           touch x/y/zzz.txt
           mkdir x/z/
           touch x/z/file.txt

       그러면 다음 rsync 명령은 "x/y/file.txt" 파일과 해당 파일을 보관하는 데 필요한 디렉토리를 전송하여 원격 호스트에 "/tmp/x/y/file.txt" 경로가 존재하도록 합니다:

           rsync -ai -f'+ x/' -f'+ x/y/' -f'+ x/y/file.txt' -f'- *' x host:/tmp/

       참고: 이 복사는 -R 옵션을 사용하여도 달성할 수 있었습니다 (단, 삭제가 활성화된 경우 두 명령은 다르게 작동합니다):

           rsync -aiR x/y/file.txt host:/tmp/

       다음 명령은 "x" 디렉토리가 전송의 일부가 아니므로 (후행 슬래시 주의) 포함할 필요가 없습니다.
       이 명령을 실행하면 "y" 및 "z" 디렉토리가 제외되므로 "/tmp/x/file.txt"만 복사됩니다:

           rsync -ai -f'+ file.txt' -f'- *' x/ host:/tmp/x/

       이 명령은 "zzz.txt" 파일을 제외하고 "x"와 그 안에 포함된 모든 것을 복사합니다:

           rsync -ai -f'- zzz.txt' x host:/tmp/

   FILTER RULES WHEN DELETING
       삭제 옵션이 없으면 디렉토리별 규칙은 보내는 측에만 관련되므로, 병합 파일 자체를 제외해도 전송에 영향을 주지 않습니다.
       이를 쉽게 하기 위해 'e' 수정자가 이 제외를 자동으로 추가합니다. 다음 두 가지 동등한 명령에서 볼 수 있습니다:

           rsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest
           rsync -av --filter=':e .excl' host:src/dir /dest

       그러나 수신 측에서 삭제를 수행하고 일부 파일을 삭제에서 제외하고 싶다면, 수신 측이 어떤 파일을 제외해야 하는지 알아야 합니다.
       가장 쉬운 방법은 디렉토리별 병합 파일을 전송에 포함하고 --delete-after를 사용하는 것입니다.
       이는 삭제를 시도하기 전에 수신 측이 보내는 측과 동일한 모든 제외 규칙을 받도록 보장하기 때문입니다:

           rsync -avF --delete-after host:src/dir /dest

       그러나 병합 파일이 전송의 일부가 아닌 경우, 전역 제외 규칙을 지정하거나 (즉, 명령줄에 지정), 수신 측에서 자체 디렉토리별 병합 파일을 유지해야 합니다.
       첫 번째 예시는 다음과 같습니다 (원격 .rules 파일이 자신을 제외한다고 가정):

           rsync -av --filter=': .rules' --filter='. /my/extra.rules'
              --delete host:src/dir /dest

       위 예시에서 extra.rules 파일은 전송의 양쪽에 영향을 미칠 수 있지만, (보내는 측에서는) 디렉토리별 병합 규칙 이후에 지정되었으므로 .rules 파일에서 병합된 규칙보다 하위입니다.

       마지막 예시로, 원격 측은 전송에서 .rsync-filter 파일을 제외하고 있지만, 수신 측에서 무엇이 삭제될지 제어하기 위해 자체 .rsync-filter 파일을 사용하고 싶습니다.
       이를 위해 디렉토리별 병합 파일을 명시적으로 제외하고 (삭제되지 않도록), 로컬 파일에 다른 무엇이 삭제되지 않아야 하는지 제어하는 규칙을 추가해야 합니다.
       다음 명령 중 하나와 같이:

           rsync -av --filter=':e /.rsync-filter' --delete \
               host:src/dir /dest
           rsync -avFF --delete host:src/dir /dest

   FILTER RULES IN DEPTH
       Rsync는 이전 스타일 포함/제외 규칙과 새로운 스타일 필터 규칙을 지원합니다.
       이전 규칙은 --include 및 --exclude뿐만 아니라 --include-from 및 --exclude-from을 사용하여 지정됩니다.
       이들은 동작이 제한적이지만 "-" 또는 "+" 접두사가 필요하지 않습니다.
       이전 스타일 제외 규칙은 "- name" 필터 규칙(수정자 없음)으로 변환되고, 이전 스타일 포함 규칙은 "+ name" 필터 규칙(수정자 없음)으로 변환됩니다.

       Rsync는 명령줄에 지정되었거나 파일에서 읽어온 필터 규칙의 순서 있는 목록을 빌드합니다.
       새로운 스타일 필터 규칙은 다음 구문을 가집니다:

           RULE [PATTERN_OR_FILENAME]
           RULE,MODIFIERS [PATTERN_OR_FILENAME]

       아래 설명된 짧은 또는 긴 RULE 이름을 선택하여 사용할 수 있습니다. 짧은 이름의 규칙을 사용하는 경우 RULE과 MODIFIERS를 구분하는 ','는 선택 사항입니다.
       그 뒤에 오는 PATTERN 또는 FILENAME (존재하는 경우)은 단일 공백 또는 밑줄(_) 뒤에 와야 합니다.
       추가 공백 및/또는 밑줄은 패턴 이름의 일부로 간주됩니다. 사용 가능한 규칙 접두사는 다음과 같습니다:

       exclude, '-'
              숨김(hide)과 보호(protect)를 모두 수행하는 제외 패턴을 지정합니다 (기본값).

       include, '+'
              표시(show)와 위험(risk)을 모두 수행하는 포함 패턴을 지정합니다 (기본값).

       merge, '.'
              더 많은 규칙을 읽을 클라이언트 측의 병합 파일(merge-file)을 지정합니다.

       dir-merge, ':'
              디렉토리별 병합 파일(per-directory merge-file)을 지정합니다.
              이러한 종류의 필터 규칙을 사용하려면 보내는 측의 필터 확인을 신뢰해야 하므로, --trust-sender 옵션에 언급된 부작용이 있습니다.

       hide, 'H'
              전송에서 파일을 숨기기 위한 패턴을 지정합니다. 보내는 측 전용 제외와 동일하므로 -f'H foo'는 -f'-s foo'로도 지정할 수 있습니다.

       show, 'S'
              패턴과 일치하는 파일은 숨겨지지 않습니다. 보내는 측 전용 포함과 동일하므로 -f'S foo'는 -f'+s foo'로도 지정할 수 있습니다.

       protect, 'P'
              삭제로부터 파일을 보호하기 위한 패턴을 지정합니다. 받는 측 전용 제외와 동일하므로 -f'P foo'는 -f'-r foo'로도 지정할 수 있습니다.

       risk, 'R'
              패턴과 일치하는 파일은 보호되지 않습니다. 받는 측 전용 포함과 동일하므로 -f'R foo'는 -f'+r foo'로도 지정할 수 있습니다.

       clear, '!'
              현재 포함/제외 목록을 지웁니다 (인자를 받지 않습니다).

       규칙이 파일에서 읽어올 때 (merge 또는 dir-merge 사용), 빈 줄은 무시되며, '#'으로 시작하는 전체 줄 주석도 무시됩니다 (해시 문자를 포함하는 파일 이름 규칙은 영향을 받지 않습니다).

       또한 --filter, --include 및 --exclude 옵션은 각각 하나의 규칙/패턴만 받습니다.
       여러 개를 추가하려면 명령줄에서 옵션을 반복하거나, --filter 옵션의 병합 파일 구문을 사용하거나, --include-from / --exclude-from 옵션을 사용하십시오.

   PATTERN MATCHING RULES
       위에 언급된 대부분의 규칙은 규칙이 무엇과 일치해야 하는지 지정하는 인자를 받습니다.
       rsync가 디렉토리 계층을 재귀적으로 탐색하는 경우, 각 패턴은 rsync가 보낼 파일 이름을 찾으면서 하위 경로의 모든 디렉토리 이름과 일치하는지 확인된다는 점을 명심하십시오.

       패턴 인자에 대한 일치 규칙은 여러 형태를 가집니다:

       o      패턴에 / (후행 슬래시 제외) 또는 "**" (슬래시와 일치할 수 있음)가 포함된 경우, 패턴은 전송 내의 모든 선행 디렉토리를 포함한 전체 경로 이름과 일치합니다.
              패턴에 (후행이 아닌) / 또는 "**"가 포함되어 있지 않으면, 파일 이름 또는 경로 이름의 마지막 구성 요소와만 일치합니다.
              예를 들어, foo는 최종 경로 구성 요소가 "foo"여야 함을 의미하며, foo/bar는 경로의 마지막 두 요소와 일치합니다 (두 요소 모두 전송 내에 있는 한).

       o      /로 끝나는 패턴은 디렉토리만 일치시키고, 일반 파일, 심볼릭 링크 또는 장치는 일치시키지 않습니다.

       o      /로 시작하는 패턴은 전송 경로의 끝이 아닌 시작에 고정됩니다.
              예를 들어, /foo/** 또는 /foo/bar/**는 경로의 선행 요소만 일치시킵니다.
              규칙이 디렉토리별 필터 파일에서 읽힌 경우, 일치하는 전송 경로는 전송의 최상단이 아닌 필터 파일 수준에서 시작됩니다.
              전송의 루트에서 일치하는 패턴을 지정하는 방법에 대한 전체 논의는 ANCHORING INCLUDE/EXCLUDE PATTERNS 섹션을 참조하십시오.

       Rsync는 패턴에 다음 세 가지 와일드카드 문자 중 하나가 포함되어 있는지 확인하여 간단한 문자열 일치와 와일드카드 일치 중 하나를 선택합니다: '*', '?', '[' :

       o      '?'는 슬래시(/)를 제외한 모든 단일 문자와 일치합니다.

       o      '*'는 슬래시가 아닌 0개 이상의 문자와 일치합니다.

       o      '**'는 슬래시를 포함하여 0개 이상의 문자와 일치합니다.

       o      '['는 문자 클래스(예: [a-z] 또는 [[:alpha:]])를 도입하며, 한 문자와 일치해야 합니다.

       o      패턴의 후행 ***는 디렉토리와 그 모든 내용을 단일 규칙으로 일치시킬 수 있는 약식입니다.
              예를 들어, "dir_name/***"를 지정하면 "dir_name" 디렉토리(마치 "dir_name/"이 지정된 것처럼)와 디렉토리 내의 모든 내용(마치 "dir_name/**"이 지정된 것처럼)을 모두 일치시킵니다.

       o      역슬래시는 와일드카드 문자를 이스케이프하는 데 사용할 수 있지만, 일치 패턴에 와일드카드 문자가 하나 이상 있는 경우에만 이스케이프 문자로 해석됩니다.
              예를 들어, 패턴 "foo\bar"는 단일 역슬래시를 리터럴로 일치시키지만, 패턴 "foo\bar*"는 "\b"가 단순히 "b"가 되는 것을 피하기 위해 "foo\\bar*"로 변경되어야 합니다.

       다음은 제외/포함 일치 예시입니다:

       o      옵션 -f'- *.o'는 .o로 끝나는 모든 파일 이름을 제외합니다.

       o      옵션 -f'- /foo'는 전송-루트 디렉토리의 foo라는 파일(또는 디렉토리)을 제외합니다.

       o      옵션 -f'- foo/'는 foo라는 모든 디렉토리를 제외합니다.

       o      옵션 -f'- foo/*/bar'는 foo라는 디렉토리 아래 두 단계에 있는 bar라는 파일/디렉토리를 제외합니다 (foo가 전송에 포함된 경우).

       o      옵션 -f'- /foo/**/bar'는 최상위 디렉토리 foo 아래 두 단계 이상에 있는 bar라는 파일/디렉토리를 제외합니다 (단, /foo/bar는 이것에 의해 제외되지 않습니다).

       o      옵션 -f'+ */' -f'+ *.c' -f'- *'는 모든 디렉토리와 .c 소스 파일만 포함하고 다른 것은 포함하지 않습니다.

       o      옵션 -f'+ foo/' -f'+ foo/bar.c' -f'- *'는 foo 디렉토리와 foo/bar.c만 포함합니다 (foo 디렉토리는 명시적으로 포함되어야 합니다. 그렇지 않으면 "- *"에 의해 제외됩니다).

   FILTER RULE MODIFIERS
       다음 수정자는 포함(+) 또는 제외(-) 규칙 뒤에 허용됩니다:

       o      /는 포함/제외 규칙이 현재 항목의 절대 경로 이름과 일치해야 함을 지정합니다.
              예를 들어, -f'-/ /etc/passwd'는 전송이 "/etc" 디렉토리에서 파일을 보낼 때마다 passwd 파일을 제외하며, "-/ subdir/foo"는 "foo"가 "subdir"라는 디렉토리에 있을 때 항상 "foo"를 제외합니다.
              "foo"가 현재 전송의 루트에 있더라도 마찬가지입니다.

       o      !는 패턴이 일치하지 않을 때 포함/제외가 적용되어야 함을 지정합니다. 예를 들어, -f'-! */'는 모든 비디렉토리를 제외합니다.

       o      C는 모든 전역 CVS-제외 규칙이 "-C" 대신 제외로 삽입되어야 함을 나타내는 데 사용됩니다. 인자가 뒤따르지 않습니다.

       o      s는 규칙이 보내는 측에 적용됨을 나타내는 데 사용됩니다. 규칙이 보내는 측에 영향을 미칠 때, 이는 보내는 측의 파일 목록에 어떤 파일이 포함될지에 영향을 미칩니다.
              기본값은 규칙이 양쪽에 영향을 미치는 것이지만, --delete-excluded가 지정된 경우 기본 규칙은 보내는 측에만 적용됩니다.
              보내는 측의 포함/제외를 지정하는 다른 방법인 hide (H) 및 show (S) 규칙도 참조하십시오.

       o      r은 규칙이 수신 측에 적용됨을 나타내는 데 사용됩니다.
              규칙이 수신 측에 영향을 미칠 때, 이는 파일이 삭제되는 것을 방지합니다.
              자세한 내용은 s 수정자를 참조하십시오.
              수신 측의 포함/제외를 지정하는 다른 방법인 protect (P) 및 risk (R) 규칙도 참조하십시오.

       o      p는 규칙이 소멸성(perishable)임을 나타냅니다. 즉, 삭제되는 디렉토리에서는 무시됩니다.
              예를 들어, --cvs-exclude (-C) 옵션의 "CVS" 및 "*.o"와 같은 것을 제외하는 기본 규칙은 소멸성으로 표시되며, 소스에서 제거된 디렉토리가 대상에서 삭제되는 것을 방지하지 않습니다.

       o      x는 규칙이 xattr 복사/삭제 작업에서 xattr 이름에 영향을 미치고 (따라서 파일/디렉토리 이름과 일치할 때는 무시됩니다) 있음을 나타냅니다.
              xattr-일치 규칙이 지정되지 않으면 기본 xattr 필터링 규칙이 사용됩니다 (--xattrs 옵션 참조).

   MERGE-FILE FILTER RULES
       병합(.) 또는 디렉토리 병합(:) 필터 규칙을 지정하여 전체 파일을 필터 규칙에 병합할 수 있습니다 (위의 FILTER RULES 섹션에서 소개됨).

       병합 파일에는 단일-인스턴스('.')와 디렉토리별(':') 두 가지 종류가 있습니다.
       단일-인스턴스 병합 파일은 한 번 읽히며, 그 규칙은 "." 규칙 위치의 필터 목록에 통합됩니다.
       디렉토리별 병합 파일의 경우, rsync는 탐색하는 모든 디렉토리에서 명명된 파일을 스캔하고, 파일이 존재할 때 그 내용을 현재 상속된 규칙 목록에 병합합니다.
       이러한 디렉토리별 규칙 파일은 보내는 측에서 생성되어야 합니다.
       보내는 측이 전송할 수 있는 파일을 스캔하기 때문입니다.
       또한, 삭제되지 않아야 할 파일에 영향을 미치려면 이러한 규칙 파일을 수신 측으로 전송해야 할 수도 있습니다 (아래 PER-DIRECTORY RULES AND DELETE 참조).

       몇 가지 예시:

           merge /etc/rsync/default.rules
           . /etc/rsync/default.rules
           dir-merge .per-dir-filter
           dir-merge,n- .non-inherited-per-dir-excludes
           :n- .non-inherited-per-dir-excludes

       다음 수정자는 병합 또는 디렉토리 병합 규칙 뒤에 허용됩니다:

       o      -는 파일이 오직 제외 패턴으로만 구성되어야 하며, 인-파일 주석을 제외하고는 다른 규칙 파싱은 없어야 함을 지정합니다.

       o      +는 파일이 오직 포함 패턴으로만 구성되어야 하며, 인-파일 주석을 제외하고는 다른 규칙 파싱은 없어야 함을 지정합니다.

       o      C는 파일이 CVS 호환 방식으로 읽혀야 함을 지정하는 방법입니다.
              이것은 'n', 'w', '-'를 켜지만, 목록 지우기 토큰(!)도 지정할 수 있도록 합니다.
              파일 이름이 제공되지 않으면 ".cvsignore"가 가정됩니다.

       o      e는 병합 파일 이름을 전송에서 제외합니다. 예: "dir-merge,e .rules"는 "dir-merge .rules"와 "- .rules"와 같습니다.

       o      n은 규칙이 하위 디렉토리에 상속되지 않음을 지정합니다.

       o      w는 규칙이 일반적인 줄 분할 대신 공백으로 단어 분할됨을 지정합니다.
              이것은 또한 주석을 끕니다.
              참고: 접두사와 규칙을 분리하는 공백은 특별하게 처리되므로, "- foo + bar"는 두 개의 규칙으로 파싱됩니다 (접두사 파싱도 비활성화되지 않았다고 가정할 때).

       o      "+" 또는 "-" 규칙 (위 참조)에 대한 수정자 중 하나를 지정할 수도 있습니다.
              이는 파일에서 읽어온 규칙이 해당 수정자가 설정된 것으로 기본값을 갖도록 하기 위함입니다 (유용하지 않을 ! 수정자는 제외).
              예를 들어, "merge,-/ .excl"은 .excl의 내용을 절대 경로 제외로 처리하고, "dir-merge,s .filt" 및 ":sC"는 각각 디렉토리별 규칙을 보내는 측에만 적용되도록 합니다.
              병합 규칙이 영향을 미칠 측면을 지정하는 경우 (s 또는 r 수정자 또는 둘 다를 통해), 파일의 규칙은 측면을 지정해서는 안 됩니다 (수정자 또는 hide와 같은 규칙 접두사를 통해).

       디렉토리별 규칙은 'n' 수정자가 사용되지 않는 한 병합 파일이 발견된 디렉토리의 모든 하위 디렉토리에서 상속됩니다.
       각 하위 디렉토리의 규칙은 부모로부터 상속된 디렉토리별 규칙 앞에 추가되어, 최신 규칙이 상속된 규칙보다 높은 우선순위를 가집니다.
       전체 dir-merge 규칙 집합은 병합 파일이 지정된 위치에 함께 그룹화되므로, 전역 규칙 목록에서 이전에 지정된 규칙을 통해 dir-merge 규칙을 재정의할 수 있습니다.
       디렉토리별 파일에서 목록 지우기 규칙("!")이 읽히면 현재 병합 파일에 대한 상속된 규칙만 지워집니다.

       dir-merge 파일의 단일 규칙이 상속되는 것을 막는 또 다른 방법은 선행 슬래시로 고정하는 것입니다.
       디렉토리별 병합 파일의 고정된 규칙은 병합 파일의 디렉토리에 상대적이므로, 패턴 "/foo"는 dir-merge 필터 파일이 발견된 디렉토리의 "foo" 파일만 일치시킬 것입니다.

       다음은 --filter=". file"을 통해 지정할 수 있는 예시 필터 파일입니다:

           merge /home/user/.global-filter
           - *.gz
           dir-merge .rules
           + *.[ch]
           - *.o
           - foo*

       이것은 목록 시작 부분에 /home/user/.global-filter 파일의 내용을 병합하고, ".rules" 파일 이름을 디렉토리별 필터 파일로 전환합니다.
       디렉토리 스캔 시작 이전에 읽어온 모든 규칙은 전역 고정 규칙을 따릅니다 (즉, 선행 슬래시는 전송의 루트와 일치합니다).

       디렉토리별 병합 파일이 첫 번째 전송 디렉토리의 상위 디렉토리 경로로 지정된 경우, rsync는 해당 시작 지점에서 전송 디렉토리까지의 모든 상위 디렉토리에서 지정된 디렉토리별 파일을 스캔합니다.
       예를 들어, 다음은 일반적인 필터입니다 (-F 참조):

           --filter=': /.rsync-filter'

       그 규칙은 rsync에게 정상적인 디렉토리 스캔이 시작되기 전에 루트부터 전송의 상위 디렉토리까지의 모든 디렉토리에서 .rsync-filter 파일을 스캔하도록 지시합니다.
       (참고: rsync 데몬의 경우, 루트는 항상 모듈의 "path"와 동일합니다.)

       디렉토리별 파일에 대한 사전 스캔의 몇 가지 예시:

           rsync -avF /src/path/ /dest/dir
           rsync -av --filter=': ../../.rsync-filter' /src/path/ /dest/dir
           rsync -av --filter=': .rsync-filter' /src/path/ /dest/dir

       위의 처음 두 명령은 정상 스캔이 "/src/path" 및 그 하위 디렉토리에서 파일을 찾기 시작하기 전에 "/" 및 "/src"에서 ".rsync-filter"를 찾을 것입니다.
       마지막 명령은 상위 디렉토리 스캔을 피하고 전송의 일부인 각 디렉토리에서만 ".rsync-filter" 파일을 찾습니다.

       패턴에 ".cvsignore"의 내용을 포함하려면, ":C" 규칙을 사용해야 합니다.
       이것은 .cvsignore 파일의 dir-merge를 생성하지만, CVS 호환 방식으로 파싱됩니다.
       이것을 사용하여 --cvs-exclude (-C) 옵션의 디렉토리별 .cvsignore 파일 포함 위치를 필터 규칙 내에서 원하는 위치에 배치하여 제어할 수 있습니다.
       그렇지 않으면 rsync는 .cvsignore 파일에 대한 dir-merge 규칙을 다른 모든 규칙의 끝에 추가합니다 (명령줄 규칙보다 낮은 우선순위를 부여합니다).
       예를 들어:

           cat <<EOT | rsync -avC --filter='. -' a/ b
           + foo.o
           :C
           - *.old
           EOT
           rsync -avC --include=foo.o -f :C --exclude='*.old' a/ b

       위의 두 rsync 명령은 동일합니다. 각 명령은 모든 디렉토리별 .cvsignore 규칙을 목록의 끝이 아닌 중간에 병합합니다.
       이를 통해 해당 디렉토리별 규칙이 :C 이후의 규칙을 재정의할 수 있게 되며, 모든 규칙에 종속되지 않습니다.
       다른 CVS 제외 규칙(즉, 기본 제외 목록, $HOME/.cvsignore의 내용, $CVSIGNORE 값)에 영향을 미치려면 -C 명령줄 옵션을 생략하고 대신 필터 규칙에 "-C" 규칙을 삽입해야 합니다. 예를 들어 "--filter=-C"와 같이요.

   LIST-CLEARING FILTER RULE
       "!" 필터 규칙을 사용하여 현재 포함/제외 목록을 지울 수 있습니다 (위 FILTER RULES 섹션에서 소개됨).
       "현재" 목록은 전역 규칙 목록(필터 옵션을 파싱하는 동안 규칙이 발견된 경우) 또는 디렉토리별 규칙 집합(자체 하위 목록으로 상속되므로 하위 디렉토리에서 이를 사용하여 부모의 규칙을 지울 수 있음)입니다.

   ANCHORING INCLUDE/EXCLUDE PATTERNS
       앞서 언급했듯이, 전역 포함/제외 패턴은 "전송의 루트"에 고정됩니다 (디렉토리별 패턴은 병합 파일의 디렉토리에 고정됩니다).
       전송을 보내는 측에서 받는 측으로 전송되는 이름의 서브트리라고 생각한다면, 전송 루트는 트리가 대상 디렉토리에서 복제되기 시작하는 곳입니다.
       이 루트는 슬래시로 시작하는 패턴이 어디에서 일치하는지 지배합니다.

       일치가 전송 루트에 상대적이기 때문에, 소스 경로의 후행 슬래시를 변경하거나 --relative 옵션 사용을 변경하면 일치에 사용해야 하는 경로에 영향을 미칩니다 (파일 트리의 얼마나 많은 부분이 대상 호스트에 복제되는지 변경하는 것 외에도).
       다음 예시는 이를 보여줍니다.

       두 개의 소스 파일, 하나는 "/home/me/foo/bar"의 절대 경로를 가지고 있고 다른 하나는 "/home/you/bar/baz"의 경로를 가지고 있다고 가정해 봅시다.
       2-소스 전송에 대한 다양한 명령 선택 사항은 다음과 같이 다릅니다:

           예시 명령: rsync -a /home/me /home/you /dest
           +/- 패턴: /me/foo/bar
           +/- 패턴: /you/bar/baz
           대상 파일: /dest/me/foo/bar
           대상 파일: /dest/you/bar/baz

           예시 명령: rsync -a /home/me/ /home/you/ /dest
           +/- 패턴: /foo/bar               ("me"가 누락됨에 주의)
           +/- 패턴: /bar/baz               ("you"가 누락됨에 주의)
           대상 파일: /dest/foo/bar
           대상 파일: /dest/bar/baz

           예시 명령: rsync -a --relative /home/me/ /home/you /dest
           +/- 패턴: /home/me/foo/bar       (전체 경로 주의)
           +/- 패턴: /home/you/bar/baz      (동일)
           대상 파일: /dest/home/me/foo/bar
           대상 파일: /dest/home/you/bar/baz

           예시 명령: cd /home; rsync -a --relative me/foo you/ /dest
           +/- 패턴: /me/foo/bar      (지정된 경로에서 시작)
           +/- 패턴: /you/bar/baz     (동일)
           대상 파일: /dest/me/foo/bar
           대상 파일: /dest/you/bar/baz

       필터링해야 할 이름을 확인하는 가장 쉬운 방법은 --verbose를 사용하여 출력되는 이름을 보고 이름 앞에 /를 붙이는 것입니다 (--dry-run 옵션을 사용하면 아직 파일을 복사할 준비가 되지 않은 경우에 유용합니다).

   PER-DIRECTORY RULES AND DELETE
       삭제 옵션이 없으면 디렉토리별 규칙은 보내는 측에만 관련되므로, 병합 파일 자체를 제외해도 전송에 영향을 주지 않습니다.
       이를 쉽게 하기 위해 'e' 수정자가 이 제외를 자동으로 추가합니다. 다음 두 가지 동등한 명령에서 볼 수 있습니다:

           rsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest
           rsync -av --filter=':e .excl' host:src/dir /dest

       그러나 수신 측에서 삭제를 수행하고 일부 파일을 삭제에서 제외하고 싶다면, 수신 측이 어떤 파일을 제외해야 하는지 알아야 합니다.
       가장 쉬운 방법은 디렉토리별 병합 파일을 전송에 포함하고 --delete-after를 사용하는 것입니다.
       이는 삭제를 시도하기 전에 수신 측이 보내는 측과 동일한 모든 제외 규칙을 받도록 보장하기 때문입니다:

           rsync -avF --delete-after host:src/dir /dest

       그러나 병합 파일이 전송의 일부가 아닌 경우, 전역 제외 규칙을 지정하거나 (즉, 명령줄에 지정), 수신 측에서 자체 디렉토리별 병합 파일을 유지해야 합니다.
       첫 번째 예시는 다음과 같습니다 (원격 .rules 파일이 자신을 제외한다고 가정):

           rsync -av --filter=': .rules' --filter='. /my/extra.rules'
              --delete host:src/dir /dest

       위 예시에서 extra.rules 파일은 전송의 양쪽에 영향을 미칠 수 있지만, (보내는 측에서는) 디렉토리별 병합 규칙 이후에 지정되었으므로 .rules 파일에서 병합된 규칙보다 하위입니다.

       마지막 예시로, 원격 측은 전송에서 .rsync-filter 파일을 제외하고 있지만, 수신 측에서 무엇이 삭제될지 제어하기 위해 자체 .rsync-filter 파일을 사용하고 싶습니다.
       이를 위해 디렉토리별 병합 파일을 명시적으로 제외하고 (삭제되지 않도록), 로컬 파일에 다른 무엇이 삭제되지 않아야 하는지 제어하는 규칙을 추가해야 합니다.
       다음 명령 중 하나와 같이:

           rsync -av --filter=':e /.rsync-filter' --delete \
               host:src/dir /dest
           rsync -avFF --delete host:src/dir /dest

TRANSFER RULES
       보내는 측과 (삭제 시) 받는 측에서 파일 목록을 생성하는 재귀적 파일 스캔에 영향을 미치는 FILTER RULES 외에도 전송 규칙이 있습니다.
       이러한 규칙은 제외 필터 규칙의 부작용 없이 생성기가 전송해야 한다고 결정하는 파일에 영향을 미칩니다.
       전송 규칙은 파일에만 영향을 미치고 디렉토리에는 영향을 미치지 않습니다.

       전송 규칙은 보내는 측 (및 받는 측)의 파일 목록에 포함되는 항목에 영향을 미치지 않으므로, 받는 측에서 삭제되는 파일에 어떤 영향도 미칠 수 없습니다.
       예를 들어, "foo" 파일이 보내는 측 목록에 있지만 크기 때문에 전송 규칙에 의해 생략되는 경우, 받는 측은 파일을 요청하지 않습니다.
       그러나 파일 목록에 파일이 존재한다는 것은 삭제 패스가 받는 측에서 "foo"라는 이름의 일치하는 파일을 제거하지 않을 것임을 의미합니다.
       반면에, 서버 측에서 "foo" 파일을 제외(숨김)하면 파일이 서버의 파일 목록에서 제외되고, 받는 측 제외(보호)가 없으면 삭제가 요청될 경우 받는 측은 "foo"라는 이름의 일치하는 파일을 제거할 것입니다.

       파일이 여전히 보내는 측의 파일 목록에 있다는 점을 감안할 때, --prune-empty-dirs 옵션은 전송 규칙이 생략한 파일만 포함하더라도 디렉토리를 비어 있다고 판단하지 않을 것입니다.

       마찬가지로, 전송 규칙은 수신 측에서 삭제되는 파일에 추가적인 영향을 미치지 않으므로, 전송에 대한 최대 파일 크기를 설정한다고 해서 큰 파일이 삭제되는 것을 막지는 못합니다.

       전송 규칙의 예시로는 기본 "빠른 검사" 알고리즘(크기 및 수정 시간 비교), --update 옵션, --max-size 옵션, --ignore-non-existing 옵션 및 기타 몇 가지가 있습니다.

BATCH MODE
       배치 모드는 동일한 업데이트 집합을 여러 동일한 시스템에 적용하는 데 사용할 수 있습니다.
       소스 트리가 여러 호스트에 복제되어 있다고 가정해 봅시다. 이제 이 소스 트리에 변경 사항이 생겼고, 이 변경 사항을 다른 호스트에 전파해야 한다고 가정해 봅시다.
       배치 모드를 사용하여 이를 수행하려면, write-batch 옵션으로 rsync를 실행하여 소스 트리에 대한 변경 사항을 대상 트리 중 하나에 적용합니다.
       write-batch 옵션은 rsync 클라이언트가 이 작업을 다른 동일한 대상 트리에 대해 반복하는 데 필요한 모든 정보를 "배치 파일"에 저장하도록 합니다.

       배치 파일을 한 번 생성하면 여러 대상 트리를 업데이트할 때 파일 상태, 체크섬 및 데이터 블록 생성을 한 번 이상 수행할 필요가 없습니다.
       멀티캐스트 전송 프로토콜을 사용하여 동일한 데이터를 각 호스트에 개별적으로 보내는 대신 배치 업데이트 파일을 여러 호스트에 동시에 병렬로 전송할 수 있습니다.

       기록된 변경 사항을 다른 대상 트리에 적용하려면, read-batch 옵션으로 rsync를 실행하고, 동일한 배치 파일 이름과 대상 트리를 지정하십시오.
       Rsync는 배치 파일에 저장된 정보를 사용하여 대상 트리를 업데이트합니다.

       편의를 위해, write-batch 옵션이 사용될 때 스크립트 파일도 생성됩니다. 이 스크립트 파일은 배치 파일과 동일한 이름에 ".sh"가 추가됩니다.
       이 스크립트 파일에는 연관된 배치 파일을 사용하여 대상 트리를 업데이트하는 데 적합한 명령줄이 포함되어 있습니다.
       Bourne (또는 Bourne과 유사한) 셸을 사용하여 실행할 수 있으며, 선택적으로 대체 대상 트리 경로 이름을 전달할 수 있습니다.
       이 경우 원래 대상 경로 대신 해당 경로가 사용됩니다.
       이는 현재 호스트의 대상 트리 경로가 배치 파일을 생성하는 데 사용된 경로와 다른 경우에 유용합니다.

       예:

           $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
           $ scp foo* remote:
           $ ssh remote ./foo.sh /bdest/dir/

           $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
           $ ssh remote rsync --read-batch=- -a /bdest/dir/ <foo

       이 예시에서 rsync는 /source/dir/에서 /adest/dir/를 업데이트하는 데 사용되며, 이 작업을 반복하는 정보는 "foo"와 "foo.sh"에 저장됩니다.
       호스트 "remote"는 배치된 데이터가 디렉토리 /bdest/dir로 이동하면서 업데이트됩니다.
       두 예시의 차이점은 배치를 처리하는 방식에 있어 사용 가능한 유연성을 보여줍니다:

       o      첫 번째 예시는 초기 복사가 로컬일 필요가 없음을 보여줍니다. 원하는 대로 원격 셸 구문 또는 rsync 데몬 구문을 사용하여 원격 호스트로/로부터 데이터를 푸시하거나 가져올 수 있습니다.

       o      첫 번째 예시는 생성된 "foo.sh" 파일을 사용하여 원격 호스트에서 read-batch 명령을 실행할 때 올바른 rsync 옵션을 얻습니다.

       o      두 번째 예시는 표준 입력을 통해 배치 데이터를 읽으므로 배치 파일을 먼저 원격 머신으로 복사할 필요가 없습니다.
              이 예시는 수정된 --read-batch 옵션을 사용해야 했기 때문에 foo.sh 스크립트를 피하지만, 원한다면 스크립트 파일을 편집할 수 있습니다 (--exclude-from=- 옵션과 같이 다른 옵션이 표준 입력을 사용하려고 하지 않는지 확인하십시오).

       주의사항:

       read-batch 옵션은 업데이트하는 대상 트리가 배치 업데이트 파일셋을 생성하는 데 사용된 대상 트리와 동일하다고 예상합니다.
       대상 트리 간의 차이가 발견되면 업데이트는 경고와 함께 폐기될 수 있거나 (파일이 이미 최신 상태인 것처럼 보이면), 파일-업데이트가 시도된 후 파일이 확인에 실패하면 오류와 함께 업데이트가 폐기될 수 있습니다.
       이는 명령이 중단된 경우 read-batch 작업을 다시 실행해도 안전해야 함을 의미합니다.
       파일의 크기 및 날짜와 관계없이 배치 업데이트를 항상 시도하도록 강제하려면 -I 옵션(배치를 읽을 때)을 사용하십시오.
       오류가 발생하면 대상 트리는 부분적으로 업데이트된 상태가 될 것입니다.
       이 경우 rsync는 일반(비배치) 작동 모드에서 대상 트리를 수정하는 데 사용할 수 있습니다.

       모든 대상에서 사용되는 rsync 버전은 배치 파일을 생성하는 데 사용된 버전보다 최신이어야 합니다.
       배치 파일의 프로토콜 버전이 배치-읽기 rsync가 처리하기에는 너무 새로운 경우 rsync는 오류와 함께 종료됩니다.
       이전 rsync가 이해할 수 있는 배치 파일을 생성하는 방법은 --protocol 옵션도 참조하십시오.
       (배치 파일은 버전 2.6.3에서 형식이 변경되었으므로, 그보다 오래된 버전과 새로운 버전을 혼합하면 작동하지 않습니다.)

       배치 파일을 읽을 때 rsync는 배치 파일의 데이터와 일치하도록 특정 옵션의 값을 강제합니다.
       배치-쓰기 명령과 동일하게 설정하지 않은 경우에 그렇습니다.
       다른 옵션은 변경할 수 있습니다 (그리고 변경해야 합니다).
       예를 들어, --write-batch는 --read-batch로 변경되고, --files-from은 삭제되며, --filter / --include / --exclude 옵션은 --delete 옵션 중 하나가 지정되지 않는 한 필요하지 않습니다.

       BATCH.sh 파일을 생성하는 코드는 모든 필터/포함/제외 옵션을 셸 스크립트 파일에 "여기 문서"로 추가되는 단일 목록으로 변환합니다.
       고급 사용자는 이를 사용하여 --delete에 의해 삭제되는 내용을 변경하고 싶을 때 제외 목록을 수정할 수 있습니다.
       일반 사용자는 이 세부 사항을 무시하고 셸 스크립트를 배치된 데이터에 대한 적절한 --read-batch 명령을 실행하는 쉬운 방법으로 사용할 수 있습니다.

SYMBOLIC LINKS
       rsync가 소스 디렉토리에서 심볼릭 링크를 발견할 때 세 가지 기본적인 동작이 가능합니다.

       기본적으로 심볼릭 링크는 전혀 전송되지 않습니다. 존재하는 모든 심볼릭 링크에 대해 "비정규 파일 건너뛰기" 메시지가 발생합니다.

       --links가 지정되면 심볼릭 링크가 전송에 추가되고 (시끄럽게 무시하는 대신), 기본 처리는 대상에서 동일한 대상을 가리키도록 다시 생성하는 것입니다.
       --archive는 --links를 암시합니다.

       --copy-links가 지정되면 심볼릭 링크는 심볼릭 링크 자체가 아닌 참조 대상을 복사하여 "축소"됩니다.

       Rsync는 또한 "안전한" 심볼릭 링크와 "안전하지 않은" 심볼릭 링크를 구별할 수 있습니다.
       이것이 사용될 수 있는 예시는 복사되는 rsync 모듈이 사이트의 공개 섹션에 /etc/passwd에 대한 심볼릭 링크를 포함하지 않도록 하려는 웹 사이트 미러입니다.
       --copy-unsafe-links를 사용하면 모든 링크가 대상에서 가리키는 파일로 복사됩니다.
       --safe-links를 사용하면 안전하지 않은 링크가 수신자에 의해 생략됩니다.
       ( --safe-links가 효과를 가지려면 --links를 지정하거나 암시해야 한다는 점에 유의하십시오.)

       심볼릭 링크는 절대 심볼릭 링크( '/'로 시작), 비어 있거나, 전송의 최상단에서 벗어날 만큼 충분한 ".." 구성 요소를 포함하는 경우 안전하지 않은 것으로 간주됩니다.

       다음은 심볼릭 링크 옵션이 어떻게 해석되는지에 대한 요약입니다.
       목록은 우선순위 순서이므로, 옵션 조합이 언급되지 않았다면, 옵션의 완전한 하위 집합인 첫 번째 줄을 사용하십시오:

       --copy-links
              모든 심볼릭 링크를 일반 파일 및 디렉토리로 전환합니다 (다른 옵션이 영향을 미칠 심볼릭 링크를 전송에 남기지 않습니다).

       --copy-dirlinks
              디렉토리에 대한 심볼릭 링크만 실제 디렉토리로 전환하고, 다른 모든 심볼릭 링크는 아래 설명된 대로 처리되도록 둡니다.

       --links --copy-unsafe-links
              모든 안전하지 않은 심볼릭 링크를 파일로 전환하고, 모든 안전한 심볼릭 링크를 생성합니다.

       --copy-unsafe-links
              모든 안전하지 않은 심볼릭 링크를 파일로 전환하고, 모든 안전한 심볼릭 링크는 시끄럽게 건너뜁니다.

       --links --safe-links
              수신자는 전송에서 발견된 안전하지 않은 심볼릭 링크 생성을 건너뛰고 안전한 심볼릭 링크를 생성합니다.

       --links
              모든 심볼릭 링크를 생성합니다.

       --munge-links의 효과에 대해서는 해당 옵션 섹션의 설명을 참조하십시오.

       --keep-dirlinks 옵션은 전송의 심볼릭 링크에는 영향을 미치지 않고, 대신 rsync가 수신 측에 이미 존재하는 디렉토리에 대한 심볼릭 링크를 처리하는 방식에 영향을 미친다는 점에 유의하십시오.
       해당 옵션 섹션의 경고를 참조하십시오.

DIAGNOSTICS
       Rsync는 때때로 다소 이해하기 어려운 오류 메시지를 생성합니다.
       가장 혼란을 야기하는 메시지는 "protocol version mismatch -- is your shell clean?"입니다.

       이 메시지는 일반적으로 시작 스크립트 또는 원격 셸 기능이 rsync가 전송에 사용하는 스트림에 원치 않는 쓰레기 데이터를 생성할 때 발생합니다.
       이 문제를 진단하는 방법은 다음과 같이 원격 셸을 실행하는 것입니다:

           ssh remotehost /bin/true > out.dat

       그런 다음 out.dat 파일을 확인하십시오.
       모든 것이 올바르게 작동하면 out.dat는 0 길이 파일이어야 합니다.
       rsync에서 위 오류가 발생하면 out.dat에 일부 텍스트 또는 데이터가 포함되어 있을 것입니다.
       내용을 살펴보고 무엇이 이를 생성하는지 파악해 보십시오.
       가장 흔한 원인은 비대화형 로그인에 대한 출력 문을 포함하는 잘못 구성된 셸 시작 스크립트(.cshrc 또는 .profile과 같은)입니다.

       필터 패턴을 디버깅하는 데 문제가 있다면 -vv 옵션을 지정해 보십시오.
       이 상세도 수준에서는 rsync가 각 개별 파일이 포함되거나 제외되는 이유를 보여줍니다.

EXIT VALUES
       o      0 - 성공

       o      1 - 구문 또는 사용 오류

       o      2 - 프로토콜 비호환성

       o      3 - 입력/출력 파일, 디렉토리 선택 오류

       o

              o      4 - 요청된 작업이 지원되지 않습니다. 다음 중 하나일 수 있습니다:

                     64비트 파일을 지원할 수 없는 플랫폼에서 64비트 파일을 조작하려는 시도

              o      클라이언트에서 지원하지만 서버에서는 지원하지 않는 옵션이 지정됨

       o      5 - 클라이언트-서버 프로토콜 시작 오류

       o      6 - 데몬이 로그 파일에 추가할 수 없음

       o      10 - 소켓 I/O 오류

       o      11 - 파일 I/O 오류

       o      12 - rsync 프로토콜 데이터 스트림 오류

       o      13 - 프로그램 진단 오류

       o      14 - IPC 코드 오류

       o      20 - SIGUSR1 또는 SIGINT 수신

       o      21 - waitpid()에서 반환된 일부 오류

       o      22 - 코어 메모리 버퍼 할당 오류

       o      23 - 오류로 인한 부분 전송

       o      24 - 사라진 소스 파일로 인한 부분 전송

       o      25 - --max-delete 제한으로 삭제 중지

       o      30 - 데이터 송수신 타임아웃

       o      35 - 데몬 연결 대기 타임아웃

ENVIRONMENT VARIABLES
       CVSIGNORE
              CVSIGNORE 환경 변수는 .cvsignore 파일의 무시 패턴을 보완합니다. 자세한 내용은 --cvs-exclude 옵션을 참조하십시오.

       RSYNC_ICONV
              이 환경 변수를 사용하여 기본 --iconv 설정을 지정합니다. 3.0.0부터 처음 지원됩니다.

       RSYNC_OLD_ARGS
              --old-args 옵션을 기본적으로 활성화하려면 "1"을 지정하고, 반복 옵션 상태로 활성화하려면 "2" (또는 그 이상)를 지정하거나, 기본적으로 비활성화되도록 하려면 "0"을 지정하십시오.
              이 환경 변수가 0이 아닌 값으로 설정되면 RSYNC_PROTECT_ARGS 변수를 재정의합니다.

              이 변수는 --old-args, --no-old-args 또는 --secluded-args가 명령줄에 지정된 경우 무시됩니다.

              3.2.4부터 처음 지원됩니다.

       RSYNC_PROTECT_ARGS
              --secluded-args 옵션을 기본적으로 활성화하려면 0이 아닌 숫자 값을 지정하고, 기본적으로 비활성화되도록 하려면 0 값을 지정하십시오.

              이 변수는 --secluded-args, --no-secluded-args 또는 --old-args가 명령줄에 지정된 경우 무시됩니다.

              3.1.0부터 처음 지원됩니다. 3.2.4부터 이 변수는 RSYNC_OLD_ARGS가 0이 아닌 값으로 설정되면 무시됩니다.

       RSYNC_RSH
              이 환경 변수를 사용하면 rsync의 전송으로 사용되는 기본 셸을 재정의할 수 있습니다.
              --rsh (-e) 옵션과 마찬가지로 명령 이름 뒤에 명령줄 옵션이 허용됩니다.

       RSYNC_PROXY
              이 환경 변수를 사용하면 rsync 데몬에 연결할 때 rsync 클라이언트가 웹 프록시를 사용하도록 리디렉션할 수 있습니다.
              RSYNC_PROXY를 hostname:port 쌍으로 설정해야 합니다.

       RSYNC_PASSWORD
              이 환경 변수를 사용하면 rsync 데몬 연결에 대한 암호를 설정하여 암호 프롬프트를 피할 수 있습니다.
              이는 ssh와 같은 원격 셸 전송에 암호를 제공하지 않는다는 점에 유의하십시오 (이를 수행하는 방법은 해당 설명서를 참조하십시오).

       USER or LOGNAME
              USER 또는 LOGNAME 환경 변수는 rsync 데몬으로 전송되는 기본 사용자 이름을 결정하는 데 사용됩니다.
              둘 다 설정되지 않으면 사용자 이름은 "nobody"로 기본값이 지정됩니다.
              둘 다 설정된 경우 USER가 우선합니다.

       RSYNC_PARTIAL_DIR
              이 환경 변수는 부분 전송이 활성화되도록 암시하지 않고 --partial 전송에 사용할 디렉토리를 지정합니다.
              자세한 내용은 --partial-dir 옵션을 참조하십시오.

       RSYNC_COMPRESS_LIST
              이 환경 변수를 사용하면 대체 순서 또는 축소된 이름 목록을 지정하여 압축 알고리즘 협상을 사용자 정의할 수 있습니다.
              사용 가능한 압축 이름을 확인하려면 rsync --version 명령을 사용하십시오.
              자세한 내용은 --compress 옵션을 참조하십시오.

       RSYNC_CHECKSUM_LIST
              이 환경 변수를 사용하면 대체 순서 또는 축소된 이름 목록을 지정하여 체크섬 알고리즘 협상을 사용자 정의할 수 있습니다.
              사용 가능한 체크섬 이름을 확인하려면 rsync --version 명령을 사용하십시오.
              자세한 내용은 --checksum-choice 옵션을 참조하십시오.

       RSYNC_MAX_ALLOC
              이 환경 변수는 --max-alloc 옵션을 사용한 것처럼 할당 최대값을 설정합니다.

       RSYNC_PORT
              이 환경 변수는 rsync에 의해 읽히지 않지만, rsync가 원격 셸을 데몬 연결과 함께 실행할 때 하위 환경에 설정됩니다.
              이를 통해 rsync-ssl과 같은 스크립트가 명령줄에 사용자가 지정한 포트 번호를 알 수 있습니다.

       HOME   이 환경 변수는 사용자의 기본 .cvsignore 파일을 찾는 데 사용됩니다.

       RSYNC_CONNECT_PROG
              이 환경 변수는 주로 디버그 설정에서 데몬 연결을 할 때 사용할 프로그램을 설정하는 데 사용됩니다.
              자세한 내용은 CONNECTING TO AN RSYNC DAEMON을 참조하십시오.

       RSYNC_SHELL
              이 환경 변수는 주로 디버그 설정에서 RSYNC_CONNECT_PROG에 의해 지정된 프로그램을 실행하는 데 사용할 프로그램을 설정하는 데 사용됩니다.
              자세한 내용은 CONNECTING TO AN RSYNC DAEMON을 참조하십시오.

FILES
       /etc/rsyncd.conf 또는 rsyncd.conf

SEE ALSO
       rsync-ssl(1), rsyncd.conf(5), rrsync(1)

BUGS
       o      시간은 *nix time_t 값으로 전송됩니다.

       o      FAT 파일 시스템으로 전송할 때 rsync가 수정되지 않은 파일을 다시 동기화할 수 있습니다. --modify-window 옵션에 대한 설명을 참조하십시오.

       o      파일 권한, 장치 등은 원시 숫자 값으로 전송됩니다.

       o      --delete 옵션에 대한 설명도 참조하십시오.

       버그를 보고해 주십시오! 웹 사이트 https://rsync.samba.org/를 참조하십시오.

VERSION
       이 맨페이지는 rsync 버전 3.2.7에 대한 것입니다.

INTERNAL OPTIONS
       --server 및 --sender 옵션은 rsync 내부적으로 사용되며, 정상적인 상황에서는 사용자가 직접 입력해서는 안 됩니다.
       이러한 옵션에 대한 인식이 특정 시나리오, 예를 들어 rsync 명령만 실행할 수 있는 로그인을 설정할 때 필요할 수 있습니다.
       예를 들어, rsync 배포판의 support 디렉토리에는 rrsync (제한된 rsync)라는 예시 스크립트가 있으며, 제한된 ssh 로그인과 함께 사용할 수 있습니다.

CREDITS
       Rsync는 GNU General Public License에 따라 배포됩니다. 자세한 내용은 COPYING 파일을 참조하십시오.

       rsync 웹 사이트는 https://rsync.samba.org/에서 사용할 수 있습니다. 이 사이트에는 이 설명서 페이지에서 다루지 않은 질문에 답할 수 있는 FAQ-O-Matic이 포함되어 있습니다.

       rsync github 프로젝트는 https://github.com/WayneD/rsync입니다.

       이 프로그램을 좋아하신다면 기꺼이 여러분의 의견을 듣겠습니다. rsync@lists.samba.org 메일링 리스트로 연락주십시오.

       이 프로그램은 Jean-loup Gailly와 Mark Adler가 작성한 훌륭한 zlib 압축 라이브러리를 사용합니다.

THANKS
       특별히 John Van Essen, Matt McCutchen, Wesley W. Terpstra, David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, 그리고 우리를 떠났지만 잊혀지지 않을 동지 J.W. Schultz에게 감사드립니다.

       Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell, David Bell에게도 감사드립니다. 몇몇 분들을 놓쳤을 수도 있습니다. 죄송합니다.

AUTHOR
       Rsync는 원래 Andrew Tridgell과 Paul Mackerras가 작성했습니다. 많은 사람들이 나중에 기여했습니다. 현재 Wayne Davison이 유지 관리하고 있습니다.

       지원 및 개발을 위한 메일링 리스트는 https://lists.samba.org/에서 사용할 수 있습니다.

rsync 3.2.7                                                                                2022년 10월 20일                                                                                rsync(1)
```

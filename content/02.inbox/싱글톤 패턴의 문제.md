---
title: 싱글톤 패턴의 문제
resource-path: 02.inbox/싱글톤 패턴의 문제.md
keywords:
tags:
  - java
  - design_patterns
date: 2024-01-26T05:15:00+09:00
lastmod: 2024-01-26T05:15:00+09:00
---
클래스의 생성자를 통해 만들어지는 인스턴스의 개수를 1개로 고정시키는 디자인 패턴이다
하지만 이는 몇가지 문제를 만들어낸다

- [](|싱글톤%20패턴의%20문제#코드양%20증가)
- 의존성 문제
- OCP 원칙 위반
- 테스트 어려움
- 내부 속성 변경 어려움
- 자식 클래스 생성 어려움


## 코드 양 증가
싱글톤 패턴을 구현하려면 클래스 내에 싱글톤 인스턴스를 생성하고 관리하는 코드가 추가됩니다. 이로 인해 코드가 더 복잡해지고, 가독성이 떨어질 수 있습니다.
```java
public class SingletonImpl implements Singleton{
    private static SingletonImpl instance;

    private SingletonImpl() {
        // private 생성자
    }

    public static SingletonImpl getInstance() {
        if (instance == null) {
            instance = new SingletonImpl();
        }
        return instance;
    }
}
   ```

## 의존성 문제
클라이언트는 Singleton 클래스에 직접 의존하게 되므로, 의존성 역전 원칙(Dependency Inversion Principle, DIP)을 위반합니다. 즉, 클라이언트는 구체 클래스에 종속되어 유연성이 감소합니다.
   
```java
public class Client {
    private Singleton singleton = SingletonImpl.getInstance();

    // 클라이언트가 SingletonImpl 클래스에 직접 의존
}
   ```
## OCP 원칙 위반
만약 다른 싱글톤 클래스로 교체하려면 클라이언트 코드를 직접 수정해야 합니다. 이는 개방-폐쇄 원칙(Open/Closed Principle, OCP)을 위반하는 것이며, 시스템 확장이 어려워집니다.
```java
public class Client {
    private Singleton singleton = SingletonImpl.getInstance();
    // 다른 싱글톤 클래스로 교체하려면 클라이언트 코드 수정 필요
}
   ```
   
## 테스트 어려움
싱글톤은 전역 상태를 가지고 있어 테스트하기 어려울 수 있습니다. 특히 싱글톤 인스턴스가 다른 객체에 의존하는 경우, 모의 객체(Mock Object) 등을 사용하기 어려워집니다. 싱글톤 인스턴스가 다른 객체에 의존하는 경우, 이 의존성을 모의 객체로 대체하는 것이 어렵습니다. 싱글톤 인스턴스는 생성 시점에 의존성을 갖게 되므로, 테스트 시점에 이를 모의 객체로 대체하는 것이 불가능합니다. 이로 인해 의존성에 대한 제어가 어려워져, 테스트가 복잡해질 수 있습니다.
```java
public class SingletonImpl {
    private Dependency dependency;

    private SingletonImpl() {
        this.dependency = new Dependency(); // 의존성 주입이 어려움
    }
    // ...
}
```
## 내부 속성 변경 어려움
일반적으로 싱글톤은 내부 상태를 변경하거나 초기화하는 메서드를 제공하지 않습니다. 따라서 내부 속성을 동적으로 변경하기 어려울 수 있습니다.
```java
public class SingletonImpl {
    private int value;
    private SingletonImpl() {
        this.value = 0;
    }
    // 내부 속성 변경 메서드가 없음
}

   ```
## 자식 클래스 생성 어려움
싱글톤 클래스의 생성자가 private이므로 자식 클래스에서 이를 상속하고 확장하기 어려워집니다.
```java
public class ChildSingleton extends SingletonImpl {
    // 오류: 부모 클래스의 생성자에 접근할 수 없음
}
```





>**유연성 감소**: 위의 문제들로 인해 싱글톤 패턴은 유연성이 감소하게 되며, 코드 유지보수 및 확장이 어려워집니다. 이로 인해 안티패턴으로 불리기도 합니다.
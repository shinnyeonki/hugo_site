---
title: 그래서 컴퓨터는 어떻게 동작하나요 1
aliases: 
tags:
  - cs
  - cpu
description: 
source: 그래서 컴퓨터는 어떻게 동작하나요
sequence: "1"
finish: 
created: 2024-07-10T00:41:00+09:00
modified: 2025-10-12T15:43:22+09:00

---

> WORD : CPU 에 의해 한번에 처리될 수 있는 비트 수

## SR latch

NOR 게이트를 사용한 SR 래치는 기본적인 SR 래치로, 아래와 같이 작동합니다.

- 두 개의 NOR 게이트를 교차 연결합니다.
- 입력은 S(Set)와 R(Reset)입니다

| S   | R   | Q (다음 상태) | ¬Q (다음 상태) |
| --- | --- | --------- | ---------- |
| 0   | 0   | Q (이전 상태) | ¬Q (이전 상태) |
| 0   | 1   | 0         | 1          |
| 1   | 0   | 1         | 0          |
| 1   | 1   | 불안정       | 불안정        |

NAND 게이트를 사용한 SR 래치는 약간 다르게 동작합니다. 이 경우에는 입력을 보통 S'와 R'으로 표기합니다.
- 입력은 S'(Set)와 R'(Reset)입니다. 여기서 S'와 R'은 각각 S와 R의 부정 입력입니다.

| S'  | R'  | Q (다음 상태) | ¬Q (다음 상태) |
| --- | --- | --------- | ---------- |
| 0   | 0   | 불안정       | 불안정        |
| 0   | 1   | 1         | 0          |
| 1   | 0   | 0         | 1          |
| 1   | 1   | Q (이전 상태) | ¬Q (이전 상태) |
\
## D latch
sr latch 의 확장판
1. 불안정 상태 즉 q = ¬Q 인 상황 제거
2. clk 주기에 컨트롤 가능하게 한다
    clk 가 1이면 data 저장 clk 가 0 이면 data 저장하지 않는다

| gate or enable | Data | Q 다음상태    |
| -------------- | ---- | --------- |
| 0              | 0    | Q (이전 상태) |
| 0              | 1    | Q (이전 상태) |
| 1              | 0    | 0         |
| 1              | 1    | 1         |

## D flip flop
D latch 의 확장판
1. Q 는 오직 클럭이 0 에서 1로 바뀌는 시점의 data 를 저장한다 즉 RISING EDGE 에서만 저장 허용 클럭에 사용할 수 있다

|Clock Edge|D|Q (다음 상태)|
|---|---|---|
|상승/하강|0|0|
|상승/하강|1|1|



레지스터
set = 저장 활성화 여부
enabler = 출력 활성화 여부








## ALU

아래의 조합회로들로 ALU 를 구성한다 세부적인 설계는 최적화 여부에 따라 많이 달라질 수 있다
- adder
- shift right
- shift left
- not
- ander
- orer

ALU 는 아래의 in 그리고 out  을 가진다
- in
	- a (첫번째 피연산자)
	- b (두번째 피연산자)
	- c_in ( carry in )
	- op (operation code) 명령어가 들어간다
- out
	- 연산 결과
	- c_out (carry out)
	- a > b
	- a = b
	- zero

결국 위의 부품을 통해 아래의 레지스터에 임시적으로 저장된다
1. **누산기(Accumulator)**: 연산 결과를 일시적으로 저장하는 레지스터입니다. ALU의 주요 연산 결과가 이곳에 저장됩니다.
2. **피연산자 레지스터(Operand Registers)**: 연산에 사용되는 데이터를 저장하는 레지스터입니다. 예를 들어, 소스 레지스터(Source Register)와 대상 레지스터(Destination Register)가 있습니다.
3. **상태 레지스터(Status Register)** 또는 **플래그 레지스터(Flag Register)**: 연산 결과에 따른 상태 정보(예: 오버플로우, 제로, 부호 등)를 저장합니다. 이는 이후 연산이나 조건 분기에 사용됩니다.
	1. flag register 의 각 비트에 이러한 bit 를 정해 위에서 나온 out 결과를 저장한다
4. **프로그램 카운터(Program Counter)**: 다음에 실행할 명령어의 주소를 저장하는 레지스터로, ALU가 프로그램의 흐름을 제어하는 데 중요한 역할을 합니다.



### 상태 레지스터의 플래그 예시
1. **제로 플래그(Zero Flag, ZF)**: 연산 결과가 0일 때 설정됩니다. 결과가 0이 아닌 경우에는 클리어됩니다.
2. **부호 플래그(Sign Flag, SF)**: 연산 결과의 최상위 비트가 1일 경우 설정됩니다. 이는 결과가 음수임을 나타냅니다.
3. **캐리 플래그(Carry Flag, CF)**: 덧셈에서 자리올림이 발생하거나, 뺄셈에서 자리내림이 발생할 때 설정됩니다. 이는 또한 unsigned 연산의 오버플로우를 나타냅니다.
4. **오버플로우 플래그(Overflow Flag, OF)**: 부호 있는 연산에서 오버플로우가 발생할 때 설정됩니다. 이는 결과가 표현할 수 있는 범위를 초과했음을 나타냅니다.
5. **패리티 플래그(Parity Flag, PF)**: 연산 결과의 하위 8비트의 1의 개수가 짝수일 때 설정됩니다.
6. **보조 캐리 플래그(Auxiliary Carry Flag, AF)**: 4비트 경계에서 자리올림이나 자리내림이 발생할 때 설정됩니다. 이는 주로 BCD(Binary-Coded Decimal) 연산에서 사용됩니다.
7. **트랩 플래그(Trap Flag, TF)**: 설정되면 프로세서가 한 명령어를 실행한 후 인터럽트를 발생시킵니다. 주로 디버깅 목적으로 사용됩니다.
8. **인터럽트 플래그(Interrupt Flag, IF)**: 설정되면 마스크 가능한 인터럽트를 허용합니다. 클리어되면 인터럽트가 무시됩니다.
9. **디렉션 플래그(Direction Flag, DF)**: 문자열 처리 명령어에서 증가 또는 감소 방향을 설정합니다. 설정되면 감소 방향으로, 클리어되면 증가 방향으로 처리됩니다.

## RAM
ram은 크게 저장된 위치를 나타내는 address bus 와 data 를 저장하거나 출력해 볼 수 있는 data bus  2개로 이루어져있다
여기서 조금 더 들어가서 










## 클럭의 종류
원본 클럭 01010101 반복
출력 제어 011101110111 반복 enable 출력
입력 제어 001000100010 반복 set 저장




## 사용되는 레지스터
- 범용 레지스터 실제 인스턴스 R0, R1, R2, R3 범용 레지스터
- IAR(PC) : 다음 실행할 명령어의 주소를 저장하는 레지스터
- IR : 현재 실행중인 명령어 그 자체를 보유
- TMP : ALU 는 2개의 피연산자가 필요한데 첫번째로 bus로 흐르는 값을 임시 저장하는 레지스터
- BUS1 : 다음에 실행할 명령어는 일반적으로 1 이며 이것을 회로 단에서 쉽게 계산하기 위한 TMP 와 ALU 사이에 있는 1 레지스터 
- ACC : ALU 로 부터 계산된 값은 임시적으로 저장하는 레지스터
- MAR : 메모리 특정 위치의 값을 가리키는 레지스터
- CTMP : carry out 이 발생한 것을 다시 carry in 하기위한 임시 저장 레지스터

## 8비트 컴퓨터 명령어 구조
1~4 : 4비트는 명령어의 종류 선택하는 OPCODE 이다
5~6 : 2비트는 레지스터 선택자(RA)로 00 부터 11 까지 각각 R0, R1, R2, R3 레지스터에 매핑되어 있다
7~8 : 2비트는 레지스터 2비트는 레지스터 선택자(RB)로 00 부터 11 까지 각각 R0, R1, R2, R3 레지스터에 매핑되어 있다

> 후술한 cpu 는 8비트 컴퓨터로 여러가지 제약사항이 있다
> 1. 실제 컴퓨터는 rising edge 에 set(저장) 을 하는 것이 일반적인 방식이지만 지금은 1일때 set 하는 방식으로 만들었다
> 2. ROM에 제어방식(어떤 OPCODE 일때 어떤 동작을 수행(일반적으로 레지스터 쓰기 읽기))을 적는 마이크로코드 방식이 아닌 하드웨어 기반 제어방식으로 서술 되어있다
> 3. 상대적으로 적은 step 을 사용하는 명령의 경우 END_INST 비트가 있다면 남은 스텝을 밟지 않고 다시 처음 step 부터 시작할 수 있지만 opcode 의 비트수가 4개밖에 없으므로 남은 step 은 아무 실행도 하지 않지만 step 은 밟아야 한다 이를 위해 링카운터를 사용한다 (다른 종류는 리플 카운터가 있다)

## INSTRUCTIO DECODE (Stepper 단계마다 실행해야할 작업 목록)

> 아래는 ROM에 제어방식을 적는 마이크로코드 방식이 아닌 하드웨어 기반 제어방식으로 서술 되어있다

어떤 명령이든 1,2,3 단계인 ram 에서 명령어를 꺼내와서 IR 에 저장하고 IAR 에 +1 을 하여 다시 IAR 에 저장하는 단계는 동일하다

### 1,2,3단계  명령어 가져오기 실행해야할 작업 목록
1. IAR에 담긴 주소를 이용해 RAM에서 현재 실행할 명령어를 꺼낸다
2. IR 에 저장한다
3. IAR 값을 1 증가시킨다

**자세한 접근**
1. 현재 상태 : IAR 에는 현재 실행해야 할 명령을 가리키는 주소가 들어있다 / BUS 에 IAR 값이 흐를 때 다음 접근 명령 주소를 미리 계산해야 한다 
   IAR 값을 enable 시켜서 MAR 에 set(저장) 시킨다 또한 다음 싸이클에 IAR 이 접근해야할 메모리 주소 +1 을 해야 하므로 bus1 을 enable 시킨다 그리고 +1 한 값을 3단계에서 IAR 에 집어넣어야 하기 때문에 임시 보관 용도로 ACC 를 set 시킨다
2. RAM 을 Enable 시켜서 MAR 에 들어있는 현재 명령값이 BUS 로 흐르게 된다 또한 그 BUS 로 흐른 값이 IR 로 들어가게 set 한다
3. ACC 를 enable 시켜서 IAR + 1 한 값이 BUS 로 흐르게 하고 그것은 IAR 을 Set 시켜서 다음 명령 주소값을 저장한다


| stapper | ACC    | BUS1(s) | IAR    | IR  | MAR | RAM    | BUS                |
| ------- | ------ | ------- | ------ | --- | --- | ------ | ------------------ |
| 1       | set    | enable  | enable |     | set |        | IAR (현재 실행중 명령 주소) |
| 2       |        |      ![](../../08.media/20240712214531.png)     |
| 3       | enable |         | set    |     |     |        | ACC(현재 실행 IAR+1)   |



### 4,5,6단계 ALU 명령일 때 실행해야할 작업 목록(op_0 = 1)

![Pasted image 20240712214531](../../08.media/20240712214531.png)
![Pasted image 20240712220752](../../08.media/20240712220752.png)
![Pasted image 20240713032992](../../08.media/20240713032992.png)
**자세한 접근**
1. 현재 RB 에 값을 bus 보내기 위해 enable 한다 ALU 는 2개의 값이 필요하므로 임시로 TMP 를 set 시켜서 bus 의 값을 임시 저장시킨다
2. RA 를 bus로 보내기 위해 enable 시킨다 또한 동시에 ALU 는 계산된 값을 내보내며 이것은 임시 저장하기 위해 ACC 를 set 시킨다
3. ACC 값을 enable 시켜서 bus 로 흐르게 한다 bus로 흐른 값이 RB 로 저장하기 위해 RB 를 set 한다 단 여기서 ALU 비교연산(OP 명령 1111)에서는 RB 로 저장하지 않는다


%% 4. RB 값 TMP 저장
5. RA 와 TMP을 ALU를 통해 계산할 것을 ACC 에 저장
6. ACC 의 값을 RB 로 저장 단 비교 연산은 제외 %%

### 4,5,6단계 LOAD, STORE 명령일 때 실행해야할 작업 목록(op = 0000), (op = 0001)
![Pasted image 20240713075383](../../08.media/20240713075383.png)
![Pasted image 20240713075825](../../08.media/20240713075825.png)

**LOAD**
4. RA 에 들어있는 RAM 주소를 MAR 에 저장
5. MAR을 통해 RAM의 데이터를 RB 에 저장

**STORE**
1. RA 에 들어있는 RAM 주소를 MAR 에 저장'
2. RB 의 데이터를 RAM 에 저장

### 4,5,6 단계 DATA 명령일 때 실행해야할 작업 목록(op = 0010)

![Pasted image 20240713083787](../../08.media/20240713083787.png)
![Pasted image 20240713084179](../../08.media/20240713084179.png)

4. IAR 의 값을 MAR 로 저장, BUS1 을 enable 하여 ALU 값을 실행하여 ACC 에 미리 다음 명령을 준비
5. MAR 에 의해 읽어낸 RAM 의 값을 RB 로 저장
6. ACC 의 값을 IAR 에 저장

**자세한 접근**

4. 예를 들어서 설명 현재 명령어 위치 주소는 26 이지만 명령어 가져오기 단계에서 IAR 에 이미 27 다음 단계의 명령어 위치 주소가 기다리고 있다 또한 DATA 명령에서는 27 주소(다음 명령 주소 위치)에는 명령어가 아닌 data 값이 들어 있으므로 4단계에서 IAR 의 값을 MAR 에 주면 데이터를 꺼내올수 있다 물론 앞단계에서 +1 을 하여 다음 명령을 대비한 것은 무효화 했으므로 +1 해서 다시 IAR 에 저장해야 한다 그렇게 하기 위해 bus 에 흐르는 IAR 값(2바이트 명령어 data 부분)을 ALU 로 보내고 BUS1 또한 enable 하여 ALU 에 계산된 값을 임시저장하기 위해 ACC 를 set 한다
   즉 IAR enable, MAR set, BUS1 enable, ACC set
5. RAM enable 하여 원하는 2개의 바이트로 이루어진 명령의 2번째 바이트의 명령(실제는 data) 가 버스로 흐르게 된다 버스로 흐르는 RB 에 저장하기 위해 RB 를 set
6. ACC 에 임시 저장된 값(다음 명령어 주소 29)를 IAR 에 저장하기 위해 enable 하고 IAR 은 set 한다


### 4,5,6 단계 JMPR RB 명령일 때 실행해야할 작업 목록(op = 0011)
![Pasted image 20240714091621](../../08.media/20240714091621.png)


4. 단순히 RB 에 들어있는 것을 IAR 에 저장
   RB enable, IAR set :
   RB 를 enable 하여 bus 로 보낸다 그리고 IAR 을 set 시켜 bus 흐른 값을 저장 시켜 다음 명령에는  RB 에 들어있는 주소가 바로 실행되게 한다


### 4,5,6 단계 JMP Addr 명령일 때 실행해야할 작업 목록(op = 0011)


4. IAR 을 MAR 에 저장
5. RAM 에 출력을 IAR 로 저장


 

**자세한 접근**
1. IAR enable, MAR set : 
   현재 IAR 에는 다음 명령의 주소가 지금 명령의 +1 해서 들어있다 즉 주소데이터에 분기할 주소가 적혀 있다
2. RAM enable, IAR set : 
   분기 명령이므로 IAR 의 값을 두번째 바이트의 값으로 바꿔 주어야 한다 즉 현재 저장된 주소값에 저장된 메모리에 접근해서 분기할 주소값을 가져와 IAR 에 넣어주어야 한다



### 4,5,6 단계 J(C,A,E,Z) JUMP CONDITION 명령일 때 실행해야할 작업 목록 (op = 0101)


![Pasted image 20240716143528](../../08.media/20240716143528.jpg)
![Pasted image 20240716143532](../../08.media/20240716143532.jpg)
![Pasted image 20240716143535](../../08.media/20240716143535.jpg)
![Pasted image 20240717075319](../../08.media/20240717075319.png)
- **c**: Carry (자리올림)
- **a**: Greater than (a > b)
- **e**: Equal (a = b)
- **z**: Zero (결과가 0)


1. 일반 Jump 와 동일하게 IAR 을 MAR 에 저장
2. 5단계에서는 분기하지 않는 상황을 처리 acc 에 있는 
3. 6단계에서는 분기하는 상황을 처리

**자세한 접근**
전제 조건 
- 5단계에서는 분기하지 않는 상황을 처리 6단계에서는 분기하는 상황을 처리
- ALU 는 항상 flag 를 출력하는데 이때 BUS1 같은 상황에서 플래그 비트를 저장하지 말하야 한다 그렇다면 ALU 실행중에서만 명령에서 자리올림을 받기 위해 일반적인 ALU 연산에서는 4단계에서 TMP 레지스터를  set 하고 5단계에서 ACC 레지스터를 set 한다 이때 TMP set 의 신호가 Ctmp 와 함께 set 되며 이전에 자리올림되었던 값을 적용 시킨다
   또한 이전의 ALU 명령에서 flag 레지스터를 저장하기 위해 5단계 ALU 명령에서 ACC set 신호와 함께 flags ALU set 신호를 함께 준다
- 각각의 IR의 4,5,6,7 번 플래그와 ALU(Flags 레지스터)를 각각 플레그를 비교하여 UPDATE IAR 을 할지 판단한다


1. IAR enable, MAR set, BUS1 enable
   일반 JUMP 와 동일하게 IAR 을 MAR 에 저장 또한 분기 하지 않을 수 있으므로 BUS1 또한 enable
2. bus1 enable, acc enable, IAR set
   5단계에서는 분기 하지 않을 상황을 처리 미리 IAR 을 분기 하지 않을 상황으로 가정하고  BUS1 으로 계산된 +1 (조건이 맞지 않는 상황) ACC 값을 IAR 에 저장
3. 6단계에서는 분기할 상황을 처리하므로 MAR 을 통해 접근할 주소를 얻기 위해 RAM 을 Enable, IAR 을 조건에 따라 SET


### 4,5,6 단계 CLF 명령일 때 실행해야 할 작업 목록 (op = 0110)

현재까지 Flags set 신호 Ctmp enable 신호만 만들고 Ctmp 신호의 set 신호의 경우 ALU 연산실행시 무조건 set 되는 TMP 신호를 중복 활용하여 사용했다 또한  Flags 의 enable 신호는 따로 만들지 않았기 때문에 Flags 레시스터를 이후 연산에 사용되지 않도록 clear 0000으로 만드는 Clear Flag instruction 이 필요하다 ((c_out)=0 -> 0 , (a>b) -> 0, (a=b) -> 0, (Zero) -> 0) 인 상황을 강제로 만들기 위해 BUS1 을 Enable 하면 ALU b 입력으로 1이 들어가고 A 입력은 default 값이 0 이 들어가므로 Flags 레지스터를 set 만 한다면 Flags 비트가 0000으로 초기화 된다
4. BUS1 enable, Flages set


### 4,5,6 단계 NOP 명령일 때 실행해야할 작업 목록
프로그램을 멈추기 위해 inscruction fetch 모듈에서 명령을 가져오지 못하게 하면 프로그램이 멈추게 된다 된다








### ALU Selection module
모든 ALU 명령은 RB 를 먼저 가져와 TMP 에 먼저 저장 그다음에 RA 를 가져와 ALU 계산을 통해 ACC 저장 ACC 저장 값을 다시 RB 에 저장하는 형태이다(비교연산을 제외하고) 즉 
$RB = RA\  (산술\ 연산)\  RB$
와 같이 표현되며 ALU Selection moudle 에서는 입력 클럭 사용은 RB 에만 적용된다











### 18강 레지스터 상태변화 4~7 단계

| stapper | ACC        | R0        | R1        | TMP(s) | BUS     |
| ------- | ---------- | --------- | --------- | ------ | ------- |
| 초기 값    | Err        | 5         | 8         | Err    | Err     |
| 4       |            |           | enable(8) | set(8) | R1(8)   |
| 5       | set(5)     | enable(5) |           |        | R0(5)   |
| 6       | enable(13) | set(13)   |           |        | ACC(13) |
| 7       |            |           |           |        |         |


### 20강 명령어 가져오기 단계(1 ~ 3)에서의 레지스터 상태 변화

| stapper | ACC    | BUS1(s) | IAR    | IR  | MAR | RAM    | BUS                |
| ------- | ------ | ------- | ------ | --- | --- | ------ | ------------------ |
| 1       | set    | enable  | enable |     | set |        | IAR (현재 실행중 명령 주소) |
| 2       |        |         |        | set |     | enable | RAM(접근한 명령값)       |
| 3       | enable |         | set    |     |     |        | ACC(현재 실행 IAR+1)   |




| stapper |       |       |       | ACC    | RA      | RB      | TMP(s) | BUS   |
| ------- | ----- | ----- | ----- | ------ | ------- | ------- | ------ | ----- |
| 1       |       |       |       |        |         |         |        |       |
| 2       |       |       |       |        |         |         |        |       |
| 3       |       |       |       |        |         |         |        |       |
| 4       |       |       |       |        |         | enable  | set    | RB    |
| 5       |       |       |       | set    | enable  | disable | unset  | RA    |
| 6       |       |       |       | enable | disable |         |        | ACC   |
| 7       | reset | reset | reset | reset  | reset   | reset   | reset  | reset |


---



---

---

```psedocode
A = 127
B = 29
C = 88
D = A - B - C
  = 10
```

```armasm
:aa <- 7f // 1단계
:ab <- 1d // 2단계
:ac <- 58 // 3단계
:c3 <- ([:aa] - [:ab]) - [:ac] //4단계
```

![Pasted image 20240714055948](../../08.media/20240714055948.png)
![Pasted image 20240714060909](../../08.media/20240714060909.png)
![Pasted image 20240714060244](../../08.media/20240714060244.png)
![Pasted image 20240714060371](../../08.media/20240714060371.png)
![Pasted image 20240714060494](../../08.media/20240714060494.png)

> 뺄때는 2의 보수법을 사용하여 음수를 더하는 개념으로 ALU 에서 - 가 구현되지 않았지만 동작하게 할 수 있다 이 경우 HW 로 구현한 것이 아닌 SW 로 구현한 것이 된다 즉 어셈블리어 단계에서 이 방식을 미리 SW 에서 구현해주어야 한다
> 아래는 음수로 하고 +1 을 하는 방식이다
![Pasted image 20240714060667](../../08.media/20240714060667.png)
![Pasted image 20240714061236](../../08.media/20240714061236.png)
![Pasted image 20240714061127](../../08.media/20240714061127.png)
![Pasted image 20240714061251](../../08.media/20240714061251.png)
![Pasted image 20240714062148](../../08.media/20240714062148.png)
![Pasted image 20240714062107](../../08.media/20240714062107.png)
![Pasted image 20240714062272](../../08.media/20240714062272.png)

명령어 갯수 : 13개






![Pasted image 20240714100280](../../08.media/20240714100280.png)

![Pasted image 20240714100280](../../08.media/20240714100280.png)

- Stepper module : " " => 클럭, step 생성
  클럭 신호 스텝퍼 처리
- IR code module : IR code => ALU 의 어떤 기능 사용 op_out, 
  IR code 해석 모듈
- Instruction fetch module : 1~3 단계 명령 가져오기 모듈
- ALU instruction condition : 4~6 단계 ALU 관련 명령 조건 (ex IR_0 가 1일때)
- ALU instruction module : 4~6 단계 단계에 어떤 레지스터 조건이 필요한지
- Resgister selection module : IR 뒷자리 4개가 어떤 범용 레지스터 선택했는지

초깃값 문재 power on reset 또는 preset

---
title: 백엔드 구조 변화 역사
aliases:
tags:
  - spring
  - ai-content
created: 2025-07-04T06:32:40+09:00
modified: 2025-10-19T18:28:32+09:00

---
## 모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석

현대 백엔드 개발의 핵심 철학
### 서론: 왜 아키텍처는 중요한가?

소프트웨어 개발은 단순히 '동작하는 코드'를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, 새로운 기술이 등장하며, 비즈니스는 확장됩니다. 이러한 변화의 파도 속에서 흔들리지 않는 견고하고 유연한 시스템을 구축하는 것, 이것이 바로 '아키텍처'의 역할입니다. 제공된 텍스트는 웹 애플리케이션 개발 아키텍처의 중요한 변곡점인 **모델 1**과 **모델 2**의 차이를 통해, 좋은 아키텍처가 무엇이며 어떻게 발전해 왔는지를 심도 있게 이야기하고 있습니다. 이는 단순히 기술의 변화가 아닌, '문제 해결 방식'에 대한 패러다임의 전환을 의미합니다.

---

### 제1장: 혼돈의 시대, 모델 1 아키텍처

모델 1 아키텍처는 초창기 웹 개발의 직관적인 접근 방식이었습니다. 웹 페이지(JSP, ASP, PHP 등) 하나가 하나의 요청을 처음부터 끝까지 모두 책임지는 구조입니다.

**1. 핵심 구조: All-in-One 페이지**

사용자가 `list.jsp`라는 페이지를 요청했다고 가정해 봅시다. 모델 1 구조에서 이 `list.jsp` 파일 안에는 다음과 같은 코드들이 뒤섞여 있습니다.

*   **① 요청 분석 코드 (Controller의 역할):** 사용자가 검색어를 입력했는지, 특정 페이지 번호를 요청했는지 등의 파라미터를 분석하는 자바 코드.
*   **② 비즈니스 로직 및 데이터 처리 코드 (Service & Repository의 역할):** 데이터베이스에 연결하여 게시글 목록을 조회하는 SQL 쿼리와 JDBC 코드.
*   **③ 화면 출력 코드 (View의 역할):** 조회된 데이터를 `<table>`, `<li>` 등의 HTML 태그를 사용하여 웹 페이지 형태로 그려내는 코드.

```jsp
<%-- list.jsp (모델 1 예시) --%>
<%@ page import="java.sql.*, java.util.*" %>
<html>
<head><title>게시판 목록</title></head>
<body>
    <h1>게시판 목록</h1>
    <%
        // ① 요청 분석 + ② 데이터 처리 (Controller + Service + Repository)
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List<Map<String, Object>> boardList = new ArrayList<>();

        try {
            // DB 연결
            String dbUrl = "jdbc:mysql://localhost:3306/mydb";
            conn = DriverManager.getConnection(dbUrl, "user", "password");

            // SQL 실행
            String sql = "SELECT id, title, writer, created_at FROM board ORDER BY id DESC";
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();

            // 결과(ResultSet)를 Array(List<Map>)로 변환
            while (rs.next()) {
                Map<String, Object> board = new HashMap<>();
                board.put("id", rs.getInt("id"));
                board.put("title", rs.getString("title"));
                board.put("writer", rs.getString("writer"));
                boardList.add(board);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 자원 해제
            if (rs != null) rs.close();
            if (pstmt != null) pstmt.close();
            if (conn != null) conn.close();
        }
    %>

    <!-- ③ 화면 출력 (View) -->
    <table border="1">
        <tr>
            <th>번호</th>
            <th>제목</th>
            <th>작성자</th>
        </tr>
        <% for (Map<String, Object> board : boardList) { %>
        <tr>
            <td><%= board.get("id") %></td>
            <td><%= board.get("title") %></td>
            <td><%= board.get("writer") %></td>
        </tr>
        <% } %>
    </table>
</body>
</html>
```

**2. 모델 1의 치명적인 문제점**

텍스트에서 지적한 "소스에 대한 응집이 높아 특정 단계에 대한 기능을 수정해도... 결국 전체의 결과물을 확인하고 수정해야 하는 비효율적인 문제"가 바로 여기서 발생합니다.

*   **높은 결합도(High Coupling):** 디자인을 수정하기 위해 HTML 태그 하나를 바꾸려 해도, 복잡한 자바 코드 한가운데를 헤쳐나가야 합니다. 반대로, DB 테이블의 컬럼 이름이 `writer`에서 `author`로 바뀌면, SQL 쿼리뿐만 아니라 HTML을 출력하는 부분의 `board.get("writer")` 코드까지 모두 수정해야 합니다. 디자이너와 개발자의 작업 영역이 완전히 겹쳐 협업이 불가능에 가깝습니다.
*   **낮은 재사용성:** '게시글 목록을 조회하는 로직'은 매우 유용한 기능입니다. 하지만 모델 1에서는 이 로직이 `list.jsp`라는 특정 '화면'에 종속되어 있습니다. 만약 모바일 앱을 위해 게시글 목록 데이터만 JSON 형태로 제공해야 한다면? `list.jsp`의 코드를 복사-붙여넣기하여 `api_list.jsp` 같은 파일을 새로 만들어야 합니다. 이는 중복 코드의 양산이며, 유지보수의 재앙을 불러옵니다.
*   **테스트의 어려움:** '데이터베이스 조회 기능'만 따로 떼어내어 잘 동작하는지 테스트할 방법이 없습니다. 반드시 웹 서버를 실행하고, 브라우저로 `list.jsp`를 요청해서 눈으로 확인해야 합니다. 이는 단위 테스트(Unit Test)의 부재로 이어져 코드의 안정성을 심각하게 저해합니다.
*   **"어레이(Array) 문제":** 텍스트가 명확히 짚은 이 문제는 매우 중요합니다. 위 예제에서 데이터는 `List<Map<String, Object>>` 형태로 전달됩니다. 다음 단계의 코드는 `map.get("title")`과 같이 문자열 키에 의존해야 합니다. 만약 키 이름을 `titel`로 오타를 내도 컴파일 시점에는 오류를 잡을 수 없고, 실행 후 페이지가 깨지거나 오류가 발생한 뒤에야 문제를 인지할 수 있습니다. 데이터의 구조가 명확하지 않아 개발자의 실수를 유발하기 매우 쉬운 구조입니다.

---

### 제2장: 역할의 분리, 모델 2 아키텍처의 등장 (MVC 패턴)

이러한 모델 1의 혼돈을 해결하기 위해 등장한 것이 바로 **모델 2 아키텍처**, 즉 우리에게 친숙한 **MVC(Model-View-Controller) 패턴**입니다. 모델 2의 핵심 철학은 '관심사의 분리(Separation of Concerns)'입니다. 각자 잘하는 일에만 집중하자는 것입니다.

*   **Controller:** 사용자의 요청을 가장 먼저 받는 '교통 경찰'입니다. 요청(URL, 파라미터 등)을 분석하여 어떤 작업이 필요한지 판단하고, 그 작업을 실제 일꾼인 'Service'에게 위임합니다. 작업이 끝나면 결과를 받아 어떤 'View'에게 전달하여 화면을 그리게 할지 결정합니다.
*   **Model:** 실질적인 데이터와 비즈니스 로직을 담당하는 영역입니다. "게시글을 저장한다", "사용자 레벨을 업그레이드한다"와 같은 핵심 로직이 여기에 포함됩니다. 현대 개발에서는 이를 다시 **Service**와 **Repository**로 세분화합니다.
*   **View:** Controller로부터 전달받은 데이터를 화면에 '그리는' 일만 합니다. JSP, Thymeleaf 등이 여기에 해당하며, 내부에는 비즈니스 로직이 전혀 없고 오직 표현 로직만 존재합니다.

**1. 모델 2의 정제: Controller-Service-Repository 구조**

텍스트에서 설명하듯, 현대적인 모델 2 구현은 Model 영역을 더욱 구체적으로 분화하여 책임과 역할을 명확히 합니다.

*   **Controller:** 오직 웹 요청과 응답에만 집중합니다. HTTP 헤더를 분석하고, 요청 본문을 객체로 변환하며, 인증/인가를 확인하고, 적절한 Service 메소드를 호출한 뒤, 그 결과를 JSON, HTML 등 요청된 형식으로 변환하여 응답합니다.
    *   *예시: `/posts` (GET 요청) -> `PostController.getPostList()` 호출*
*   **Service:** '비즈니스 로직'의 중심입니다. 트랜잭션 관리, 여러 데이터 소스 조합 등 애플리케이션의 핵심 정책과 규칙을 구현합니다. 이 계층은 웹(HTTP)이나 데이터베이스(SQL) 기술에 의존하지 않는 순수한 자바 코드로 작성되는 것을 지향합니다.
    *   *예시: `PostService.getPostList()` -> 게시글 목록 조회 로직 수행. 필요하다면 `UserService`를 호출하여 작성자 정보를 함께 가져올 수도 있음.*
    *   **재사용성의 핵심:** 텍스트의 "웹에서 작동했던 게시판의 기능을 단말 어플로 확장해야 할 때 서비스의 고유 기능을 유지한 상태에서 컨트롤러의 기능만 수정"할 수 있다는 설명이 바로 이 지점입니다. 모바일 앱을 위한 JSON 응답이 필요하면, 기존 `PostService`는 그대로 두고 `ApiPostController`를 새로 만들어 동일한 서비스를 호출하기만 하면 됩니다. 핵심 로직의 재사용성이 극대화됩니다.
*   **Repository(DAO):** 데이터 영속성(Persistence)만을 전담합니다. 즉, 데이터베이스에 데이터를 저장(Save), 조회(Find), 수정(Update), 삭제(Delete)하는 역할만 수행합니다.
    *   *예시: `PostRepository.findAll()` -> `SELECT * FROM post` 쿼리 실행*
    *   **유지보수의 효율성:** 텍스트의 "테이블 구조 변경 시 리파지토리 수정만으로 적용이 가능"하다는 설명이 여기에 해당합니다. 데이터베이스가 MySQL에서 PostgreSQL로 바뀌거나, ORM 기술(JPA 등)을 도입할 때, 오직 Repository 계층의 코드만 수정하면 Service나 Controller는 아무런 영향을 받지 않습니다.

**2. 소통의 규약: DTO (Data Transfer Object)**

모델 1의 '어레이 문제'를 해결하는 모델 2의 해법이 바로 **DTO**입니다. 텍스트에서는 '데이터 전달 객체'라고 표현했습니다.

*   **DTO란?** 계층 간 데이터 교환을 위해 사용하는, 데이터 필드(멤버 변수)와 그에 대한 Getter/Setter 메소드만으로 이루어진 순수한 데이터 운반용 객체입니다.
*   **장점:**
    *   **명확한 계약:** DTO는 그 자체로 계층 간에 "우리는 이런 구조의 데이터를 주고받을 것이다"라는 명확한 약속(Contract)이 됩니다.
    *   **타입 안정성(Type Safety):** `map.get("title")` 대신 `postDto.getTitle()`을 사용합니다. `getTitle()` 메소드는 항상 문자열(String)을 반환함이 보장되며, 만약 `getTitel()`과 같이 오타를 내면 컴파일 시점에 즉시 오류를 발견할 수 있습니다.
    *   **개발 편의성:** IDE의 자동완성 기능 등을 통해 어떤 데이터가 있는지 쉽게 파악할 수 있어 생산성이 향상됩니다.

---

### 제3장: 궁극의 유연성, 의존성 주입 (Dependency Injection)

모델 2 구조로 역할을 분리하고 DTO로 소통 규약을 정했지만, 마지막 문제가 남아있습니다. "실제 구현에서 각각의 기능을 연동하기 위한 코드가 생성되어 기능의 독립성이 사라지는 문제"입니다.

`PostController`가 `PostService`를 사용하려면 어떻게 해야 할까요? 가장 단순한 방법은 다음과 같습니다.

```java
public class PostController {
    private PostService postService = new PostServiceImpl(); // ★ 문제 지점!

    // ...
}
```

`PostController`가 `PostServiceImpl`이라는 '구체적인 구현 클래스'를 직접 생성하고 있습니다. 이를 **'강한 결합(Tight Coupling)'**이라고 합니다. 이 코드의 문제는, 만약 `PostService`의 구현체를 테스트용 `TestPostServiceImpl`로 바꾸고 싶을 때 `PostController`의 코드를 직접 수정해야 한다는 것입니다. 각 기능의 독립적인 개발과 테스트가 다시 어려워집니다.

**1. 의존성 주입(DI)과 제어의 역전(IoC)**

이 문제를 해결하는 기술이 바로 **의존성 주입(DI)**입니다. DI의 근간에는 **제어의 역전(Inversion of Control, IoC)**이라는 원리가 있습니다.

*   **기존 방식:** `PostController`가 자신이 사용할 `PostService` 객체를 **직접 생성(제어)**한다.
*   **IoC/DI 방식:** `PostController`는 `PostService` 객체를 생성하지 않는다. 단지 "나는 `PostService` 타입의 객체가 필요해!"라고 선언만 해둔다. 그러면 **외부의 누군가(DI 컨테이너, 예: 스프링 프레임워크)**가 `PostController`에게 필요한 `PostService` 객체를 만들어서 **주입(연결)**해준다. 객체를 생성하고 연결하는 '제어'의 흐름이 개발자 코드에서 프레임워크로 역전된 것입니다.

**2. "동물이 오리로 변하고 강아지로 변한다"는 비유의 해석**

텍스트의 이 비유는 DI의 핵심을 완벽하게 설명합니다.

*   **`동물` (Animal):** 이것이 바로 **인터페이스(Interface)**입니다. `소리를 내다(makeSound())`라는 '기능(메소드)'을 약속(정의)합니다.
*   **`오리`(Duck), `강아지`(Dog):** 이것이 **구현체(Implementation)**입니다. `동물` 인터페이스를 구현하여, `소리를 내다()` 메소드를 `꽤액꽤액` 또는 `멍멍`으로 구체화합니다.
*   **`사육사`(Zookeeper):** `동물`을 필요로 하는 클라이언트 코드(예: `Controller`, `Service`)입니다.

```java
// 인터페이스 (약속)
public interface Animal {
    String makeSound();
}

// 구현체 1
public class Duck implements Animal {
    @Override
    public String makeSound() {
        return "꽤액꽤액";
    }
}

// 구현체 2
public class Dog implements Animal {
    @Override
    public String makeSound() {
        return "멍멍";
    }
}

// 클라이언트 (스프링에서의 예시)
@RestController
public class ZookeeperController {

    private final Animal animal; // '구현체'가 아닌 '인터페이스'에 의존!

    // 생성자를 통해 외부에서 Animal 객체를 주입받음 (DI)
    @Autowired
    public ZookeeperController(Animal animal) {
        this.animal = animal;
    }

    @GetMapping("/sound")
    public String hearSound() {
        // 주입된 객체가 Dog라면 "멍멍", Duck이라면 "꽤액꽤액"이 반환됨
        return animal.makeSound();
    }
}
```

`ZookeeperController`는 `Dog`인지 `Duck`인지 전혀 모릅니다. 단지 `Animal` 인터페이스에 정의된 `makeSound()`를 호출할 뿐입니다. 어떤 동물이 주입될지는 스프링 프레임워크가 설정(Configuration)에 따라 **런타임(실행 시점)**에 결정하여 '동적으로' 연결해줍니다. 이것이 바로 텍스트에서 말한 "인터페이스로 연동하여 기능이 실행되는 런타임에서 인터페이스의 구현체를 주입하는 방식"이며, "동적 생성"의 진정한 의미입니다.

이러한 DI를 통해, 우리는 테스트 시에는 실제 DB에 접근하는 `RealPostRepository` 대신, 메모리에서 가짜 데이터를 반환하는 `MockPostRepository`를 `PostService`에 주입하여 DB 없이도 Service 로직을 완벽하게 테스트할 수 있게 됩니다. 각 계층이 완벽하게 분리되어 독립적인 개발과 테스트가 가능해지는 것입니다.

---

### 결론: 정적인 코드에서 동적인 아키텍처로

모델 1에서 모델 2로의 발전, 그리고 DI의 도입은 단순히 코드를 정리하는 수준을 넘어 개발의 패러다임을 바꾼 혁신입니다.

*   **모델 1:** 모든 것이 얽힌 **정적인 구조**. 변경에 취약하고 재사용이 불가능하며 테스트가 어렵다.
*   **모델 2 (MVC):** 역할과 책임을 분리하여 **느슨한 결합**을 추구. 유지보수성과 재사용성의 기틀을 마련.
*   **모델 2 + DI:** 인터페이스를 통한 의존성 주입으로 결합을 끊어내고 **동적인 구조**를 완성. 각 기능의 완벽한 독립성과 테스트 용이성을 확보하여 유연하고 확장 가능한 시스템을 구축.

"백엔드 개발자는 기본적인 문법의 영적이고 확장적인 기능을 파악하여 정적인 기능을 동쪽으로 유도할 줄 아는 능력이 필요합니다"는 이 모든 과정을 함축합니다. 훌륭한 백엔드 개발자는 단순히 문법에 맞춰 코드를 작성하는 사람이 아닙니다. 변화를 예측하고, 각 기능이 독립적으로 존재하며 서로 유연하게 협력할 수 있는 '구조'를 설계할 줄 아는 사람입니다. 딱딱하게 굳어있는 정적인 코드를, 언제든 다른 부품으로 교체할 수 있는 유연하고 살아있는 동적인 시스템으로 만드는 능력, 이것이 바로 모델 2와 DI가 우리에게 가르쳐주는 핵심 교훈이자 현대 백엔드 개발자가 갖춰야 할 가장 중요한 역량입니다.










--- 

문제

순수 Java 코드(Plain Old Java Object, POJO)로 시작하여 프레임워크 없이 각 개념을 구현해보는 실습입니다.

---

### Stage 1: 모델 1 - 모든 것이 섞여있는 코드

**🎯 목표:** 왜 모델 1 아키텍처가 유지보수에 재앙인지 코드로 직접 경험합니다. 하나의 클래스 안에서 요청 분석, 데이터 처리, 화면 생성이 모두 일어나는 상황의 문제점을 느껴봅니다.

📝 문제:

PostManager라는 클래스를 만드세요. 이 클래스는 main 메소드를 가지고 있으며, 실행하면 게시판 목록을 HTML 문자열 형태로 콘솔에 출력해야 합니다.

**요구사항:**

1. `PostManager` 클래스 안에 게시물 데이터를 `List<Map<String, Object>>` 형태로 하드코딩하여 가지고 있으세요. (DB 연결 흉내)
    
2. 이 데이터를 `<table>` 태그를 사용한 HTML 형식으로 변환하는 로직을 구현하세요.
    
3. 모든 로직(데이터 정의, HTML 생성)은 `main` 메소드 또는 `PostManager` 클래스 내의 private 메소드에 전부 포함되어야 합니다.
    

**🔑 핵심 질문:**

- 만약 테이블의 `<th>` 순서를 바꾸거나 `<td>`에 CSS 클래스를 추가하는 등 **디자인을 변경**하고 싶다면 코드를 얼마나, 어디를 수정해야 하나요?
    
- 게시물 목록 데이터를 HTML이 아닌 **JSON 형식으로도 제공**해야 한다는 새로운 요구사항이 생겼다면 어떻게 해야 할까요? 코드 재사용이 가능한가요?
    

  

---

### Stage 2: 모델 2 (MVC) - 역할의 분리

**🎯 목표:** 모델 1의 문제를 해결하기 위해 '관심사의 분리'를 적용합니다. Controller, Service, View의 역할을 하는 클래스들을 만들어 코드를 분리합니다.

📝 문제:

Stage 1의 PostManager를 Controller, Service, View 역할로 나누어 리팩토링하세요.

**요구사항:**

1. **`PostController`**: 요청을 받는 진입점. `PostService`를 호출하여 데이터를 받고, 받은 데이터를 `PostView`에 넘겨 최종 결과를 받아옵니다.
    
    - `PostController` 내부에 `private PostService postService = new PostServiceImpl();` 와 같이 **서비스 객체를 직접 생성**해야 합니다.
        
2. **`PostService`**: 비즈니스 로직과 데이터 처리를 담당. 게시물 목록 데이터를 `List<Map<String, Object>>` 형태로 반환하는 메소드를 제공합니다. (Stage 1의 데이터 처리 로직을 그대로 가져옵니다)
    
3. **`PostView`**: 데이터를 받아 최종 HTML을 생성하는 역할만 합니다. 로직 없이 데이터를 화면에 그리는 데 집중합니다.
    

**🔑 핵심 질문:**

- 이제 디자인 변경(View 수정)이나 데이터 소스 변경(Service 수정)이 이전보다 쉬워졌나요?
    
- `PostController`가 `PostServiceImpl`을 직접 생성(`new`)하고 있습니다. 만약 테스트를 위해 다른 가짜 `Service` 객체를 사용하고 싶다면, `PostController`의 코드를 수정해야만 하는가요? 이것이 어떤 문제를 일으킬까요? (이것이 바로 **강한 결합(Tight Coupling)** 입니다.)
    

  

---

### Stage 3: DTO 도입 - 명확한 데이터 계약

**🎯 목표:** 모델 2 구조에서 계층 간 데이터를 `Map`이 아닌 DTO(Data Transfer Object)로 주고받도록 개선합니다. '어레이 문제'를 해결하고 타입 안정성을 확보하는 과정을 이해합니다.

📝 문제:

Stage 2의 코드에서 List<Map<String, Object>>를 사용하는 모든 부분을 PostDto를 사용하도록 변경하세요.

**요구사항:**

1. **`PostDto` 클래스**를 생성하세요. `id`, `title`, `writer` 필드와 각 필드에 대한 Getter 메소드를 가져야 합니다.
    
2. **`PostService`**는 이제 `List<PostDto>`를 반환하도록 수정합니다. 내부적으로 `Map`을 `PostDto` 객체로 변환하는 과정이 필요합니다.
    
3. **`PostController`**와 **`PostView`**는 `Map` 대신 `PostDto`를 사용하여 데이터를 처리하고 화면을 생성하도록 수정합니다. `map.get("title")` 대신 `dto.getTitle()`을 사용하게 됩니다.
    

**🔑 핵심 질문:**

- `dto.getTitel()` 처럼 오타를 냈을 때, 컴파일 시점에 오류를 발견할 수 있나요? `Map`을 사용할 때와 비교하여 어떤 점이 좋아졌나요?
    
- DTO를 사용함으로써 `Service`와 `Controller` 사이에 "어떤 형태의 데이터를 주고받을지"에 대한 약속이 명확해졌나요?
    

  

---

### Stage 4: 의존성 주입 (DI) - 궁극의 유연성 확보

**🎯 목표:** 인터페이스를 도입하고 외부에서 의존성을 주입하여 각 컴포넌트 간의 결합을 끊어냅니다. 이를 통해 기능의 교체가 유연해지고 테스트가 쉬워지는 것을 확인합니다.

📝 문제:

Stage 3의 강한 결합 문제를 해결하기 위해 의존성 주입(DI) 원리를 적용하세요.

**요구사항:**

1. **`PostService` 인터페이스**를 만드세요. (`List<PostDto> getPosts()` 메소드 선언)
    
2. 기존 `PostService` 클래스의 이름을 **`PostServiceImpl`**로 바꾸고 `PostService` 인터페이스를 구현(`implements`)하도록 하세요.
    
3. **`PostController`**가 더 이상 `PostServiceImpl`을 직접 생성하지 않도록 수정합니다. 대신 `PostService` 인터페이스 타입의 멤버 변수를 선언하고, **생성자를 통해 외부에서 `PostService` 구현체를 주입**받도록 변경하세요.

    ```    Java
    public class PostController {
        private final PostService postService;
    
        // 생성자를 통해 의존성 주입
        public PostController(PostService postService) {
            this.postService = postService;
        }
        // ...
    }
    ```

4. **`Main` (또는 `Application`) 클래스**를 만들어 **DI 컨테이너**의 역할을 하도록 합니다. 이 클래스가 `PostServiceImpl` 객체를 생성하고, 이 객체를 `PostController`의 생성자에 인자로 넘겨주어 전체 시스템을 조립하고 실행합니다.
    
5. **(심화)** `TestPostServiceImpl`이라는 `PostService`의 또 다른 구현체를 만드세요. 이 클래스는 테스트용 고정 데이터("테스트 제목 1", "테스트 제목 2" 등)를 반환하도록 합니다. `Main` 클래스에서 `PostServiceImpl` 대신 `TestPostServiceImpl`을 주입했을 때, `Controller` 코드를 전혀 바꾸지 않고도 프로그램의 동작이 바뀌는 것을 확인하세요.
    

**🔑 핵심 질문:**

- '사육사(`Controller`)'는 '동물(`Service` 인터페이스)'에게 일을 시킬 뿐, 실제 일하는 동물이 '오리(`ServiceImpl`)'인지 '강아지(`TestServiceImpl`)'인지 더 이상 신경 쓰지 않게 되었습니다. 이로 인해 얻는 가장 큰 이점은 무엇일까요?
    
- 이제 `PostService` 로직만 따로 테스트하는 것이 얼마나 쉬워졌나요? 이것이 바로 **단위 테스트(Unit Test)**의 시작입니다.

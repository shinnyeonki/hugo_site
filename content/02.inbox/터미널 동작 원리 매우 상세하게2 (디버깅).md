---
title: 터미널 동작 원리 매우 상세하게2 (디버깅)
date: 2025-08-11T02:53:22+09:00
lastmod: 2025-08-11T02:53:56+09:00
resource-path: 02.inbox/터미널 동작 원리 매우 상세하게2 (디버깅).md
aliases:
tags:
  - 잡지식
---
각 케이스별로 터미널의 동작을 디버깅하고 특히 **PTY 마스터-슬레이브 간의 통신을 실시간으로 확인하는 방법**

### 디버깅을 위한 핵심 도구 (Toolbox)

우리가 사용할 주요 도구는 다음과 같습니다. 각 도구의 역할을 이해하면 어떤 상황에 무엇을 써야 할지 명확해집니다.

| 도구 | 핵심 기능 | 무엇을 볼 수 있는가? |
| :--- | :--- | :--- |
| **`strace`** | **시스템 콜 추적** | 프로세스(셸, vim)가 커널과 어떤 상호작용을 하는지 (`read`, `write`, `ioctl` 호출 및 주고받는 데이터)를 정확히 보여줍니다. **슬레이브 측 통신 확인에 최적화**되어 있습니다. |
| **`script`** | **터미널 세션 기록** | 터미널 에뮬레이터와 PTY 마스터 사이의 **모든 바이트 스트림(입력/출력)**을 날것 그대로 파일에 기록합니다. **마스터 측 통신 확인에 완벽**합니다. |
| **`socat`** | **만능 데이터 중계기** | 두 개의 통신 채널을 엮고 그 사이를 흐르는 데이터를 엿볼 수 있습니다. PTY를 직접 생성하여 **마스터-슬레이브 양단의 모든 트래픽을 실시간 Hex 덤프로 확인**하는 궁극의 방법입니다. |
| **`lsof`** | **열린 파일 목록 확인** | 특정 프로세스가 어떤 파일 디스크립터(PTY 슬레이브 포함)를 열고 있는지 확인하는 데 사용합니다. |

---

### 실전! 디버깅 시나리오: `strace`로 셸(Slave) 관찰하기

이 방법은 **셸(bash)이 PTY 슬레이브와 어떻게 상호작용하는지**를 가장 직접적으로 보여줍니다.

#### 1단계: 환경 준비

두 개의 터미널 창을 엽니다.

*   **터미널 1 (실행용):** 우리가 `ls`, `Ctrl+C` 등을 입력할 터미널입니다.
*   **터미널 2 (관찰용):** `strace`를 실행하여 터미널 1의 셸을 감시할 터미널입니다.

#### 2단계: 추적 대상 찾기

1.  **터미널 1**에서 다음을 입력하여 현재 셸의 프로세스 ID(PID)와 PTY 슬레이브 장치 파일을 확인합니다.

    ```bash
    # 현재 셸의 PID 확인
    echo $$
    # 출력 예시: 24567

    # 현재 터미널의 PTY 슬레이브 장치 파일 확인
    tty
    # 출력 예시: /dev/pts/3
    ```

2.  이제 우리는 PID `24567`를 가진 `bash` 프로세스가 `/dev/pts/3`을 통해 통신한다는 것을 알았습니다.

#### 3단계: `strace` 실행

**터미널 2 (관찰용)**에서 다음 명령을 실행하여 터미널 1의 셸에 `strace`를 붙입니다. `sudo`가 필요할 수 있습니다.

```bash
# -p [PID]: 특정 프로세스에 연결
# -e trace=read,write,ioctl: read, write, ioctl 시스템 콜만 추적
# -s 100: 문자열 데이터는 최대 100자까지 표시
# -xx: 문자열이 아닌 데이터는 Hex(16진수)로 표시
sudo strace -p 24567 -e trace=read,write,ioctl -s 100 -xx
```

이제 `strace`가 터미널 1의 셸을 감시하기 시작합니다. `strace`는 `read(0, ...)`와 같이 셸이 입력을 기다리며 멈춰있을 겁니다. (여기서 FD `0`은 셸의 표준 입력, 즉 `/dev/pts/3` 입니다.)

#### 4단계: 케이스별 관찰 (터미널 1에서 입력)

이제 **터미널 1**에서 여러 가지 입력을 해보고 **터미널 2**에 나타나는 `strace` 출력을 관찰합시다.

---

**▶️ Case 1: `ls`를 입력하고 Enter**

1.  **터미널 1:** `l`, `s`, `Enter`를 차례로 입력합니다.
2.  **터미널 2 (`strace` 출력):**

    ```
    # 커널의 라인 버퍼링 때문에 'ls'와 '\n'이 한번에 전달됨
    read(0, "ls\n", 100)                     = 3
    # ... fork, execve("ls") 등 ...
    # ls의 결과가 PTY 슬레이브를 통해 터미널 에뮬레이터로 출력됨
    write(1, "Desktop    Downloads    Music\n", 28) = 28
    # 셸 프롬프트가 다시 출력됨
    write(2, "$ ", 2)                        = 2
    ```

    *   **핵심 관찰:** `l`이나 `s`를 입력할 때는 `read`가 호출되지 않습니다. 커널(TTY 드라이버)이 `Enter`가 올 때까지 버퍼링하다가 `ls\n`을 한 번에 셸에게 전달합니다. **이것이 `cooked` 모드의 증거입니다.**

---

**▶️ Case 2: 입력 중 `Backspace` 사용**

1.  **터미널 1:** `l`, `p`, `Backspace`, `s`, `Enter`를 입력합니다.
2.  **터미널 2 (`strace` 출력):**

    ```
    read(0, "ls\n", 100)                     = 3
    ```

    *   **핵심 관찰:** `strace` 결과는 Case 1과 **완전히 동일**합니다. 셸은 `p`를 입력했는지, `Backspace`로 지웠는지 전혀 모릅니다. 커널의 TTY 드라이버가 입력 편집을 모두 처리하고 최종 결과인 `ls\n`만 셸에게 전달했기 때문입니다.

---

**▶️ Case 3: `Ctrl+C` 누르기**

1.  **터미널 1:** `sleep 100`을 실행한 뒤, 바로 `Ctrl+C`를 누릅니다.
2.  **터미널 2 (`strace` 출력):**

    ```
    # sleep 100 실행 부분 생략 ...
    # Ctrl+C를 누르면, 셸은 0x03 바이트를 read 하는 것이 아니라,
    # SIGINT 시그널을 받는다!
    --- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
    # 시그널을 받은 후, 셸은 다시 프롬프트를 찍는다.
    write(2, "\n", 1)                         = 1
    write(2, "$ ", 2)                         = 2
    read(0,
    ```

    *   **핵심 관찰:** `read` 시스템 콜로 `0x03` 바이트가 들어오는 것이 아니라, `--- SIGINT ---` 라는 메시지가 뜹니다. 이는 커널이 `Ctrl+C`에 해당하는 바이트를 해석하여 셸 프로세스에 **`SIGINT` 시그널을 보냈음**을 명확히 보여줍니다.

---

**▶️ Case 5: `vim` 실행 (Raw 모드)**

1.  **터미널 1:** `vim`을 실행합니다.
2.  **터미널 2 (`strace` 출력):**

    ```
    # vim이 시작하자마자 터미널 설정을 바꾸기 위해 ioctl을 호출한다.
    # TCSETSW는 "지금 바로 설정을 바꿔라"는 의미.
    # c_lflag에서 ICANON(Canonical 모드), ECHO(에코) 등이 꺼진 것을 볼 수 있음.
    ioctl(0, TCSETSW, {c_iflag=ICRNL|IXON, c_oflag=OPOST|ONLCR, c_cflag=B38400|CS8|CREAD, c_lflag=ISIG|IEXTEN, ...})
    # 화면을 그리기 위해 수많은 이스케이프 시퀀스를 write 한다.
    write(1, "\33[?2004h\33[?1049h\33[22;0;0t\33[1;24r\33[m\33[H\33[2J...", 200) = 200
    ```

3.  **터미널 1 (vim 내부):** `j` 키를 한 번 눌러 커서를 아래로 이동합니다.
4.  **터미널 2 (`strace` 출력):**

    ```
    # Raw 모드이므로 'j' 키를 누르자마자 read가 즉시 반환됨.
    read(0, "j", 16)                        = 1
    # vim은 'j' 입력에 대한 반응으로, 커서를 이동시키는 이스케이프 시퀀스를 출력.
    write(1, "\33[11;5H", 6)                     = 6
    ```

    *   **핵심 관찰:**
        *   `ioctl` 호출로 터미널이 `raw` 모드로 변경되는 것을 확인했습니다.
        *   `j` 키 하나를 누르자마자 `read`가 바로 반환됩니다. **라인 버퍼링이 꺼졌다는 증거입니다.**
        *   `vim`은 커서 이동 같은 간단한 동작조차 이스케이프 시퀀스를 `write`하여 직접 처리합니다.

---

### 심화 과정: `script`로 마스터 측 통신 훔쳐보기

`strace`는 셸(슬레이브) 관점의 훌륭한 도구지만, 커널이 편집해주는 `Backspace`나 에뮬레이터가 보내는 화살표 키의 실제 바이트는 볼 수 없습니다. 이때 `script`를 사용합니다.

1.  **터미널 1**에서 다음을 실행합니다.

    ```bash
    # -t 옵션은 시간 정보를 timing.log에 기록
    # session.log 파일에 모든 바이트 스트림을 기록
    script -t timing.log session.log
    ```

2.  이제 `script`가 새로운 셸을 실행시키고, 이 세션에서 일어나는 모든 입출력을 기록하기 시작합니다. 여기서 다음을 순서대로 입력해보세요.
    *   `l`, `p`, `Backspace`, `s`, `Enter`
    *   `위쪽 화살표(↑)` 키
    *   `Ctrl+C`
    *   `exit` 를 입력하여 `script` 종료

3.  이제 `session.log` 파일을 `hexdump`로 열어보면 날것 그대로의 데이터가 보입니다.

    ```bash
    hexdump -C session.log
    ```

    아마 다음과 유사한 내용을 볼 수 있을 겁니다.

    ```
    # ... 프롬프트 ...
    # 'l', 'p', 'Backspace', 's', '\r' (Enter)
    6c 70 08 73 0d
    # 'Backspace'에 대한 커널의 화면 수정 응답: \b \b
    08 20 08
    # ... ls 결과 ...
    # 위쪽 화살표 키 입력
    1b 5b 41
    # 셸이 히스토리를 찾아 화면에 그려주는 응답
    0d 1b 5b 4b 6c 73 ...
    # Ctrl+C 입력
    03
    # ... exit 입력 ...
    ```

    *   **핵심 관찰:**
        *   사용자가 누른 `Backspace`(`0x08`)와 화살표 키(`1b 5b 41`)가 PTY 마스터에 기록된 것을 볼 수 있습니다. `strace`로는 볼 수 없었던 정보입니다.
        *   `scriptreplay timing.log session.log` 명령으로 당시 상황을 영상처럼 다시 재생해볼 수도 있습니다.

### 끝판왕: `socat`으로 실시간 양방향 트래픽 감시하기

이 방법은 가장 복잡하지만 마스터와 슬레이브 사이를 오가는 모든 데이터를 실시간으로 보여줍니다.

1.  **터미널 2 (관찰용)**에서 `socat`으로 가짜 PTY를 생성하고 중간에서 데이터를 감시합니다.

    ```bash
    # 두 개의 PTY 쌍을 만들고, 그 사이를 오가는 모든 데이터를 hex(-x)로 출력
    # 터미널 1은 /tmp/my-pty1에, 터미널 2의 셸은 /tmp/my-pty2에 연결될 것임
    socat -d -d -x PTY,link=/tmp/my-pty1,raw,echo=0 PTY,link=/tmp/my-pty2,raw,echo=0
    ```

2.  이제 **새 터미널(터미널 3)**을 열고, 셸을 PTY 슬레이브 쪽에 연결합니다.

    ```bash
    # stty raw -echo: 이 터미널 자체의 cooked 모드를 꺼서 socat에 방해되지 않게 함
    # exec bash < /tmp/my-pty2 > /tmp/my-pty2 2>&1: bash의 입출력을 PTY 슬레이브로 리다이렉션
    stty raw -echo; exec bash < /tmp/my-pty2 > /tmp/my-pty2 2>&1
    ```

3.  **터미널 1**에서는 터미널 에뮬레이터 역할을 할 프로그램을 PTY 마스터 쪽에 연결합니다. `socat`을 또 사용하면 편리합니다.

    ```bash
    socat - "file:/tmp/my-pty1,raw,echo=0"
    ```

이제 **터미널 1**에서 키보드를 입력하면, 그 데이터가 **터미널 2**의 `socat` 감시 화면에 보이고, 처리된 결과가 **터미널 3**의 `bash`로 전달됩니다. `bash`의 출력 역시 **터미널 2**를 거쳐 **터미널 1**에 보이게 됩니다. 이로써 완벽한 Man-in-the-middle 감시 환경이 구축되었습니다.

이 방법을 통해 제공해주신 문서의 모든 데이터 흐름도를 눈으로 직접 확인할 수 있습니다.
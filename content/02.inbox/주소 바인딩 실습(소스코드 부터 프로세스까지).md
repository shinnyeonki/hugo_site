---
title: 주소 바인딩 실습(소스코드 부터 프로세스까지)
aliases: 
tags:
  - operating-system
created: 2025-05-29T06:39:00+09:00
modified: 2025-06-03T05:44:08+09:00

---
##  주소 바인딩(Address Binding) 과정 심층 분석

### 1. 주소 바인딩의 개념과 목적

**주소 바인딩(Address Binding)**이란 프로그램의 소스 코드에 사용된 변수나 함수 같은 심볼릭 주소(Symbolic Address)가 실제 물리 메모리(Physical Memory)의 주소로 변환되는 전체 과정을 의미합니다. 이 과정은 컴퓨터가 프로그램을 실행하기 위한 핵심적인 메커니즘입니다.

#### 목적

- **재배치(Relocation)**: 프로그램을 메모리의 어느 위치에든 적재하여 실행할 수 있도록 합니다. 만약 주소가 고정되어 있다면 여러 프로그램을 동시에 실행하기 어렵습니다.
- **메모리 보호(Memory Protection)**: 각 프로세스가 자신에게 할당된 메모리 영역만 접근하도록 격리하여 시스템의 안정성을 높입니다.
- **메모리 효율성 증대**: 가상 메모리(Virtual Memory), 공유 라이브러리(Shared Library) 등의 기법을 통해 한정된 물리 메모리를 여러 프로세스가 효율적으로 나누어 사용할 수 있게 합니다.

본 문서는 리눅스 CLI 환경에서 제공하는 다양한 도구를 활용하여, **컴파일 → 링크 → 적재 → 실행** 각 단계에서 주소 바인딩이 어떻게 이루어지는지 구체적인 명령과 출력을 통해 심층적으로 추적하고 분석하는 것을 목표로 합니다.

---

### 2. 실습 환경 구성

실습을 위해 간단한 C 코드를 작성합니다. 이 코드는 전역 변수, 함수 등을 포함하여 각 단계별 변화를 관찰하기에 용이합니다.

#### 예제 코드 (`addr_test.c`)

```c
#include <stdio.h>

int initialized_global_var = 10;
int uninitialized_global_var;
const int const_global_var = 20;

void function(void) {
    printf("Function address\n");
}

int main(void) {
    static int static_local_var = 30;
    int local_var = 40;

    function();
    printf("Address of initialized_global_var: %p\n", &initialized_global_var);
    printf("Address of main function: %p\n", main);

    return 0;
}
```

---

### 3. 1단계: 컴파일 시간 바인딩 (Compile-Time Binding)

**목표**: 소스 코드의 심볼릭 주소(변수명, 함수명)가 컴파일러에 의해 **재배치 가능한(Relocatable) 주소**로 변환되는 과정을 확인합니다. 이 주소는 각 오브젝트 파일(`.o`) 내에서의 상대적인 오프셋(offset)입니다.

#### 1. 오브젝트 파일 생성

`gcc`의 `-c` 옵션은 링킹을 수행하지 않고 컴파일만 진행하여 오브젝트 파일을 생성합니다.

Bash

```
gcc -c addr_test.c -o addr_test.o
```

#### 2. 심볼 테이블 분석 (`nm`)

`nm` 도구는 오브젝트 파일의 심볼 테이블을 보여줍니다. 이를 통해 각 심볼이 어떤 섹션에, 어떤 상대 주소로 할당되었는지 확인할 수 있습니다.

```bash
nm addr_test.o
```

**출력 예시 및 분석**:

```bash
000000000000001e T function
0000000000000000 D initialized_global_var
0000000000000035 T main
                 U printf
0000000000000004 C uninitialized_global_var
...
```

- **주소**: `0x00...`으로 시작하는 이 값들은 최종 메모리 주소가 아닌, 파일 내의 **상대 주소(오프셋)**입니다.
- **심볼 타입**:
    - `T`: `.text` 섹션(코드)에 위치한 심볼. `main`, `function` 함수가 해당됩니다.
    - `D`: `.data` 섹션(초기화된 데이터)에 위치한 심볼. `initialized_global_var`가 해당됩니다.
    - `C`: Common 심볼. 초기화되지 않은 전역 변수(`uninitialized_global_var`)로, 크기만 명시되고 최종 위치는 링커가 결정합니다.
    - `U`: Undefined. 이 파일 내에 정의되지 않은 심볼로, `printf`처럼 외부 라이브러리에서 가져와야 함을 의미합니다.

#### 3. 섹션별 상세 분석 (`objdump`)

`objdump -d`는 코드 섹션(`.text`)을 디스어셈블하여 명령어 수준에서 상대 주소를 보여줍니다.

```bash
objdump -d addr_test.o
```

> 출력된 어셈블리 코드에서 `call`이나 `mov` 명령어의 대상 주소가 `0` 또는 상대적인 값으로 표시된 것을 볼 수 있습니다. 이는 링커가 채워주어야 할 부분입니다.

---

### 4. 2단계: 링크 시간 바인딩 (Link-Time Binding)

**목표**: 링커가 여러 오브젝트 파일과 라이브러리를 결합하여 **단일 실행 파일**을 만드는 과정을 확인합니다. 이 과정에서 재배치 가능 주소는 프로그램의 **가상 주소 공간(Virtual Address Space)** 내의 **절대 주소(Absolute Address)**로 확정됩니다.

#### 1. 실행 파일 생성

오브젝트 파일을 링킹하여 실행 파일을 생성합니다. 이 과정에서 `printf` 같은 외부 함수의 주소도 연결됩니다.

```bash
gcc addr_test.o -o addr_test
```

#### 2. 실행 파일의 심볼 주소 확인 (`readelf`)

`readelf -s`는 ELF(Executable and Linkable Format) 형식 파일의 심볼 테이블을 더 상세히 보여줍니다.

```bash
readelf -s ./addr_test | grep 'main\|function\|initialized'
```

**출력 예시 및 분석**:

```bash
  38: 0000000000004030     4 OBJECT  GLOBAL DEFAULT   15 initialized_global_var
  63: 0000000000001159    26 FUNC    GLOBAL DEFAULT   14 function
  69: 0000000000001173    69 FUNC    GLOBAL DEFAULT   14 main
```

- 이제 주소(`0x4030`, `0x1159` 등)는 `0`이 아닌, **가상 메모리 주소**로 확정되었습니다.
- 이 주소는 프로세스가 시작될 때 할당될 논리적인 주소이며, 모든 심볼이 고유한 가상 주소를 갖게 됩니다.

---

### 5. 3단계: 적재 시간 바인딩 (Load-Time Binding)

**목표**: 운영체제(OS)의 로더(Loader)가 실행 파일을 메모리에 올릴 때, 프로그램의 각 세그먼트(코드, 데이터 등)가 프로세스의 가상 주소 공간에 어떻게 매핑되는지 확인합니다.

#### 1. 프로세스 실행 및 PID 확인

프로세스를 백그라운드로 실행하고 해당 PID(Process ID)를 변수에 저장합니다.

```bash
./addr_test &
PID=$!
```

#### 2. 프로세스 메모리 맵 확인 (`pmap`)

`pmap`은 특정 프로세스의 메모리 맵을 보여주는 강력한 도구입니다.

```bash
pmap $PID
```

**출력 예시 및 분석**:

```bash
000055a3d0ab4000      4K r-xp /path/to/addr_test  <-- Code (.text)
000055a3d0acb000      4K r--p /path/to/addr_test  <-- Read-only data
000055a3d0acc000      4K rw-p /path/to/addr_test  <-- Read-write data (.data, .bss)
...
00007ffc8d9e8000    132K rw-p [stack]              <-- Stack
...
```

- **첫 번째 열**: 각 메모리 영역의 **시작 가상 주소**입니다.
- **ASLR (Address Space Layout Randomization)** 때문에 프로그램을 실행할 때마다 이 시작 주소는 변경될 수 있습니다. `readelf`에서 본 오프셋은 유지된 채, 전체적인基底 주소(Base Address)가 바뀌는 것입니다.

#### 3. `/proc` 파일 시스템으로 확인

`/proc/<PID>/maps` 파일은 `pmap`보다 더 상세한 정보를 제공합니다.

```bash
cat /proc/$PID/maps
```

> 출력 형식은 `pmap`과 유사하지만, 파일 오프셋, 디바이스/inode 정보 등 더 많은 세부 정보를 포함합니다. 이 파일을 통해 코드, 데이터, 스택, 힙 및 동적 라이브러리가 가상 주소 공간에 어떻게 배치되었는지 명확히 볼 수 있습니다.

---

### 6. 4단계: 실행 시간 바인딩 (Execution-Time Binding)

**목표**: 프로그램이 실제로 실행되는 동안 **MMU(Memory Management Unit)** 하드웨어가 가상 주소를 물리 주소로 동적으로 변환하는 개념을 간접적으로 확인합니다. 현대 OS는 대부분 이 방식을 사용합니다.

#### 1. 페이지 폴트(Page Fault) 관찰 (`perf`)

가상 주소가 처음 접근될 때, 해당 데이터가 물리 메모리에 없다면 **페이지 폴트**가 발생합니다. 이때 OS는 디스크에서 데이터를 물리 메모리로 가져오고 페이지 테이블을 업데이트합니다. 이것이 바로 실행 시간 바인딩의 핵심 순간입니다.

```bash
# -e page-faults 옵션으로 페이지 폴트 이벤트 카운팅
perf stat -e page-faults ./addr_test
```

**출력 예시**:

```
 Address of initialized_global_var: 0x55d8b2f9a030
 Address of main function: 0x55d8b2f98173

 Performance counter stats for './addr_test':

               105      page-faults

       0.001099684 seconds time elapsed
```

> `105`개의 페이지 폴트가 발생했음을 보여줍니다. 이는 프로그램 실행에 필요한 코드/데이터 페이지가 실행 시점에 동적으로 물리 메모리에 바인딩되었음을 의미합니다.

#### 2. 가상 주소 → 물리 주소 매핑 확인 (`pagemap`, 고급)

`/proc/<PID>/pagemap` 파일은 각 가상 페이지에 대한 물리 페이지 프레임 번호(PFN) 정보를 담고 있습니다. 이를 통해 최종적인 가상-물리 주소 매핑을 직접 확인할 수 있지만, 루트 권한이 필요하며 파싱이 복잡합니다. 이는 주소 변환의 가장 낮은 수준을 보여주는 증거입니다.

관심 있는 사용자는 [kernel.org의 pagemap 문서](https://www.kernel.org/doc/Documentation/vm/pagemap.txt)를 참조하여 직접 스크립트를 작성해볼 수 있습니다.

---

### 7. 전체 과정 요약


| **바인딩 단계** | **목적**                | **핵심 도구**                             | **주소의 상태**                              |
| ---------- | --------------------- | ------------------------------------- | --------------------------------------- |
| **컴파일 시간** | 심볼릭 주소를 상대 주소로 변환     | `gcc -c`, `nm`, `objdump`             | **재배치 가능 주소 (Relocatable Address)**     |
| **링크 시간**  | 여러 오브젝트를 묶어 가상 주소 결정  | `gcc`, `readelf -s`                   | **절대 가상 주소 (Absolute Virtual Address)** |
| **적재 시간**  | 실행 파일을 프로세스 가상 공간에 매핑 | `pmap`, `/proc/PID/maps`              | **가상 메모리 주소 (Mapped Virtual Address)**  |
| **실행 시간**  | MMU가 가상 주소를 물리 주소로 변환 | MMU (HW), `perf`, `/proc/PID/pagemap` | **물리 주소 (Physical Address)**            |
---
title: 무제 6
date: 2025-07-17T21:27:20+09:00
lastmod: 2025-07-17T23:50:34+09:00
resource-path: 무제 6.md
aliases: 
tags: 
---
네, 직접 매우 단순한 WSGI 애플리케이션과 이를 실행할 수 있는 매우 단순한 WSGI 서버를 만들어 보겠습니다. 이를 통해 WSGI 인터페이스가 어떻게 동작하는지 직관적으로 이해할 수 있을 겁니다.

---

## WSGI의 핵심 원리: Callable(호출 가능한 객체)

WSGI의 가장 중요한 부분은 "애플리케이션"이 `application(environ, start_response)` 이라는 시그니처를 가진 **호출 가능한 객체(callable)**여야 한다는 것입니다.

*   `environ`: 웹 서버로부터 받은 요청 정보(HTTP 헤더, 경로, 쿼리 파라미터 등)를 담은 딕셔너리입니다.
*   `start_response`: 애플리케이션이 웹 서버에게 HTTP 응답 상태 코드(예: "200 OK")와 응답 헤더를 보내기 위해 호출해야 하는 함수입니다. 웹 서버가 이 함수를 제공합니다.

애플리케이션은 이 두 인자를 받아 처리하고, 응답 본문(body)을 포함하는 **이터러블(iterable)** 객체를 반환해야 합니다.

---

## 1. 매우 단순한 WSGI 애플리케이션 (`my_simple_app.py`)

이것은 우리가 만들 웹 "애플리케이션"입니다. 웹 프레임워크 없이 순수 WSGI 규약에 맞춰 작성됩니다.

```python
# my_simple_app.py

import sys

def my_simple_app(environ, start_response):
    """
    이것은 WSGI 규약을 따르는 매우 단순한 웹 애플리케이션입니다.

    Args:
        environ (dict): 웹 서버로부터 받은 요청 정보(환경 변수).
                        예: 'REQUEST_METHOD', 'PATH_INFO', 'QUERY_STRING' 등
                        'wsgi.input', 'wsgi.errors' 등 WSGI 관련 정보도 포함.
        start_response (callable): 서버가 제공하는 함수로, 애플리케이션이
                                  HTTP 응답 상태 코드와 헤더를 서버에 전달할 때 사용합니다.
                                  시그니처: start_response(status, headers, exc_info=None)
    Returns:
        iterable: 응답 본문(body)을 포함하는 바이트 문자열의 이터러블.
    """
    status = '200 OK'  # HTTP 상태 코드
    headers = [
        ('Content-type', 'text/plain; charset=utf-8'),
        ('X-Powered-By', 'MySimpleWSGIApp') # 커스텀 헤더도 가능
    ]

    # start_response 함수를 호출하여 상태 코드와 헤더를 서버에게 전달합니다.
    start_response(status, headers)

    # 요청 경로를 확인하여 다른 응답을 줄 수 있습니다.
    path = environ.get('PATH_INFO', '/')
    if path == '/':
        response_body = b"Hello from My Simple WSGI App! (Homepage)\n"
    elif path == '/hello':
        response_body = b"Hello, specific page!\n"
    elif path == '/info':
        response_body = b"Environment info:\n"
        # environ 딕셔너리의 내용을 응답 본문에 추가
        for key, value in sorted(environ.items()):
            response_body += f"{key}: {value}\n".encode('utf-8')
    else:
        status = '404 Not Found'
        headers = [('Content-type', 'text/plain; charset=utf-8')]
        start_response(status, headers) # 404 상태로 다시 호출
        response_body = b"404 Not Found: This page does not exist.\n"

    # 응답 본문은 바이트 문자열의 이터러블이어야 합니다.
    # 단순화를 위해 여기서는 하나의 바이트 문자열을 리스트에 담아 반환합니다.
    return [response_body]

# 이 파일이 직접 실행될 경우 (예: 개발 서버용)
if __name__ == '__main__':
    # 이 부분은 실제 WSGI 서버(Gunicorn, uWSGI)가 하는 일을 매우 간소화한 것입니다.
    # 실제 서버가 애플리케이션을 로드하여 실행합니다.
    print("This is a WSGI application module. It needs a WSGI server to run.")
    print("Try running `python simple_wsgi_server.py` and access http://localhost:8000/")
```

---

## 2. 매우 단순한 WSGI 서버 (`simple_wsgi_server.py`)

이것은 클라이언트의 HTTP 요청을 받아 우리 `my_simple_app` WSGI 애플리케이션을 호출하고, 그 결과를 클라이언트에게 다시 HTTP 응답으로 보내는 역할을 하는 서버입니다. 실제 Gunicorn이나 uWSGI와 비교할 수 없을 정도로 단순하며, 한 번에 하나의 요청만 처리합니다.

```python
# simple_wsgi_server.py

import socket
import sys
import os # PATH_INFO에 필요한 모듈

# 우리가 만든 WSGI 애플리케이션을 임포트합니다.
from my_simple_app import my_simple_app

class SimpleWSGIServer:
    def __init__(self, host, port, application):
        self.host = host
        self.port = port
        self.application = application
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 개발 시 재시작할 때 주소가 이미 사용 중인 문제를 방지
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    def serve_forever(self):
        self.socket.bind((self.host, self.port))
        self.socket.listen(1) # 한 번에 하나의 연결만 대기
        print(f"Serving WSGI app on http://{self.host}:{self.port}/...")
        print("Try accessing /hello, /info, or /nonexistent_page")

        while True:
            client_connection, client_address = self.socket.accept()
            print(f"Accepted connection from {client_address}")
            self.handle_request(client_connection)

    def handle_request(self, client_connection):
        # 1. 클라이언트 요청 데이터 수신 및 파싱
        request_data = client_connection.recv(1024).decode('utf-8')
        request_lines = request_data.split('\r\n')
        if not request_lines:
            client_connection.close()
            return

        request_line = request_lines[0]
        try:
            method, path, version = request_line.split(' ')
        except ValueError:
            # 유효하지 않은 요청 라인 처리
            client_connection.sendall(b"HTTP/1.1 400 Bad Request\r\n\r\nBad Request")
            client_connection.close()
            return

        # 2. `environ` 딕셔너리 생성 (매우 간소화된 버전)
        # 실제 WSGI 서버는 이 딕셔너리를 훨씬 더 풍부하게 채웁니다.
        environ = {
            'REQUEST_METHOD': method,
            'PATH_INFO': path.split('?')[0], # 쿼리 스트링 분리
            'QUERY_STRING': path.split('?')[1] if '?' in path else '',
            'SERVER_NAME': self.host,
            'SERVER_PORT': str(self.port),
            'SERVER_PROTOCOL': version,
            'wsgi.version': (1, 0),
            'wsgi.url_scheme': 'http',
            'wsgi.input': client_connection.makefile('rb', -1), # 요청 본문 스트림 (여기에선 사용 안함)
            'wsgi.errors': sys.stderr, # 에러 로그 스트림
            'wsgi.multithread': False, # 이 서버는 단일 쓰레드
            'wsgi.multiprocess': False, # 이 서버는 단일 프로세스
            'wsgi.run_once': False, # 계속 실행됨
        }

        # 3. `start_response` 콜러블 정의
        # 이 함수는 애플리케이션이 호출하여 응답 상태 및 헤더를 서버에게 알려줍니다.
        headers_set = [] # 애플리케이션이 설정할 상태 및 헤더를 저장할 리스트
        response_started = False

        def start_response(status, headers, exc_info=None):
            nonlocal response_started
            if response_started:
                raise RuntimeError("start_response() already called!")
            response_started = True

            headers_set.append(status)
            headers_set.extend(headers)

            # exc_info는 에러 처리 시 사용되지만, 여기서는 생략합니다.
            # print(f"[Server] App called start_response: Status={status}, Headers={headers}")
            return None # WSGI 스펙에 따라 None 반환

        # 4. WSGI 애플리케이션 호출
        try:
            app_body_iterable = self.application(environ, start_response)

            # 5. HTTP 응답 구성 및 전송
            response_status = headers_set[0]
            response_headers = headers_set[1:]

            response_line = f"HTTP/1.1 {response_status}\r\n"
            response_headers_str = ""
            for header_name, header_value in response_headers:
                response_headers_str += f"{header_name}: {header_value}\r\n"
            
            # 최종 헤더
            full_response_headers = (response_line + response_headers_str + "\r\n").encode('utf-8')
            client_connection.sendall(full_response_headers)

            # 애플리케이션이 반환한 이터러블로부터 본문을 읽어 전송
            for data in app_body_iterable:
                client_connection.sendall(data) # data는 이미 바이트 문자열이어야 합니다.

        except Exception as e:
            # 애플리케이션 내부에서 발생한 예상치 못한 오류 처리
            print(f"Error handling request: {e}", file=sys.stderr)
            error_response = b"HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\n\r\nInternal Server Error"
            client_connection.sendall(error_response)
        finally:
            # 요청 처리 완료 후 클라이언트 연결 닫기
            client_connection.close()
            print(f"Connection from {client_address} closed.")

# 서버 실행
if __name__ == '__main__':
    HOST = '127.0.0.1' # localhost
    PORT = 8000

    server = SimpleWSGIServer(HOST, PORT, my_simple_app)
    server.serve_forever()
```

---

## 실행 방법

1.  위 코드들을 각각 `my_simple_app.py`와 `simple_wsgi_server.py` 파일로 저장합니다.
2.  터미널을 열고 `simple_wsgi_server.py` 파일이 있는 디렉토리로 이동합니다.
3.  다음 명령어를 실행합니다:

    ```bash
    python simple_wsgi_server.py
    ```

4.  콘솔에 "Serving WSGI app on http://127.0.0.1:8000/..." 메시지가 나타나면, 웹 브라우저를 열고 다음 주소들을 방문해 보세요:
    *   `http://127.0.0.1:8000/`
    *   `http://127.0.0.1:8000/hello`
    *   `http://127.0.0.1:8000/info` (environ 딕셔너리 내용을 볼 수 있습니다)
    *   `http://127.0.0.1:8000/nonexistent_page` (404 에러를 확인)

---

## 코드 설명 및 WSGI 이해

이 예제를 통해 WSGI의 핵심을 이해할 수 있습니다:

1.  **애플리케이션(App)과 서버(Server)의 분리:**
    *   `my_simple_app.py`는 오직 WSGI 규약에 맞춰 `application`이라는 함수를 구현합니다. 이 함수는 HTTP 요청/응답에 대한 지식은 거의 없고, 오직 `environ` 딕셔너리와 `start_response` 함수를 다루는 방법만 압니다.
    *   `simple_wsgi_server.py`는 HTTP 프로토콜(소켓 통신, 요청 파싱, 응답 전송)을 처리하고, `my_simple_app`을 호출하기 위한 `environ`과 `start_response`를 준비합니다.
    *   이러한 분리 덕분에, 개발자는 `my_simple_app`과 같은 WSGI 애플리케이션을 한 번 작성하면, 어떤 WSGI 호환 서버(Gunicorn, uWSGI 등)에서도 실행할 수 있습니다. 반대로, 서버 개발자는 어떤 WSGI 호환 애플리케이션이라도 실행할 수 있습니다.

2.  **`environ` 딕셔너리:**
    *   서버는 클라이언트의 HTTP 요청을 파싱하여 다양한 정보를 `environ` 딕셔너리에 담아 애플리케이션에 전달합니다. `PATH_INFO`, `REQUEST_METHOD`, `QUERY_STRING` 등이 대표적입니다.
    *   또한 `wsgi.version`, `wsgi.input` (요청 본문을 읽기 위한 파일 객체), `wsgi.errors` (에러 로그를 위한 파일 객체)와 같은 WSGI 자체의 환경 변수도 포함됩니다.

3.  **`start_response` 콜러블:**
    *   애플리케이션은 응답 본문을 반환하기 전에 반드시 이 `start_response` 함수를 호출해야 합니다. 이 호출을 통해 서버는 HTTP 상태 코드(예: "200 OK")와 응답 헤더(예: `Content-Type`)를 알게 되고, 실제 응답의 첫 부분을 클라이언트에게 보낼 준비를 합니다.

4.  **반환 값: 이터러블 본문:**
    *   애플리케이션은 응답 본문을 바이트 문자열의 이터러블로 반환합니다. 이 예제에서는 `[b"Hello..."]`와 같이 하나의 리스트에 담았지만, 큰 파일 전송의 경우 제너레이터를 사용하여 메모리 효율적으로 데이터를 스트리밍할 수도 있습니다.

이 간단한 예제를 통해 WSGI가 웹 서버와 Python 웹 애플리케이션 사이에 어떻게 표준화된 인터페이스 역할을 하는지 이해할 수 있을 것입니다. 실제 Gunicorn 같은 WSGI 서버는 이 기본적인 원리 위에 멀티프로세싱/멀티스레딩, 로깅, 설정 관리 등 훨씬 더 복잡한 기능들을 추가하여 프로덕션 환경에 적합하도록 만듭니다.
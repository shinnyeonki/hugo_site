---
title: 코어 덤프(Core Dump)
resource-path: 코어 덤프(Core Dump).md
keywords:
tags:
  - ai-content
  - system-programing
date: 2025-09-09T23:13:33+09:00
lastmod: 2025-10-19T16:12:19+09:00
---
## 코어 덤프(Core Dump)란 무엇인가? - "프로세스의 마지막 순간을 담은 사진"

코어 덤프(Core Dump)는 프로그래밍과 시스템 관리에서 매우 중요한 개념입니다. 가장 쉽게 비유하자면, **코어 덤프는 특정 프로그램(프로세스)이 비정상적으로 종료되는 바로 그 순간의 메모리 상태를 그대로 찍어 저장한 "스냅샷 파일"**입니다. 마치 비행기 사고 시 원인 분석을 위해 블랙박스를 회수하는 것과 같습니다.

### 1. "코어(Core)" 라는 이름의 유래

이름이 조금 생소할 수 있습니다. "코어"라는 단어는 현대의 CPU 코어를 의미하는 것이 아닙니다. 이는 아주 오래전, 컴퓨터의 주기억장치로 **자기 코어 메모리(Magnetic Core Memory)**를 사용하던 시절에서 유래했습니다. 당시 메모리의 내용을 파일로 '쏟아낸다(dump)'는 의미에서 '코어 덤프'라는 용어가 탄생했고, 메모리 기술이 반도체로 바뀐 지금까지도 그 이름이 그대로 사용되고 있습니다.

---

### 2. 코어 덤프는 언제 생성되나요?

코어 덤프는 주로 프로그램이 심각한 오류를 만나 더 이상 실행을 계속할 수 없을 때, 운영체제(커널)에 의해 생성됩니다. 앞서 살펴본 신호(Signal) 목록에서 **"Default Action"이 `create core image` 또는 `Core`로 표시된 신호**를 받았을 때가 바로 그 경우입니다.

대표적인 예시는 다음과 같습니다.

*   **`SIGSEGV` (Segmentation Violation):** 허용되지 않은 메모리 영역에 접근하려고 할 때 (가장 흔한 원인).
*   **`SIGILL` (Illegal Instruction):** CPU가 이해할 수 없는 잘못된 명령어를 실행하려고 할 때.
*   **`SIGFPE` (Floating-Point Exception):** 0으로 나누는 등 잘못된 부동소수점 연산을 수행할 때.
*   **`SIGABRT` (Abort):** 프로그램이 스스로 `abort()` 함수를 호출하여 비정상 종료를 선택했을 때.
*   **`SIGQUIT` (Quit):** 사용자가 의도적으로 디버깅을 위해 `Ctrl+\` 키를 눌러 코어 덤프를 생성하며 종료시키고자 할 때.

반면, `SIGTERM`이나 `SIGINT`(`Ctrl+C`) 같은 신호는 프로그램에게 "정리하고 정상적으로 종료하라"고 요청하는 신호이므로, 기본적으로는 코어 덤프를 생성하지 않습니다.

---

### 3. 코어 덤프 파일에는 무엇이 들어있나요?

코어 덤프 파일은 단순한 텍스트 파일이 아니라, 특정 구조를 가진 바이너리 파일입니다. 여기에는 오류 분석에 필요한 거의 모든 정보가 담겨 있습니다.

*   **프로세스 메모리 이미지 (Process Memory Image):**
    *   **스택(Stack):** 함수 호출 기록, 지역 변수 등의 정보가 담겨 있습니다. 충돌이 발생한 지점까지 어떤 함수들이 어떤 순서로 호출되었는지 추적하는 데 결정적입니다.
    *   **힙(Heap):** 동적으로 할당된 메모리 영역의 데이터가 들어있습니다.
    *   **전역 변수(Global Variables) 및 정적 변수(Static Variables):** 프로그램 전역에서 사용되는 변수들의 마지막 상태를 알 수 있습니다.

*   **CPU 레지스터 상태 (CPU Registers Status):**
    *   **프로그램 카운터 (Program Counter, PC 또는 IP):** 오류가 발생한 정확한 코드 라인(기계어 명령어 주소)을 가리킵니다.
    *   **스택 포인터 (Stack Pointer, SP):** 현재 스택의 최상단 위치를 가리킵니다.
    *   **범용 레지스터 (General-Purpose Registers):** 연산에 사용되던 값들이 그대로 저장되어 있어, 오류 직전의 계산 상태를 파악할 수 있습니다.

*   **프로세스 상태 정보:**
    *   프로세스 ID(PID), 사용자 ID(UID) 등 프로세스 기본 정보.
    *   코어 덤프를 유발한 신호(Signal)의 번호.

---

### 4. 코어 덤프의 주된 용도: 사후 분석 디버깅 (Post-mortem Debugging)

코어 덤프의 존재 이유는 단 하나, **"사후 분석 디버깅"**을 위해서입니다.

프로그램이 고객 환경이나 운영 서버처럼 개발 환경이 아닌 곳에서 예기치 않게 죽었을 때, 개발자는 실시간으로 디버깅을 할 수 없습니다. 이때 서버에 남겨진 코어 덤프 파일을 가져오면, **마치 프로그램이 방금 죽은 그 순간으로 시간을 되돌려 현장을 조사하는 것처럼** 디버깅을 할 수 있습니다.

주로 **`gdb`(GNU Debugger, Linux에서 주로 사용)**나 **`lldb`(LLVM Debugger, macOS에서 주로 사용)**와 같은 디버거를 사용하여 코어 덤프 파일을 분석합니다.

예를 들어, 다음과 같은 명령어로 분석을 시작할 수 있습니다.

```bash
# gdb <실행 파일> <코어 덤프 파일>
gdb ./my_program core 
```

디버거로 코어 덤프를 열면 개발자는 다음과 같은 강력한 분석을 할 수 있습니다.

*   **백트레이스(Backtrace) 확인:** `bt` 명령어를 통해 프로그램이 어떤 함수 호출 순서를 거치다가 죽었는지 한눈에 파악할 수 있습니다. (가장 먼저 하는 일)
*   **변수 값 확인:** 특정 시점의 변수들이 어떤 값을 가지고 있었는지 확인할 수 있습니다.
*   **메모리 상태 조사:** 특정 메모리 주소에 어떤 데이터가 있었는지 직접 들여다볼 수 있습니다.
*   **레지스터 값 확인:** CPU 레지스터 값을 통해 저수준의 연산 상태를 분석할 수 있습니다.

---

### 5. 실용적인 정보 및 주의사항

*   **파일 크기:** 코어 덤프는 프로세스가 사용하던 메모리 전체를 저장하므로, 파일 크기가 매우 클 수 있습니다 (수백 MB ~ 수십 GB). 이 때문에 기본적으로 시스템에서 코어 덤프 생성이 비활성화되어 있는 경우가 많습니다.
*   **활성화 방법:** 쉘에서 `ulimit -c unlimited` 명령어를 사용하면 현재 세션에서 코어 덤프 파일 크기 제한을 풀어 생성을 활성화할 수 있습니다. (`ulimit -c 0`은 비활성화)
*   **보안:** 코어 덤프 파일에는 메모리의 모든 내용, 즉 **비밀번호, 개인 키, 고객 정보 등 매우 민감한 데이터가 평문으로 포함될 수 있습니다.** 따라서 코어 덤프 파일은 매우 신중하게 관리해야 하며, 외부 유출에 각별히 주의해야 합니다.
*   **파일 이름 및 위치:** 생성되는 코어 덤프 파일의 이름은 보통 `core` 또는 `core.[PID]` 형식이며, 파일의 이름과 저장 위치는 운영체제 설정을 통해 변경할 수 있습니다 (Linux의 경우 `/proc/sys/kernel/core_pattern`).

### 요약

**코어 덤프는 프로그램의 비정상 종료 시점의 메모리 상태, 레지스터 값 등을 담고 있는 파일로, '사후 분석 디버깅'을 위한 핵심적인 단서입니다.** 이를 통해 개발자는 재현하기 어려운 버그의 원인을 정확하고 효율적으로 찾아낼 수 있습니다.

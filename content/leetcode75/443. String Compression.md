---
title: 443. String Compression
resource-path: leetcode75/443. String Compression.md
aliases:
tags:
description:
series: leetcode74
series_weight: 443
finish:
date: 2024-12-31T00:21:00+09:00
lastmod: 2025-09-29T12:44:39+09:00
---
```
주어진 문자 배열 chars를 다음 알고리즘을 사용하여 압축하세요:

빈 문자열 s로 시작합니다. chars에서 연속으로 반복되는 문자의 그룹마다:

그룹의 길이가 1인 경우, 문자를 s에 추가합니다.
그렇지 않으면, 문자를 그룹의 길이와 함께 s에 추가합니다.
압축된 문자열 s는 별도로 반환하지 않고, 입력 문자 배열 chars에 저장해야 합니다. 그룹의 길이가 10 이상인 경우, chars에 여러 문자로 나누어 저장해야 합니다.

수정이 완료된 후, 배열의 새 길이를 반환합니다.

상수 추가 공간만 사용하는 알고리즘을 작성해야 합니다.

예시
예시 1:

입력: chars = ["a", "a", "b", "b", "c", "c", "c"]
출력: 6을 반환하며, 입력 배열의 처음 6개의 문자: ["a", "2", "b", "2", "c", "3"]
설명: 그룹은 "aa", "bb", "ccc"이며, "a2b2c3"으로 압축됩니다.
예시 2:

입력: chars = ["a"]
출력: 1을 반환하며, 입력 배열의 첫 번째 문자는: ["a"]
설명: 유일한 그룹은 "a"이며, 단일 문자이므로 압축되지 않습니다.
예시 3:

입력: chars = ["a", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b"]
출력: 4를 반환하며, 입력 배열의 처음 4개의 문자는: ["a", "b", "1", "2"]
설명: 그룹은 "a"와 "bbbbbbbbbbbb"이며, "ab12"로 압축됩니다.
제약 조건
1 <= chars.length <= 2000
chars[i]는 소문자 영어 문자, 대문자 영어 문자, 숫자 또는 기호입니다.
```

vector 로 조작하면 

```cpp
class Solution {
public:
    int compress(vector<char>& chars) {
        vector<char> ret;
        auto itr = char.begin();
        char first = itr;
        char last = itr+1;
        int count;
        for(itr < chars.end()){
            if(*first != *last){
                count = last - first;
                char.erase(remove(first+1, last), );
                if(count >= 1000){// 1000 이상
                    *first
                }
                // 100이상
                // 10 이상
                last = ++first
            }else last++;
        }
    }
};
```
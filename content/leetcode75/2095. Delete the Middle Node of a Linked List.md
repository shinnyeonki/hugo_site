---
title: 2095. Delete the Middle Node of a Linked List
date: 2025-02-01T02:37:00+09:00
lastmod: 2025-09-29T12:44:55+09:00
resource-path: leetcode75/2095. Delete the Middle Node of a Linked List.md
aliases: 
tags:
  - algorithm
  - leetcode
---
## 문제
주어진 연결 리스트의 헤드가 주어졌을 때, 중간 노드를 삭제하고 수정된 연결 리스트의 헤드를 반환하세요.

크기가 $n$인 연결 리스트의 중간 노드는 0-based 인덱스를 사용하여 $\lfloor n / 2 \rfloor$번째 노드입니다. 여기서 $\lfloor x \rfloor$는 $x$보다 작거나 같은 가장 큰 정수를 나타냅니다.

예를 들어, $n = 1, 2, 3, 4, 5$일 때 중간 노드의 인덱스는 각각 $0, 1, 1, 2, 2$입니다.

---

### **예제**

#### 예제 1:
입력:

```cpp
head = [1, 3, 4, 7, 1, 2, 6]
```

출력:

```cpp
[1, 3, 4, 1, 2, 6]
```

설명:
위 그림은 주어진 연결 리스트를 나타냅니다. 노드의 인덱스는 아래에 표시되어 있습니다.  
$ n = 7 $이므로, 값이 $ 7 $인 3번째 노드(0-based 인덱스)가 중간 노드입니다. 이 노드는 빨간색으로 표시되어 있습니다.  
우리는 이 노드를 제거한 후 새로운 리스트를 반환합니다.

---

#### 예제 2:
입력:

```cpp
head = [1, 2, 3, 4]
```

출력:

```cpp
[1, 2, 4]
```

설명:
위 그림은 주어진 연결 리스트를 나타냅니다.  
$ n = 4 $이므로, 값이 $ 3 $인 2번째 노드(0-based 인덱스)가 중간 노드입니다. 이 노드는 빨간색으로 표시되어 있습니다.

---

#### 예제 3:
입력:

```cpp
head = [2, 1]
```

출력:

```cpp
[2]
```

설명:
위 그림은 주어진 연결 리스트를 나타냅니다.  
$ n = 2 $이므로, 값이 $ 1 $인 1번째 노드(0-based 인덱스)가 중간 노드입니다. 이 노드는 빨간색으로 표시되어 있습니다.  
값이 $ 2 $인 0번째 노드만 남게 됩니다.

---

### **제약 조건**
- 연결 리스트의 노드 수는 $[1, 10^5]$ 범위에 있습니다.
- $1\leq \text{Node.val} \leq 10^5$


## 답
일반적 접근

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 노드의 값
 *     ListNode *next;   // 다음 노드를 가리키는 포인터
 *     ListNode() : val(0), next(nullptr) {} // 기본 생성자
 *     ListNode(int x) : val(x), next(nullptr) {} // 값만 초기화하는 생성자
 *     ListNode(int x, ListNode *next) : val(x), next(next) {} // 값과 다음 노드를 초기화하는 생성자
 * };
 */
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        // Edge case: 리스트에 노드가 하나만 있는 경우 nullptr 반환
        if (head == nullptr || head->next == nullptr) {
            return nullptr; // 노드가 없거나 하나뿐이면 삭제 후 nullptr 반환
        }

        // Step 1: 연결 리스트의 길이 계산
        int length = 0; // 리스트 길이를 저장할 변수
        ListNode* temp = head; // 임시 포인터를 사용하여 리스트 순회
        while (temp != nullptr) { // 리스트의 끝까지 이동
            length++; // 노드 수 카운트
            temp = temp->next; // 다음 노드로 이동
        }

        // Step 2: 중간 노드의 인덱스 계산 (0-based)
        int mid = length / 2; // 중간 노드의 인덱스 계산

        // Step 3: 중간 노드 바로 전 노드까지 이동
        temp = head; // 다시 head부터 시작
        for (int i = 0; i < mid - 1; i++) { // 중간 노드 바로 전까지 이동
            temp = temp->next; // 다음 노드로 이동
        }

        // Step 4: 중간 노드 삭제
        ListNode* toDelete = temp->next; // 삭제할 중간 노드를 저장
        temp->next = temp->next->next; // 중간 노드를 건너뛰도록 연결 변경
        delete toDelete; // 메모리 해제 (C++에서는 선택 사항)

        return head; // 수정된 리스트의 head 반환
    }
};
```

투포인터 접근

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 노드의 값
 *     ListNode *next;   // 다음 노드를 가리키는 포인터
 *     ListNode() : val(0), next(nullptr) {} // 기본 생성자
 *     ListNode(int x) : val(x), next(nullptr) {} // 값만 초기화하는 생성자
 *     ListNode(int x, ListNode *next) : val(x), next(next) {} // 값과 다음 노드를 초기화하는 생성자
 * };
 */
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        // Edge case: 리스트에 노드가 하나만 있는 경우 nullptr 반환
        if (head == nullptr || head->next == nullptr) {
            return nullptr; 
            // 노드가 없거나 하나뿐이면 중간 노드를 삭제한 후 nullptr을 반환합니다.
        }
        
        // 더미 노드 생성
        ListNode* prev = new ListNode(0, head); 
        // 더미 노드(prev)를 생성하고, next를 head로 설정합니다.
        // 이는 중간 노드를 삭제할 때 편리하게 처리하기 위함입니다.
        ListNode* slow = prev; 
        // slow 포인터를 더미 노드로 초기화합니다.
        ListNode* fast = head; 
        // fast 포인터를 head로 초기화합니다.

        // 투 포인터 기법으로 중간 노드 찾기
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next; 
            // slow는 한 칸씩 이동합니다.
            fast = fast->next->next; 
            // fast는 두 칸씩 이동합니다.
        }

        // 임시 보관
        ListNode* toDelete = slow->next; 
        // 삭제할 중간 노드를 toDelete에 저장합니다.

        // 실제 변경
        slow->next = slow->next->next; 
        // slow의 next를 변경하여 중간 노드를 건너뜁니다(중간 노드 삭제).

        // 메모리 해제
        delete toDelete; // 삭제된 중간 노드의 메모리 해제
        delete prev;     // 더미 노드의 메모리 해제

        return head; 
        // 수정된 리스트의 head를 반환합니다.
    }
};
```
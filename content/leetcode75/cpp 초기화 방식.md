---
title: cpp 초기화 방식
aliases: 
tags: 
created: 2025-02-02T02:18:00+09:00
modified: 2025-09-29T12:44:58+09:00

---

```cpp
class Widget
{
public:
  Widget() {
    std::cout << "default" << std::endl;
  }

  Widget(std::initializer_list<int> il) {
    std::cout << "init" << std::endl;
  }
};

int main() {
Widget w1; //기본 생성자 호출
Widget w2(); //함수! 호출 x
Widget w3{}; //기본 생성자 호출
Widget w4({});//std::initializer_list 이용해 호출
Widget w5{ {} };//std::initializer_list 이용해 호출
Widget w6 = {}; // 기본 생성자 호출
Widget w7 = { {} }; //std::initializer_list 이용해 호출
}

```

모두의 코드 해당 자료
https://modoocode.com/286


## 1. 초기화(Initialization)란?

- **정의**:  
    변수를 선언할 때 그 변수에 최초의 값을 제공하는 과정을 **초기화**라고 합니다.
    - 객체나 변수의 메모리 공간이 할당되면서 동시에 정해진 초기 값이 부여됩니다.
    - 이는 선언문의 초기화 부분이나, `new` 표현식, 함수 호출 시(함수 인자 및 리턴값 초기화) 등에서 이루어집니다.

---

## 2. 초기화 구문(Initializers) 형태

각 선언자(declarator)에 대해 초기화자가 있을 경우 사용할 수 있는 구문은 다음과 같습니다.

1. **`= expression`**
    
    - **설명**: 등호(`=`) 다음에 임의의 표현식이 나오는 형태입니다.
    - **예**:

        ```cpp
        int a = 5;
        std::string s = "hello";
        ```

    - **용어**: "복사 초기화(copy-initialization)"라고 부릅니다.
2. **`= {}` 또는 `= { initializer-list }` 또는 `= { designated-initializer-list }`**
    
    - **설명**: 등호 뒤에 중괄호를 사용하여 초기값을 나열하는 형태입니다.
    - **역사**:
        - C++11부터 중괄호를 사용한 **목록 초기화(list-initialization)**가 도입되었습니다.
        - C++20부터 **지정 초기자(designated initializer)** 문법이 추가되었습니다.
    - **예**:

        ```cpp
        int arr[3] = {1, 2, 3}; // 배열에 대한 aggregate 초기화
        MyStruct s = { .x = 10, .y = 20 }; // C++20 지정 초기자
        ```

3. **`( expression-list )` 또는 `( initializer-list )`**
    
    - **설명**: 괄호를 사용한 직접 초기화 구문입니다.
    - **차이점**:
        - C++11 이전에는 괄호 안에 초기값 목록을 쓰는 것이 **직접 초기화(direct-initialization)** 문법이었습니다.
        - C++11 이후에도 여전히 지원됩니다.
    - **예**:

        ```cpp
        std::string s("hello"); // 직접 초기화
        ```

4. **`{}` 또는 `{ initializer-list }` 또는 `{ designated-initializer-list }`**
    
    - **설명**: 중괄호만을 사용한 초기화 구문으로, C++11부터 도입된 **목록 초기화(list-initialization)**입니다.
    - **예**:

        ```cpp
        std::string s{"hello"}; // 목록 초기화 (C++11 이후)
        int a{};                // 기본값으로 초기화 (보통 0으로 초기화)
        ```

> **요약**:
> 
> - 구문 (1)은 **복사 초기화(copy initialization)**
> - 구문 (3)은 **직접 초기화(direct initialization)**
> - 구문 (2)와 (4)는 중괄호를 사용하는 **목록 초기화(list initialization)**에 해당합니다.
> - 지정 초기자(designated initializer)는 C++20부터 사용할 수 있습니다.

---

## 3. 초기화에 사용되는 요소들의 설명

- **expression**:
    
    - 임의의 표현식을 의미합니다. 단, 괄호 없이 나열한 콤마 표현식(unparenthesized comma expressions)은 제외됩니다.
- **expression-list**:
    
    - 표현식들을 쉼표(,)로 구분하여 나열한 목록입니다. 역시, 괄호 없이 나열된 콤마 표현식은 제외합니다.
- **initializer-list**:
    
    - 쉼표로 구분된 초기화 절(clause)들의 목록입니다.
- **designated-initializer-list**:
    
    - 각 초기화 절에 멤버 이름을 명시하는 초기자들의 목록입니다. (C++20부터 지원)
- **brace-enclosed initializer list**:
    
    - 중괄호 `{}` 로 감싼 초기자 구문을 총칭하는 말입니다.

---

## 4. 초기화 구문에 따른 초기화 의미 (Initializer Semantics)

초기화가 진행되는 대상에 따라 다르게 적용됩니다.

### A. 참조(reference) 초기화

- **설명**:
    - 초기화 대상이 참조일 경우, **참조 초기화(reference initialization)** 규칙이 적용됩니다.
    - **필수**: 참조는 반드시 유효한 객체를 가리키도록 초기화되어야 합니다.
    - **예**:

        ```cpp
        int x = 10;
        int& ref = x; // 올바른 참조 초기화
        ```

    - **문제**: 초기화하지 않은 참조는 프로그램이 잘못된 동작을 하거나 컴파일 오류를 발생시킵니다.

### B. 객체(object) 초기화

- **대상**: 일반 변수나 객체는 초기화될 때 **객체 초기화**가 진행됩니다.
- **T 타입의 객체**에 대해:
    1. **(1) 복사 초기화**
        - 초기화 구문이 `= expression`인 경우, **복사 초기화**가 진행됩니다.
        - 예:

            ```cpp
            std::string s = "hello";
            ```

    2. **(2) 중괄호를 사용한 초기화**
        - T가 aggregate (집합체)인 경우, **aggregate 초기화**가 적용됩니다.
            - 예: 배열, 구조체 등.
        - T가 스칼라 타입(예: int, double)인 경우,  
            `T x = { a };` 는 `T x = a;`와 동일하게 동작합니다.
        - 만약 T가 aggregate가 아니면서 중괄호 초기화가 사용되었는데 해당 타입에 맞는 생성자가 없다면, 프로그램은 ill-formed (잘못된 프로그램)으로 간주됩니다.
    3. **(3) 직접 초기화**
        - 초기화 구문이 `( expression-list )`인 경우, **직접 초기화**가 진행됩니다.
    4. **(4) 목록 초기화 (C++11 이후)**
        - 중괄호를 사용한 형태로, **list-initialization**이 적용됩니다.

> **주의**:
> 
> - 초기화 구문에 따라 복사 초기화와 직접 초기화는 약간의 차이가 있을 수 있으며, 특히 타입 변환이나 임시 객체 생성 과정에 영향을 미칠 수 있습니다.
> - C++11부터는 목록 초기화가 도입되어 중괄호 초기화가 점점 일반적으로 사용됩니다.

---

## 5. 예제 코드와 그 의미

아래 코드를 하나씩 살펴봅니다:

```cpp
#include <string>

std::string s1;           // (a) 기본 초기화 (default initialization)
std::string s2();         // (b) 함수 선언! 초기화가 아님
std::string s3 = "hello"; // (c) 복사 초기화 (copy initialization)
std::string s4("hello");  // (d) 직접 초기화 (direct initialization)
std::string s5{'a'};      // (e) 목록 초기화 (list initialization, C++11부터)
```

- **(a) `std::string s1;`**
    
    - **기본 초기화(default-initialization)**
    - 객체 `s1`은 아무 초기값 없이 생성됩니다.
    - std::string의 경우, 내부적으로 기본 생성자가 호출되어 빈 문자열("")이 됩니다.
- **(b) `std::string s2();`**
    
    - 이것은 **초기화**가 아니라 함수 선언입니다.
    - `s2`는 매개변수가 없고 `std::string`을 반환하는 함수로 해석됩니다.
    - 이를 **"most vexing parse"** 라고 부르기도 합니다.
- **(c) `std::string s3 = "hello";`**
    
    - **복사 초기화(copy initialization)**
    - "hello"라는 문자열 리터럴을 사용하여 s3를 초기화합니다.
- **(d) `std::string s4("hello");`**
    
    - **직접 초기화(direct initialization)**
    - 생성자에 "hello"를 직접 전달하여 s4를 초기화합니다.
- **(e) `std::string s5{'a'};`**
    
    - **목록 초기화(list initialization)**
    - 중괄호를 사용하여 s5를 초기화합니다.
    - 이 경우 std::string에 대해 어떤 생성자가 호출되는지(예: 단일 문자로 구성된 문자열 등)는 타입에 따라 달라집니다.

또 다른 예로 배열과 참조 초기화:

```cpp
char a[3] = {'a', 'b'}; // aggregate 초기화: 배열의 첫 두 요소가 'a'와 'b'로, 나머지는 0으로 초기화
char& c = a[0];         // 참조 초기화: c는 배열 a의 첫 번째 요소를 참조
```

- 배열 `a`는 중괄호를 사용하여 aggregate 초기화됩니다.
- 참조 `c`는 배열의 첫 번째 요소 `a[0]`를 가리키도록 초기화됩니다.

---

## 6. 비지역 변수(Non-local variables) 초기화

비지역 변수란 전역 변수나 네임스페이스 범위, 또는 정적/스레드 로컬(static/thread-local) 변수를 말합니다.

### A. 비지역 변수의 초기화 시점

- **정적 저장 기간(static storage duration)**을 가지는 변수들은 프로그램 시작 시, `main` 함수 실행 전에 초기화됩니다.
- **스레드 로컬(thread-local storage)** 변수들은 각 스레드가 시작될 때 초기화되며, 스레드 함수가 실행되기 전에 이루어집니다.

### B. 초기화 과정은 두 단계로 나뉩니다

1. **정적 초기화 (Static initialization)**
    
    - **1) 상수 초기화 (Constant initialization)**:
        - 가능한 경우, 컴파일 타임에 상수 값으로 초기화됩니다.
        - 컴파일러는 미리 계산된 초기 값(객체 표현)을 프로그램 이미지에 저장할 수 있습니다.
    - **2) 0으로 초기화 (Zero initialization)**:
        - 상수 초기화가 불가능한 경우, 정적 및 스레드 로컬 변수들은 먼저 0으로 초기화됩니다.
        - 0으로 초기화된 변수들은 보통 프로그램의 `.bss` 섹션에 위치하며, 프로그램 로딩 시 운영체제가 이 영역을 0으로 채웁니다.
2. **동적 초기화 (Dynamic initialization)**
    
    - 정적 초기화가 완료된 후, 나머지 동적 초기화가 진행됩니다.
    - 동적 초기화에는 다음 세 가지 유형이 있습니다.
    
    **(1) 순서가 정해지지 않은(unordered) 동적 초기화**
    
    - 적용 대상: 주로 클래스 템플릿의 정적 데이터 멤버나 변수 템플릿(특수화되지 않은 경우, C++14부터 적용)
    - 이들 변수의 초기화 순서는 다른 동적 초기화들과는 indeterminately(불특정하게) 순서가 정해집니다.
    - 단, 프로그램이 변수 초기화 전에 스레드를 시작하는 경우 C++17부터는 "unsequenced"로 초기화됩니다.
    
    **(2) 부분 순서(partially-ordered) 동적 초기화**
    
    - 적용 대상: inline 변수 중 암시적 또는 명시적 인스턴스화되지 않은 특수화가 아닌 변수들
    - 한 번에 한 번, 정의된 순서에 따라 초기화 순서가 결정됩니다.
    - 한 번의 번역 단위(translation unit) 내에서, 어떤 변수 V가 항상 W보다 먼저 정의되면 V의 초기화가 W보다 먼저 이루어집니다.
    - (C++17부터 적용)
    
    **(3) 순서가 정해진(ordered) 동적 초기화**
    
    - 적용 대상: 위의 두 경우에 해당하지 않는 모든 비지역 변수들
    - 한 번의 번역 단위 내에서, 소스 코드에 나타난 순서대로 초기화가 진행됩니다.
    - 서로 다른 번역 단위 간에는 초기화 순서가 **불특정(indeterminately sequenced)** 입니다.
    - 스레드 로컬 변수의 경우, 다른 번역 단위 간에는 초기화 순서가 **unsequenced** 됩니다.

- **예외 처리**:
    - 만약 비지역 변수(정적 또는 스레드 로컬)의 초기화 도중 예외가 발생하면, `std::terminate`가 호출됩니다.

---

## 7. 조기(dynamic) 초기화(Early dynamic initialization)

- **개념**:  
    컴파일러는 아래 조건을 만족할 경우, 동적 초기화를 정적 초기화 단계에서 미리(컴파일 타임에) 수행할 수 있습니다.
    
- **조건**:
    
    1. 동적 초기화가 다른 네임스페이스 범위 객체의 값을 변경하지 않아야 합니다.
    2. 정적 초기화 버전이 동적 초기화를 수행했을 때와 동일한 값을 산출해야 합니다.
- **결과**:
    
    - 예를 들어, 어떤 객체 `o1`의 초기화 과정에서 같은 번역 단위 내의 `o2`에 접근한다면,  
        컴파일러가 `o2`를 정적으로 초기화할 수 있으면, `o2`는 완전히 초기화된 상태의 값이거나 단순히 0으로 초기화된 상태일 수 있으며, 이는 명확하지 않습니다(불특정).
- **예제**:

    ```cpp
    inline double fd() { return 1.0; }
    
    extern double d1;
    
    double d2 = d1; // d1이 동적 초기화되었으면 0.0, 아니면 1.0 등으로 초기화될 수 있음
    
    double d1 = fd(); // d1은 1.0으로 초기화; 정적 초기화될 수도, 동적 초기화될 수도 있음.
    ```

---

## 8. 지연된 동적 초기화(Deferred dynamic initialization)

- **개념**:
    
    - 일부 구현에서는 동적 초기화를 `main` 함수의 첫 문장 이전에 수행할 수도 있고,
    - 또는 `main` 함수(혹은 스레드 초기 함수)의 첫 문장 이후로 지연시킬 수도 있습니다.
- **규칙 (C++17부터)**:
    
    - **비 inline 변수**:
        - 만약 동적 초기화가 `main` 함수 시작 후로 지연된다면, 같은 번역 단위 내에서 해당 변수를 **ODR-사용(One Definition Rule 사용)**하기 전에 초기화가 이루어집니다.
        - 만약 번역 단위 내의 변수나 함수가 전혀 사용되지 않으면, 그 번역 단위에 정의된 비지역 변수들은 아예 초기화되지 않을 수도 있습니다(동적 라이브러리의 on-demand 초기화와 유사).
    - **inline 변수**:
        - inline 변수의 경우, 해당 변수가 ODR-사용되기 전에 초기화가 이루어집니다.
- **여러 파일에 걸친 예제**:  
    예제 코드에서는 서로 다른 번역 단위(File 1, File 2, File 3)에서 변수 `a`와 `b`의 초기화 순서에 따라,
    
    - 만약 `a`가 `main` 전에 초기화된다면, `A::A()` 안에서 `b`가 아직 초기화되지 않았을 수 있습니다.
    - 반면, `a`가 `main` 이후에 초기화(ODR-사용에 의해)된다면, `b`도 초기화된 후에 사용됩니다.

---

## 9. 블록 스코프(static local) 변수

- **설명**:
    - 함수 내부(또는 블록 내)에서 `static` 또는 `thread_local`로 선언된 변수들은 **지역 정적 변수**라고 합니다.
    - 이들 변수의 초기화에 관한 규칙은 별도로 다루어지며, 보통 해당 블록에 처음 도달했을 때 초기화가 수행됩니다.
- **참고**:
    - 블록 스코프 변수는 전역 변수와 달리, 외부 또는 내부 링케이지(external or internal linkage)를 갖는 선언에서는 초기화자가 허용되지 않습니다.
    - 이런 경우 `extern` 선언을 통해 정의와 분리하여 초기화해야 합니다.

---

## 10. 클래스 멤버 초기화

- **비정적 데이터 멤버(non-static data members)**
    - 클래스 내부에서, 비정적 데이터 멤버들은 두 가지 방식으로 초기화할 수 있습니다.
        1. **생성자 멤버 초기화 리스트**:
            - 생성자의 콜론(:) 뒤에 멤버들을 초기화하는 방식입니다.
        2. **기본 멤버 초기값(default member initializer)**:
            - 클래스 정의 내에서 멤버 변수를 선언할 때, 등호(`=`)나 중괄호를 사용하여 초기값을 부여하는 방식입니다.
    - **우선순위**:
        - 만약 둘 다 존재한다면, 생성자 멤버 초기화 리스트에 명시된 초기값이 우선합니다.

---

## 11. 소멸 순서

- **참고**:
    - 비지역 변수의 소멸 순서는 C++ 표준 라이브러리의 `std::exit` 문서에 설명되어 있습니다.
    - 정적 객체들은 프로그램 종료 시, 생성 순서의 역순으로 소멸됩니다.

---

## 최종 정리

C++ 초기화는 매우 다양한 구문과 규칙이 있으며, 초기화 방법에 따라 다음과 같이 분류할 수 있습니다.

1. **변수 선언 시 초기화**
    - 복사 초기화, 직접 초기화, 목록 초기화, 지정 초기자 등을 사용할 수 있습니다.
2. **참조 초기화**
    - 반드시 유효한 객체를 가리키도록 초기화되어야 하며, 임시 객체에 바인딩할 수 없음.
3. **비지역(전역, 네임스페이스, static, thread_local) 변수 초기화**
    - 두 단계(정적 초기화와 동적 초기화)로 진행됩니다.
    - 정적 초기화에서는 상수 초기화와 0 초기화가 수행됩니다.
    - 동적 초기화는 unordered, partially-ordered, ordered 세 가지 방식으로 진행되며, 번역 단위 간 순서는 보장되지 않습니다.
4. **조기(dynamic) 초기화와 지연 초기화**
    - 컴파일러가 조건을 만족하면 동적 초기화를 정적으로 미리 수행할 수 있으며,
    - 또는 프로그램 실행 도중(ODR-사용 시점)에 지연시킬 수도 있습니다.
5. **클래스 멤버 초기화**
    - 생성자 초기화 리스트 또는 기본 멤버 초기값을 통해 초기화합니다.
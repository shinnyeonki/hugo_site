---
title: 1493. Longest Subarray of 1's After Deleting One Element
aliases: 
tags:
  - leetcode
  - algorithm
created: 2025-01-17T04:48:00+09:00
modified: 2025-09-29T12:44:38+09:00

---
## 문제

```
주어진 문제는 이진 배열 nums에서 하나의 요소를 삭제한 후, 결과 배열에서 1로만 이루어진 가장 긴 비어 있지 않은 부분 배열의 크기를 반환하는 것입니다. 만약 그런 부분 배열이 존재하지 않으면 0을 반환합니다.

### 예시:
1. **입력**: nums = [1, 1, 0, 1]  
   **출력**: 3  
   **설명**: 인덱스 2의 숫자를 삭제하면 [1, 1, 1]이 되어 1의 개수가 3입니다.

2. **입력**: nums = [0, 1, 1, 1, 0, 1, 1, 0, 1]
   **출력**: 5
   **설명**: 인덱스 4의 숫자를 삭제하면 [0, 1, 1, 1, 1, 1, 0, 1]이 되어 1의 개수가 5입니다.

3. **입력**: nums = [1, 1, 1] 
   **출력**: 2  
   **설명**: 하나의 요소를 삭제해야 하므로, 최대 1의 개수는 2입니다.

### 제약 조건:
- 1 <= nums.length <= 10^5
- nums[i]는 0 또는 1입니다. 

```

## O(n^3)

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int ret = 0;
        for(int start = 0; start < nums.size(); start++){
            for(int end = start; end < nums.size(); end++){
                int zero_count = 0;
                // 부분 배열의 0 개수 찾기
                for(int i = start ; i <= end ; i++){
                    if(nums[i] == 0)
                        zero_count++;
                }
                if(zero_count == 0 || zero_count == 1)
	                ret = max(ret, end - start);
            }
        }
        return ret;
    }
};
```

## O(n^2)
zero_count 를 각 부분배열에서 다시 계산해야 할까??
부분배열의 시작 인덱스에서 반복이 실행되므로
끝 인덱스의 값만 확인하면서 0 개수를 저장해도 되지 않을까?

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int ret = 0;
        for(int start = 0; start < nums.size(); start++){
            int zero_count = 0;
            for(int end = start; end < nums.size(); end++){
                // 부분 배열의 0 개수 찾기
                if(nums[end] == 0)
                    zero_count++;
                if(zero_count == 0 || zero_count == 1)
                    ret = max(ret, end - start);
            }
        }
        return ret;
    }
};
```

## O(n) sliding window
아직 $O(n^2)$ 이다
부분배열의 관찰 이므로
sliding window 를 통해 최적화 할 수 없을까??

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int ret = 0;
        int start = 0;
        int zero_count = 0;
        for(int end = 0 ; end < nums.size(); end++){
            if(nums[end] == 0)
                zero_count++;
            
            while(zero_count > 1)
                if(nums[start++] == 0)
                    zero_count--;
            
            ret = max(ret, end - start);
        }
        return ret;
    }
};
```

## 동적계획법

> 추가 : 동적계획법으로 푸는 방법 

#ModificationRequired 

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        vector<int> dp = {0};
        int maximum = 0;

        for (int i = 0; i < nums.size(); ++i)
        {
            if (nums[i] == 1)
                dp.push_back(dp[i] + 1);
            else
                dp.push_back(0);
        }

        if (dp.back() + 1 == dp.size())
            return dp.back() - 1;

        for (int i = dp.size()-1; i >= 0; --i)
        {
            if (dp[i] != 0)
            {
                if (i - dp[i] - 1 >= 0)
                    maximum = max(maximum, dp[i] + dp[i - dp[i] - 1]);
                else
                    maximum = max(maximum, dp[i]);
                i -= dp[i];
            }
        }

        return maximum;
    }
};
```
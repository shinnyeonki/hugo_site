---
title: 334. Increasing Triplet Subsequence
resource-path: leetcode75/334. Increasing Triplet Subsequence.md
keywords:
tags:
  - algorithm
  - leetcode
description:
series: leetcode74
series_weight: 334
finish:
date: 2024-12-30T14:38:00+09:00
lastmod: 2025-09-05T03:56:21+09:00
---
```
주어진 정수 배열 nums에 대해, 인덱스 (i, j, k)가 존재하여 i < j < k이고 nums[i] < nums[j] < nums[k]를 만족하는지 확인하여, 존재하면 true를 반환하고, 그렇지 않으면 false를 반환하는 문제입니다.

예시)
입력: nums = [1,2,3,4,5]
출력: true
설명: i < j < k인 모든 조합이 유효합니다.

입력: nums = [5,4,3,2,1]
출력: false
설명: 유효한 조합이 존재하지 않습니다.

입력: nums = [2,1,5,0,4,6]
출력: true
설명: (3, 4, 5) 조합이 유효합니다. nums[3] == 0 < nums[4] == 4 < nums[5] == 6입니다.

제약 조건
1 <= nums.length <= 5 * 10^5
-2^31 <= nums[i] <= 2^31 - 1
후속 질문
O(n) 시간 복잡도와 O(1) 공간 복잡도로 구현할 수 있는 방법이 있는지 확인해 보세요.
```

greedy 알고리즘으로 풀 수 있는 문제이다

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if (nums.size() < 3) return false; // 제한 조건의 추가

        int first = INT_MAX;  // 첫 번째 최소값
        int second = INT_MAX; // 두 번째 최소값
        for (int num : nums)
            if (num <= first) first = num; // 첫 번째 최소값 업데이트
            else if (num <= second) second = num; // 두 번째 최소값 업데이트
            else return true; // 세 번째 값이 발견됨


        return false;
    }
};
```
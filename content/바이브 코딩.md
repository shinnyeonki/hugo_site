---
title: 바이브 코딩
date: 2025-10-08T04:59:51+09:00
lastmod: 2025-10-13T13:22:04+09:00
resource-path: 바이브 코딩.md
aliases:
tags:
  - thinking
---
본 글은 바이브 코딩뿐만 아니라 모든 ai가 코드에 개입하는 상황과 여러 프로젝트를 경험해보고 느낀 글이다
1. 소프트웨어 물리적 개입 분류
	1. 실시간 ai 자동완성
	2. ex) cursor 
	3. ex) gemini cli, claude code
2. 개입 정도 따른 분류


초창기 ai 는 autocomplete 형태로 개입되었다(초창기 copliot, TabNine) 2023년 정도 시점  
하지만 시간이 지나면서 cursor 가 나오게 되고 claude code 과 같은 터미널 베이스 로 개입이 되고 있다  
각각 autocomplete,

---
### 소프트 웨어 공학 용어들

- **SSoT** (Single Source of Truth, 단일 진실 공급원)  
  **정의**: 시스템 내 특정 데이터는 오직 하나의 권위 있는 출처에서만 관리되고 갱신된다.  
  **목적**: 데이터 중복, 불일치, 오류를 방지하고 일관성과 신뢰성을 확보한다.

- **응집도** (Cohesion)  
  **정의**: 모듈 내부 요소들이 하나의 목적 또는 책임을 위해 얼마나 긴밀하게 연결되어 있는가.  
  **목적**: 유지보수성, 재사용성, 테스트 용이성을 높이기 위해 응집도를 최대화한다.

- **결합도** (Coupling)  
  **정의**: 두 모듈 간의 의존 정도, 즉 한 모듈이 다른 모듈의 변경에 얼마나 영향을 받는가.  
  **목적**: 결합도를 낮춰(느슨한 결합) 시스템의 유연성과 유지보수성을 향상시킨다.

- **관심사의 분리** (Separation of Concerns, SoC)  
  **정의**: 시스템을 서로 다른 책임 또는 관심사 단위로 분리하여 설계하는 원칙.  
  **목적**: 각 구성 요소의 역할을 명확히 해 가독성, 확장성, 재사용성을 높인다.

- **단일 책임 원칙** (Single Responsibility Principle, SRP)  
  **정의**: 클래스나 함수는 오직 하나의 변경 이유만 가져야 한다.  
  **목적**: 변경의 영향 범위를 좁혀 코드의 안정성과 유지보수성을 높인다.

- **DRY 원칙** (Don’t Repeat Yourself)  
  **정의**: 동일한 지식, 로직, 정보를 시스템 내에서 중복하지 말라.  
  **목적**: 중복으로 인한 오류와 유지보수 비용을 줄이고 일관성을 유지한다.

- **KISS 원칙** (Keep It Simple, Stupid)  
  **정의**: 시스템은 가능한 한 단순하게 설계되어야 한다.  
  **목적**: 불필요한 복잡도를 제거해 이해와 유지보수를 쉽게 한다.

- **YAGNI 원칙** (You Aren’t Gonna Need It)  
  **정의**: 현재 필요하지 않은 기능은 구현하지 말라.  
  **목적**: 과도한 설계(Over-engineering)를 방지하고 개발 속도와 유연성을 높인다.

- **의존성 역전 원칙** (Dependency Inversion Principle, DIP)  
  **정의**: 상위 모듈은 하위 모듈에 의존하지 않고, 양쪽 모두 추상화(인터페이스)에 의존해야 한다.  
  **목적**: 결합도를 낮추고, 테스트 용이성 및 확장성을 높인다.

- **횡단 관심사** (Cross-cutting Concerns)  
  **정의**: 로깅, 보안, 트랜잭션 등 여러 모듈에 걸쳐 반복되는 공통 기능.  
  **목적**: SoC를 유지하기 위해 AOP, 데코레이터, 미들웨어 등을 활용해 분리한다.

- **모듈화** (Modularity)  
  **정의**: 시스템을 독립적이고 교체 가능한 단위(모듈)로 분할하는 설계 방식.  
  **목적**: 재사용성, 병렬 개발, 테스트 용이성 및 유지보수성을 향상시킨다.

- **명령-쿼리 분리 원칙** (Command-Query Separation, CQS)  
  **정의**: 메서드는 **명령**(상태를 변경) 또는 **쿼리**(값을 반환) 중 하나만 수행해야 하며, 둘 다 하면 안 된다.  
  **목적**: 부작용을 명확히 분리해 코드의 예측 가능성과 테스트 용이성을 높인다.

- **의존성 주입** (Dependency Injection, DI)  
  **정의**: 객체가 스스로 의존성을 생성하지 않고, 외부에서 주입받는 설계 패턴.  
  **목적**: 결합도를 낮추고, 유닛 테스트와 모듈 교체를 쉽게 하며 DIP를 실현한다.

- **계약에 의한 설계** (Design by Contract, DbC)  
  **정의**: 함수나 메서드가 **사전조건**(Precondition), **사후조건**(Postcondition), **불변조건**(Invariant)을 명시적으로 정의하는 방식.  
  **목적**: 인터페이스의 명확한 계약을 통해 오류를 조기에 발견하고 신뢰성을 높인다.

- **정보 은닉** (Information Hiding)  
  **정의**: 모듈 내부 구현 세부사항을 외부에 노출하지 않고, 인터페이스만 공개하는 원칙.  
  **목적**: 구현 변경이 외부에 영향을 주지 않도록 하여 유지보수성과 안정성을 확보한다.

- **리스코프 치환 원칙** (Liskov Substitution Principle, LSP)  
  **정의**: 서브타입은 언제나 기반 타입으로 대체 가능해야 하며, 프로그램의 정확성을 해쳐서는 안 된다.  
  **목적**: 상속 구조의 안정성과 예측 가능성을 보장하여 다형성을 안전하게 사용할 수 있게 한다.

- **인터페이스 분리 원칙** (Interface Segregation Principle, ISP)  
  **정의**: 클라이언트는 자신이 사용하지 않는 인터페이스 메서드에 의존하지 않아야 한다.  
  **목적**: 불필요한 의존을 줄이고, 인터페이스를 작고 목적에 맞게 분리해 유연한 설계를 가능하게 한다.

- **불변성** (Immutability)  
  **정의**: 객체가 생성된 후 상태를 변경할 수 없도록 설계하는 원칙.  
  **목적**: 동시성 안정성, 부작용 방지, 디버깅 용이성, 캐시 가능성 향상.

- **명시적 인터페이스** (Explicit Interface)  
  **정의**: 의도를 명확히 드러내는 이름과 시그니처를 가진 인터페이스를 설계하는 방식.  
  **목적**: 코드의 자기 문서화(self-documenting)를 통해 가독성과 협업 효율성을 높인다.

- **컨텍스트 경계** (Bounded Context) — 도메인 주도 설계(DDD)에서  
  **정의**: 도메인 모델이 일관된 의미와 규칙을 갖는 하나의 경계된 영역.  
  **목적**: 복잡한 시스템에서 모델의 명확성과 일관성을 유지하고, 마이크로서비스 간 경계를 정의한다.


#### 💡 선택적 추가 팁
- **SOLID 원칙** 전체를 강조하려면, 현재 목록에 **OCP, LSP, ISP**를 추가하는 것이 자연스럽습니다 (SRP, DIP는 이미 있음).
- **테스트 용이성**, **병렬 처리**, **마이크로서비스 아키텍처**와 관련된 개념이라면 **불변성**, **DI**, **Bounded Context**가 특히 유용합니다.
- **함수형 프로그래밍**과 접목한다면 **CQS**, **불변성**, **명시적 인터페이스**가 중요해집니다.


### autocomplete 기반 개입 : 최소 개입
최소 개입
### 틀을 사람이 짜고 각 컴포넌트와 같은 것을 llm 으로
웹 프론트의 (router.js, eventBus.js), 웹 백엔드 (application.propertices, interface) 와 같은 어플리케이션에 광범위한 영향을 줄수 있는 것을 사람이 통제한다
### 틀을 자연어 문서(markdown) 로 만들고 전부 llm 으로

### 단순히 어떤 앱을 만들어라고 명령 전부 llm

> ai 가 생성한 코드가 이상하더라도 치명적일 수 없도록 권한을 통제한다  
> 생성시 정확한 가이드라인을 제시
> 생성시 

### 관련 링크

[이해 부채: LLM이 만든 코드가 남기는 시한폭탄](https://codemanship.wordpress.com/2025/09/30/comprehension-debt-the-ticking-time-bomb-of-llm-generated-code/)  
=> https://news.hada.io/topic?id=23384  
  
[AI 에이전트를 위한 효과적 컨텍스트 엔지니어링](https://www.stdy.blog/korean-summary-effective-context-engineering-for-ai-agents/)   
=> https://news.hada.io/topic?id=23483  

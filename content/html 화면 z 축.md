---
title: html 화면 z 축
date: 2025-09-11T13:46:07+09:00
lastmod: 2025-10-13T13:36:25+09:00
resource-path: html 화면 z 축.md
aliases:
tags:
  - web
---
✦ 네, 더 자세히 설명해 드리겠습니다. 이 현상은 웹 브라우저가 요소를 화면에 그리는 방식, 특히 **스태킹 컨텍스트(Stacking Context)**와 `z-index`라는 개념 때문에 발생합니다. 그리고 검색 결과가 가리지 않는 이유는 검색창과 검색 결과 항목의 CSS `position` 속성 차이 때문입니다.

---

### 현상이 발생하는 원리 - 왜 검색창만 가리는가?

웹 페이지의 요소들은 단순히 2차원 평면에 있는 것이 아니라, 3차원 공간처럼 서로 겹쳐질 수 있는 '레이어(layer)' 구조를 가집니다. 어떤 요소가 다른 요소의 위나 아래에 그려질지 결정하는 규칙이 바로 '스태킹(쌓임) 순서'입니다.

1.  **기본 쌓임 순서**: 기본적으로 HTML 코드에서 나중에 나오는 요소가 먼저 나온 요소보다 위에 쌓입니다.

2.  **스태킹 컨텍스트의 형성**: 특정 CSS 속성은 요소와 그 자식들을 위한 '독립된 레이어 그룹'을 만드는데, 이를 스태킹 컨텍스트라고 합니다.
    *   대표적으로 `position` 속성이 `relative`, `absolute`, `fixed`, `sticky`이면서 `z-index`가 `auto`가 아닌 값을 가질 때 (또는 `z-index`가 없더라도 특정 조건에서), 또는 `opacity`가 1 미만일 때 등이 스태킹 컨텍스트를 형성합니다.
    *   **중요한 점은 `position: relative`만으로도 `z-index` 없이 스태킹 컨텍스트를 형성할 수 있으며, 이는 때때로 예상치 못한 쌓임 순서를 야기할 수 있다는 것입니다.**

3.  **현재 문제 상황 분석**:
    *   **탭 바 (`<nav>` 또는 `div`):** `position: sticky` 속성을 가지고 있습니다. 이 속성은 스크롤될 때 화면 특정 위치에 '달라붙게' 만듭니다. 하지만 `z-index` 값이 명시적으로 지정되지 않았습니다. `sticky` 요소는 스태킹 컨텍스트를 형성하지만, `z-index: auto`일 경우, 다른 요소들과의 쌓임 순서가 모호해질 수 있습니다. 특히 아래 설명할 `position: relative` 요소와 만났을 때 브라우저 렌더링 엔진이 헷갈리는 경우가 발생합니다.
    *   **검색창 (`<input>`):** `.src/js/ui/search-ui.js`에서 생성되는 검색창은 다음과 같은 구조를 가집니다:

        ```html
        <div class="mb-4">
            <div class="relative">  <!-- ★★★ 바로 이 부분입니다! position: relative이 적용됨 ★★★ -->
                <input type="text" id="searchInput" ...>
                ...
            </div>
        </div>
        ```

        `class="relative"`는 해당 `div`에 `position: relative;` 속성을 적용합니다. 이 `position: relative` 속성은 `z-index`가 명시되지 않더라도 **새로운 스태킹 컨텍스트를 형성**합니다.
    *   **검색 결과 (`<div>`):** 검색 결과 항목들은 `position` 속성이 명시적으로 지정되어 있지 않습니다. 즉, 기본값인 `position: static`을 가집니다. `static` 요소는 새로운 스태킹 컨텍스트를 형성하지 않으며, 일반적인 문서 흐름과 쌓임 순서를 따릅니다.

4.  **겹침 발생 원인 (검색창만 해당):**
    *   사이드바 내부에서 스크롤이 발생하면, '스크롤되는 콘텐츠' 영역(검색창 포함)과 '상단에 고정된' 영역(탭 바)이 겹치게 됩니다.
    *   이때, `z-index`가 없는 `position: sticky` 탭 바와 `z-index`가 없는 `position: relative` 검색창 컨테이너가 만나게 됩니다. 이 두 요소 모두 스태킹 컨텍스트를 형성하지만, 어느 쪽이 더 높은지 명확한 우선순위가 없습니다.
    *   **이러한 모호한 상황에서 브라우저의 렌더링 엔진은 `position: relative`를 가진 요소를 (비록 `z-index`가 `auto`여도) `position: sticky`만 있는 요소보다 더 '앞으로' 가져오려는 경향이 있습니다.** 따라서 스크롤되어 움직이는 검색창이 sticky로 고정만 되어있는 탭 바보다 높은 레이어로 판단되어 위로 올라타는 현상이 발생하는 것입니다.
    *   **검색 결과는 `position: static`이므로 스태킹 컨텍스트를 형성하지 않고, 일반적인 문서 흐름에 따라 `sticky` 요소의 아래로 자연스럽게 지나갑니다. 그래서 검색 결과는 탭 바를 가리지 않는 것입니다.**

쉽게 비유하자면, 투명한 필름(요소) 여러 장을 겹쳐 놓았는데, 각 필름의 상하 관계(`z-index`)를 명확히 지정해주지 않은 상황과 같습니다. 특히, '강력한 접착제'(`position: relative` 또는 `absolute` 같은 속성)를 사용한 필름이 '약한 접착제'(`position: sticky`만 있는 경우)를 사용한 필름보다 더 튀어나와 보이는 경향이 있는 것입니다.

---

### 코드를 변경하면 해결되는 원리

제안 드린 해결책은 탭 바의 쌓임 순서를 **가장 명확하고 강력하게** 지정하는 것입니다.

1.  **`z-10` 클래스 추가**: `index.html`의 `sticky` 속성을 가진 탭 바 `div`에 `z-10` 클래스를 추가하면, 이 요소에는 `z-index: 10;`이라는 CSS 속성이 적용됩니다.

2.  **명시적인 스태킹 컨텍스트 형성**: `position: sticky`와 `z-index: 10`이 함께 적용되면서, 탭 바는 '레벨 10'의 **가장 확실하고 강력한 독립된 스태킹 컨텍스트**를 형성합니다.

3.  **쌓임 순서 정리**:
    *   **탭 바**: 이제 '레벨 10'에 위치하게 됩니다.
    *   **검색창 컨테이너**: `position: relative`로 스태킹 컨텍스트를 형성하지만, `z-index`가 명시되지 않았으므로 '레벨 0' (기본 레벨)에 머무릅니다. 브라우저의 기본 규칙에 따라 `z-index: auto`는 명시된 `z-index` 값보다 낮은 것으로 간주됩니다.
    *   **검색 결과**: `position: static`이므로 스태킹 컨텍스트를 형성하지 않으며, `z-index`는 적용되지 않습니다. '레벨 0'보다도 더 기본층에 속합니다.

4.  **결과**: 이제 브라우저는 명확한 지시를 받았습니다. 스크롤이 일어나 검색창이나 검색 결과가 탭 바 위치로 올라오더라도, '레벨 0' 이하에 있는 검색창과 검색 결과는 '레벨 10'에 있는 탭 바의 아래를 지나가게 됩니다. 따라서 더 이상 탭 바를 덮는 현상이 발생하지 않습니다.

---

**결론적으로, `z-index`를 추가하는 것은 "이 탭 바는 다른 어떤 요소보다 항상 위에 있어야 해!"라고 브라우저에게 명확하게 알려주는 행위이며, 이를 통해 `position` 속성으로 인해 발생할 수 있는 모든 모호했던 요소 간의 상하 관계를 가장 확실하게 바로잡는 것입니다.** `position: relative`가 적용된 검색창뿐만 아니라, 향후 다른 `position` 속성을 가진 요소들이 추가되더라도 탭 바는 항상 최상단에 유지될 것입니다.

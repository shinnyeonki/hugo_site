---
title: 클라이언트 어플리케이션 구조 변화
resource-path: 클라이언트 어플리케이션 구조 변화.md
aliases:
tags:
date: 2025-10-16T16:48:03+09:00
lastmod: 2025-10-22T13:24:14+09:00
---
## 클라이언트 아키텍처의 위대한 진화: 콜백 지옥에서 선언형 UI까지

클라이언트 애플리케이션, 즉 사용자와 직접 상호작용하는 모든 소프트웨어(데스크톱 프로그램, 모바일 앱)의 개발 역사는 본질적으로 **'상태(State)와의 전쟁'**의 역사입니다. 사용자의 예측 불가능한 입력, 네트워크의 비동기적 응답, 시스템의 예기치 않은 이벤트 속에서 화면은 끊임없이 변화해야 합니다. 로딩 중, 에러 발생, 데이터 목록의 유무, 버튼의 활성화/비활성화 등, 복잡하게 얽히고설킨 상태를 어떻게 하면 ▲안정적이고 ▲테스트 가능하며 ▲유지보수하기 쉽게 관리할 수 있을까?

이 거대한 질문에 답하기 위해 아키텍처는 수십 년에 걸쳐 놀랍도록 유사한 궤적을 그리며 진화해왔습니다. 데스크톱 GUI 프로그래밍의 오랜 역사와 모바일 앱 개발의 역사는 사용하는 기술과 용어는 다를지라도, 근본적으로 같은 문제를 해결하기 위한 여정이었으며, 이는 특정 플랫폼을 넘어선 소프트웨어 공학의 보편적 원리가 존재함을 증명합니다.

이 진화의 과정은 크게 네 단계로 나눌 수 있습니다.

1.  **제1단계: 원시 시대의 혼돈, 콜백 지옥 (Callback Hell)**
2.  **제2단계: 최초의 질서와 거대해진 중재자, MVC (Model-View-Controller)**
3.  **제3단계: 테스트 가능성을 향한 여정, MVP (Model-View-Presenter)**
4.  **제4단계: 상태 관리의 자동화와 선언형 패러다임의 완성, MVVM (Model-View-ViewModel)**

이제 각 단계를 심층적으로 탐험해 보겠습니다.

---

### 제1장: 원시 시대의 혼돈, 콜백 지옥 (Callback Hell)

GUI 프로그래밍의 가장 초기 형태는 아키텍처라는 개념 없이, 단순히 이벤트와 그 이벤트를 처리할 함수를 직접 연결하는 방식이었습니다. C/C++ 기반의 순수 Win32 API나 초기 GTK, X-Window 프로그래밍이 이에 해당하며, 이는 모바일 시대의 '거대 뷰 컨트롤러'가 겪는 문제의 원형과 정확히 일치합니다.

#### **1. 핵심 구조**

이 시대의 구조는 '구조가 없는 것'이 특징입니다. 구성 요소는 단 두 가지뿐입니다.

*   **UI 요소 (View):** `CreateWindow()`, `gtk_button_new()` 같은 API를 통해 프로그래밍 방식으로 생성된 버튼, 텍스트 상자 등의 화면 요소.
*   **콜백 함수 (Callback Function):** 특정 UI 요소에서 특정 이벤트(클릭, 키 입력 등)가 발생했을 때 운영체제나 GUI 시스템에 의해 호출되도록 등록된 함수. 사실상 모든 로직이 이 함수 안에 담깁니다.

이 구조에는 역할 분리라는 개념이 존재하지 않습니다. 모든 것은 '이벤트가 발생하면 이 함수를 실행하라'는 단순한 명제로 귀결됩니다.

#### **2. 동작 방식**

1.  개발자는 화면에 필요한 UI 요소들을 코드로 생성하고 배치합니다.
2.  각 UI 요소의 특정 이벤트(예: `login_button`의 `clicked` 이벤트)에 처리 함수(`on_login_button_clicked`)를 직접 연결(등록)합니다.
3.  사용자가 버튼을 클릭하면, GUI 시스템은 등록된 콜백 함수를 호출합니다.
4.  **(문제의 지점)** 호출된 콜백 함수 내부에서 관련된 모든 작업이 순서 없이, 구분 없이 일어납니다.
    *   **다른 View에서 데이터 읽기:** 아이디 입력창(`email_entry`)과 비밀번호 입력창(`password_entry`)에서 텍스트 값을 직접 가져옵니다.
    *   **비즈니스 로직 수행:** 가져온 값으로 유효성을 검사하거나, 데이터베이스에 접근하거나, 네트워크 요청을 보내는 등의 핵심 로직을 실행합니다.
    *   **다른 View의 상태 변경:** 로직 처리 결과에 따라, 상태 메시지를 표시하는 레이블(`status_label`)의 텍스트를 바꾸거나, 다른 버튼을 비활성화시키는 등 화면의 다른 부분들을 직접 제어합니다.

#### **3. 콜백 방식을 구성하는 핵심 기술들**

이 원시적인 방식은 프레임워크의 가장 기본적인 기능들에 의존합니다.

*   **이벤트 루프 (Event Loop):** 모든 GUI 시스템의 심장입니다. 운영체제로부터 마우스 클릭, 키보드 입력, 타이머 등의 이벤트를 지속적으로 받아와 큐에 저장하고, 이를 순차적으로 처리하여 적절한 콜백 함수를 호출하는 무한 루프입니다. 개발자가 직접 제어하기보다는 시스템이 제공하는 기반 위에서 동작합니다.
*   **함수 포인터 (Function Pointers) / 시그널과 슬롯 (Signals & Slots)의 원형:** 이벤트와 처리 함수를 연결하는 '접착제' 역할을 합니다. C언어에서는 함수 포인터를 직접 전달하여 "이 이벤트가 발생하면, 이 메모리 주소에 있는 함수를 실행해"라고 알려줍니다. GTK의 `g_signal_connect`는 이러한 함수 포인터 기반의 연결을 더 체계적으로 만든 원시적인 시그널-슬롯 시스템으로 볼 수 있습니다.

#### **4. 실제 프레임워크 예시: GTK (GIMP Toolkit)**

GTK는 C언어 기반의 대표적인 GUI 툴킷으로, 초기 콜백 방식의 문제점을 명확하게 보여줍니다. 아래는 로그인 버튼 클릭 시의 동작을 콜백 함수로 구현한 상세 예시입니다.

```c
#include <gtk/gtk.h>

// 데이터베이스나 파일에서 사용자 정보를 검증하는 순수한 비즈니스 로직 함수 (가정)
gboolean perform_login(const gchar *email, const gchar *password) {
    // 실제로는 파일 I/O, DB 조회 등의 로직이 들어감
    if (g_strcmp0(email, "test@example.com") == 0 && g_strcmp0(password, "password123") == 0) {
        return TRUE;
    }
    return FALSE;
}

// 로그인 버튼이 클릭되었을 때 호출될 콜백 함수
// 이 함수 하나에 모든 책임이 집중되어 있습니다.
void on_login_button_clicked(GtkButton *button, gpointer user_data) {
    // user_data를 통해 메인 윈도우의 다른 위젯(UI 요소)들에 접근합니다.
    // 이는 이 함수가 다른 UI 요소들의 존재와 구조를 모두 알아야 함을 의미합니다. (강한 결합)
    GtkWidget *email_entry = GTK_WIDGET(g_hash_table_lookup(GTK_HASH_TABLE(user_data), "email_entry"));
    GtkWidget *password_entry = GTK_WIDGET(g_hash_table_lookup(GTK_HASH_TABLE(user_data), "password_entry"));
    GtkWidget *status_label = GTK_WIDGET(g_hash_table_lookup(GTK_HASH_TABLE(user_data), "status_label"));

    // 1. 다른 View(위젯)에서 직접 데이터를 읽어옴
    const gchar *email = gtk_entry_get_text(GTK_ENTRY(email_entry));
    const gchar *password = gtk_entry_get_text(GTK_ENTRY(password_entry));

    // 2. 비즈니스 로직을 직접 호출하여 수행
    gboolean is_login_successful = perform_login(email, password);

    // 3. 비즈니스 로직의 결과에 따라 다른 View(위젯)의 상태를 직접 변경
    if (is_login_successful) {
        gtk_label_set_text(GTK_LABEL(status_label), "Login Successful! Welcome.");
        gtk_widget_set_sensitive(GTK_WIDGET(button), FALSE); // 로그인 버튼 비활성화
    } else {
        gtk_label_set_text(GTK_LABEL(status_label), "Error: Invalid email or password.");
    }
}

int main(int argc, char *argv[]) {
    // ... GTK 초기화 및 윈도우, 버튼, 입력창 등 위젯 생성 코드 ...
    
    // 이벤트와 콜백 함수를 직접 연결하는 부분
    // "login_button"에서 "clicked" 시그널(이벤트)이 발생하면,
    // G_CALLBACK 매크로를 통해 on_login_button_clicked 함수를 호출하도록 설정합니다.
    g_signal_connect(login_button, "clicked", G_CALLBACK(on_login_button_clicked), app_widgets_hashtable);
    
    // ...
}
```

이 방식의 **치명적인 문제점**은 명확합니다.

*   **스파게티 코드 (Spaghetti Code):** `on_login_button_clicked` 함수는 UI 데이터 접근, 비즈니스 로직, UI 상태 업데이트라는 세 가지 다른 종류의 책임을 모두 떠안고 있습니다. 애플리케이션이 복잡해지면 수십 개의 콜백 함수가 서로의 상태를 읽고 변경하면서 거미줄처럼 얽히게 되어, 코드의 흐름을 추적하는 것이 불가능에 가까워집니다.
*   **재사용 불가능성:** '로그인'이라는 핵심 비즈니스 로직은 `on_login_button_clicked`라는 특정 UI 이벤트 처리 함수 내부에 갇혀 있습니다. 만약 다른 곳(예: 자동 로그인)에서 이 로직을 재사용하려면 코드를 복사-붙여넣기 하거나, 로직을 분리하기 위해 복잡한 리팩토링을 거쳐야 합니다.
*   **테스트 불가능성:** `perform_login` 함수 자체는 테스트할 수 있을지 몰라도, 이메일/비밀번호 형식에 따라 로그인 버튼이 활성화/비활성화되는 로직을 테스트하려면 어떻게 해야 할까요? 이 로직은 `gtk_entry_get_text`나 `gtk_label_set_text` 같은 GTK UI 함수에 직접적으로 의존하므로, GUI 환경을 실제로 실행하지 않고서는 단위 테스트를 작성하는 것이 거의 불가능합니다.

이러한 문제들은 필연적으로 아키텍처의 필요성을 낳았고, 그 첫 번째 대답이 바로 MVC였습니다.

---

### 제2장: 최초의 질서와 거대해진 중재자, MVC (Model-View-Controller)

MVC 패턴은 애플리케이션의 구성 요소를 세 가지 역할(Model, View, Controller)로 분리하려는 최초의 체계적인 시도였습니다. Apple과 Google이 초기에 iOS와 안드로이드 개발의 기본 패턴으로 제시하면서 모바일 개발의 시작을 열었지만, 이론의 우아함과 달리 실제 환경에서는 콜백 지옥의 문제가 다른 형태로 나타나는 한계를 보였습니다.

#### **1. 핵심 구조**

*   **Model:** 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. 데이터가 무엇인지, 어떻게 저장되고 처리되는지에 대한 규칙을 포함합니다. (예: `User` 객체, `AuthService` 클래스)
*   **View:** 사용자에게 보여지는 UI 요소를 담당합니다. (예: iOS의 `UIView`, 안드로이드의 `XML Layout`과 `View` 객체들) 사용자의 입력을 감지하여 Controller에게 전달하는 역할을 합니다.
*   **Controller:** Model과 View 사이의 중재자입니다. View로부터 사용자 입력을 받아 Model에 변경을 요청하고, Model의 데이터가 변경되면 그 결과를 가져와 View에 어떻게 표시할지 결정합니다.

#### **2. 동작 방식**

1.  사용자가 View(예: 로그인 버튼)를 터치합니다.
2.  View는 이벤트를 감지하고 이를 Controller에게 전달합니다. (예: `@IBAction` 메소드 호출)
3.  Controller는 이벤트에 맞는 로직을 수행하기 위해 Model에게 데이터 처리를 요청합니다. (예: `authService.login(...)` 호출)
4.  Model은 비즈니스 로직을 수행하고, 그 결과를 Controller에게 돌려줍니다. (예: 로그인 성공/실패 결과 반환)
5.  **(문제의 지점)** Controller는 Model로부터 받은 데이터를 가공하여 **직접 View 객체의 속성을 변경**함으로써 화면을 업데이트합니다. (예: `nameLabel.text = "홍길동"`, `loginButton.isEnabled = true`)

#### **3. MVC 패턴을 구성하는 핵심 기술들**

MVC는 객체 지향 프로그래밍의 개념을 기반으로, 플랫폼별로 다음과 같은 기술을 통해 구현됩니다.

*   **객체 지향 프로그래밍 (OOP):** MVC 자체가 역할과 책임을 객체 단위로 나눈 고전적인 디자인 패턴입니다. 각 구성 요소를 클래스로 정의하고 메시지를 통해 상호작용하는 OOP의 기본 원칙을 따릅니다.
*   **타겟-액션 (Target-Action) 매커니즘 (iOS):** 콜백 방식보다 조금 더 구조화된 이벤트 처리 방식입니다. 이벤트가 발생한 객체(예: `UIButton`)가 지정된 '타겟'(`Target`, 주로 Controller)에게 '액션'(`Action`, 특정 메소드)을 실행하라는 메시지를 보냅니다. `@IBAction`은 이 매커니즘을 시각적으로 연결해주는 기능입니다.
*   **XML 레이아웃과 ID 참조 (Android):** 안드로이드에서는 `XML`로 View의 구조를 정의하고, 각 View 요소에 고유한 `ID`를 부여합니다. Controller 역할을 하는 `Activity`나 `Fragment`는 `findViewById` 또는 최신의 `View Binding` 같은 기술을 사용하여 `ID`를 통해 View 객체에 대한 직접적인 참조를 얻어와 제어합니다.

#### **4. 실제 프레임워크 예시: iOS의 Massive View Controller**

iOS의 `UIViewController`는 이름 그대로 Controller의 역할을 하지만, 실제로는 View의 생명주기(viewDidLoad, viewWillAppear 등)를 관리하고 View 객체들을 직접 소유(`@IBOutlet`)하는 등 View의 역할도 겸합니다. 이로 인해 View와 Controller의 분리가 모호해지고 모든 책임이 `UIViewController`로 집중되는 '거대 뷰 컨트롤러' 문제가 발생합니다.

아래는 iOS MVC 패턴의 문제점을 보여주는 상세한 코드 예시입니다.

```swift
// iOS의 Massive View Controller 예시
import UIKit

// Model 레이어 (가정)
class AuthService {
    func login(email: String, password: String, completion: (Result<Bool, Error>) -> Void) {
        // 실제로는 네트워크 통신이 일어남
        if email == "test@example.com" && password.count >= 8 {
            completion(.success(true))
        } else {
            completion(.failure(NSError(domain: "AuthError", code: 401)))
        }
    }
}

class LoginViewController: UIViewController {
    
    // View 요소들을 Controller가 직접 소유하고 있습니다. (View와 Controller의 강한 결합)
    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!
    
    // Model(Service)을 Controller가 직접 소유
    let authService = AuthService()

    // View의 생명주기 관리 책임
    override func viewDidLoad() {
        super.viewDidLoad()
        // View의 초기 상태를 Controller가 직접 설정
        loginButton.isEnabled = false
        loginButton.backgroundColor = .gray
    }

    // View의 이벤트를 Controller가 직접 처리
    @IBAction func emailDidChange(_ sender: UITextField) {
        validateInput()
    }
    
    @IBAction func passwordDidChange(_ sender: UITextField) {
        validateInput()
    }

    // 이 함수 하나에 프레젠테이션 로직과 View 제어 로직이 뒤섞여 있습니다.
    private func validateInput() {
        // 1. 프레젠테이션 로직 (어떻게 보여줄지를 결정하는 로직)
        let isEmailValid = emailTextField.text?.contains("@") ?? false
        let isPasswordValid = (passwordTextField.text?.count ?? 0) >= 8
        
        // 2. View 제어 로직 (Controller가 View를 직접 제어)
        if isEmailValid && isPasswordValid {
            loginButton.isEnabled = true
            loginButton.backgroundColor = .blue
        } else {
            loginButton.isEnabled = false
            loginButton.backgroundColor = .gray
        }
    }
    
    // View의 이벤트를 처리하며 비즈니스 로직과 화면 전환 로직까지 담당합니다.
    @IBAction func loginButtonTapped(_ sender: UIButton) {
        // 1. 비즈니스 로직 호출
        authService.login(email: emailTextField.text!, password: passwordTextField.text!) { [weak self] result in
            DispatchQueue.main.async { // UI 업데이트는 메인 스레드에서
                // 2. Controller가 직접 View를 제어 (화면 전환, 얼럿 표시 등)
                switch result {
                case .success:
                    // 화면 전환 로직...
                    print("로그인 성공, 메인 화면으로 이동합니다.")
                case .failure:
                    // 얼럿(Alert)을 띄우는 View 로직...
                    let alert = UIAlertController(title: "로그인 실패", message: "아이디나 비밀번호를 확인해주세요.", preferredStyle: .alert)
                    alert.addAction(UIAlertAction(title: "확인", style: .default))
                    self?.present(alert, animated: true)
                }
            }
        }
    }
}
```

이 구조는 콜백 지옥보다 역할이 조금 분리되었을 뿐, 본질적인 문제들은 그대로 남아있습니다.

*   **과도한 책임 (Overloaded Responsibility):** `LoginViewController`는 View의 생명주기 관리, 사용자 입력 처리, 입력값 유효성 검사(프레젠테이션 로직), View의 속성 업데이트(View 제어), 비즈니스 로직 호출, 화면 전환, 에러 처리(얼럿 표시) 등 너무나 많은 책임을 집니다. 클래스가 수백, 수천 줄로 비대해져 유지보수가 재앙에 가까워집니다.
*   **강한 결합 (Tight Coupling):** Controller는 `@IBOutlet`을 통해 View의 구체적인 클래스(`UITextField`, `UIButton`)를 직접 알고 그 속성(`text`, `isEnabled`)을 변경합니다. 만약 디자이너가 `UIButton`을 커스텀 View로 교체한다면, Controller의 코드까지 수정해야 합니다. View와 Controller가 한 몸처럼 묶여있어 분리가 불가능합니다.
*   **테스트의 어려움:** `validateInput` 함수의 로직, 즉 "이메일에 @가 포함되고 비밀번호가 8자 이상이면 로그인 버튼이 활성화된다"는 중요한 정책을 테스트하고 싶다고 가정해 봅시다. 이 로직은 `emailTextField.text`와 `loginButton.isEnabled` 같은 `UIKit` 프레임워크의 구체적인 컴포넌트에 의존합니다. 따라서 이 로직을 검증하려면 iOS 시뮬레이터를 띄우고 UI 테스트를 실행해야만 합니다. 순수한 로직만 분리하여 빠르게 실행할 수 있는 **단위 테스트(Unit Test)가 거의 불가능**합니다.

결국 MVC는 '테스트'와 '역할 분리'라는 과제를 남겼고, 이를 해결하기 위해 MVP가 등장하게 됩니다.

---

### 제3장: 테스트 가능성을 향한 여정, MVP (Model-View-Presenter)

MVP(Model-View-Presenter) 패턴은 MVC의 '거대 컨트롤러'와 '테스트 불가' 문제를 정면으로 해결하기 위해 등장했습니다. 그 핵심 철학은 **View와 로직의 완벽한 분리**에 있으며, 이를 위해 '인터페이스(프로토콜)'를 통한 의존성 역전 원칙을 사용합니다.

#### **1. 핵심 구조**

*   **Model:** MVC와 동일합니다.
*   **View:** 이제 완전히 수동적이고 '멍청한(Dumb)' 존재가 됩니다. 자신의 역할은 오직 화면을 그리고, 사용자 이벤트를 Presenter에게 전달하는 것뿐입니다. View는 로직을 갖지 않습니다. 중요한 점은, View가 지켜야 할 **규칙(인터페이스/프로토콜)을 구현**한다는 것입니다. (안드로이드의 `Activity`/`Fragment`, iOS의 `UIViewController`가 이 역할을 수행합니다.)
*   **Presenter:** View와 Model 사이의 진정한 중재자. 모든 프레젠테이션 로직(데이터를 어떻게 보여줄지 결정하는 로직)을 담당합니다. 가장 큰 특징은 **Presenter가 View의 구체적인 클래스를 전혀 알지 못하고, 오직 View가 구현한 인터페이스에만 의존한다는 것**입니다. 이 덕분에 Presenter는 UI 프레임워크로부터 완벽하게 독립될 수 있습니다.

#### **2. 동작 방식**

1.  사용자가 View(버튼)를 터치합니다.
2.  View는 어떤 로직도 수행하지 않고, 자신이 소유한 Presenter의 메소드를 호출하여 이벤트를 그대로 전달합니다. (`presenter.loginButtonTapped()`)
3.  Presenter는 Model에게 데이터를 요청하고 결과를 받습니다.
4.  Presenter는 받은 데이터를 가공하여 View에 어떻게 표시할지 결정합니다.
5.  Presenter는 자신이 알고 있는 **View 인터페이스**의 메소드를 호출하여 View에게 **"무엇을 그릴지 명령"**합니다. (`view.enableLoginButton()`, `view.showLoginError(message: "에러 발생")`) View는 이 명령에 따라 실제 UI를 업데이트합니다.

#### **3. MVP 패턴을 완성하는 핵심 기술들**

MVP의 정수는 특정 프레임워크 기능이 아닌, 소프트웨어 공학 원칙의 적용에 있습니다.

*   **인터페이스 (Interfaces) / 프로토콜 (Protocols):** MVP를 가능하게 하는 **가장 핵심적인 기술**입니다. Presenter가 View의 구체적인 클래스(`LoginViewController`)에 의존하는 대신, 추상적인 규칙의 집합(`LoginView` 프로토콜)에 의존하게 만듭니다. 이는 '의존성 역전 원칙(Dependency Inversion Principle)'의 대표적인 예시로, 이로 인해 Presenter와 View의 결합이 끊어지고 Presenter를 UI 프레임워크로부터 완전히 분리할 수 있게 됩니다.
*   **모의 객체 (Mock Objects)와 의존성 주입 (Dependency Injection):** 인터페이스 덕분에 단위 테스트가 가능해집니다. 테스트 코드에서는 실제 View(`LoginViewController`) 대신, `LoginView` 프로토콜을 따르는 가짜 객체(`MockLoginView`)를 만들어 Presenter에 주입(`Injection`)할 수 있습니다. 이 모의 객체는 Presenter가 자신에게 내린 명령(`enableLoginButton`이 호출되었는가?)을 기록하고, 테스트는 이 기록을 검증함으로써 Presenter의 로직이 올바른지 확인할 수 있습니다.

#### **4. 실제 프레임워크 예시: Swift를 이용한 MVP 구현**

MVP 패턴의 정수는 인터페이스를 통한 역할 분리에 있습니다. 아래 코드는 MVC 예제를 MVP로 리팩토링한 상세 버전입니다.

```swift
import UIKit

// Model 레이어는 동일 (AuthService)

// --- MVP의 핵심: View와 Presenter 사이의 계약(Contract) 정의 ---
// 1. View가 따라야 할 규칙 (인터페이스/프로토콜)
// Presenter가 View에게 내릴 수 있는 명령들의 목록입니다.
protocol LoginView: AnyObject {
    func enableLoginButton()
    func disableLoginButton()
    func showLoginError(message: String)
    func navigateToMainScreen()
    func showLoadingIndicator()
    func hideLoadingIndicator()
}

// 2. Presenter (UI 프레임워크 코드 없음! -> import UIKit 불필요)
// 이 클래스는 순수한 Swift 코드로만 작성되어 단위 테스트가 매우 용이합니다.
class LoginPresenter {
    // Presenter는 구체적인 ViewController가 아닌, LoginView 프로토콜에만 의존합니다.
    private weak var view: LoginView?
    private let authService = AuthService()
    
    init(view: LoginView) {
        self.view = view
    }
    
    // 프레젠테이션 로직이 Controller에서 Presenter로 이동했습니다.
    func validateInput(email: String?, password: String?) {
        let isEmailValid = email?.contains("@") ?? false
        let isPasswordValid = (password?.count ?? 0) >= 8
        
        if isEmailValid && isPasswordValid {
            // View에게 "버튼을 활성화하라"고 명령합니다.
            view?.enableLoginButton()
        } else {
            // View에게 "버튼을 비활성화하라"고 명령합니다.
            view?.disableLoginButton()
        }
    }
    
    func loginButtonTapped(email: String?, password: String?) {
        guard let email = email, let password = password else { return }
        
        view?.showLoadingIndicator() // 로딩 시작 명령
        authService.login(email: email, password: password) { [weak self] result in
            self?.view?.hideLoadingIndicator() // 로딩 종료 명령
            
            switch result {
            case .success:
                self?.view?.navigateToMainScreen() // 화면 전환 명령
            case .failure:
                self?.view?.showLoginError(message: "로그인 실패") // 에러 표시 명령
            }
        }
    }
}

// 3. View (이제 훨씬 단순해지고, Presenter의 명령을 수행하는 역할만 합니다.)
class LoginViewController: UIViewController, LoginView {
    // Presenter를 소유
    var presenter: LoginPresenter!

    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!
    // ... 로딩 스피너 등 추가 UI ...

    override func viewDidLoad() {
        super.viewDidLoad()
        // 자기 자신(LoginView를 구현한 ViewController)을 Presenter에 주입하여 생성
        presenter = LoginPresenter(view: self)
    }
    
    // View는 이벤트를 받으면 생각하지 않고 Presenter에게 전달합니다.
    @IBAction func emailDidChange(_ sender: UITextField) {
        presenter.validateInput(email: sender.text, password: passwordTextField.text)
    }
    
    @IBAction func passwordDidChange(_ sender: UITextField) {
        presenter.validateInput(email: emailTextField.text, password: sender.text)
    }
    
    @IBAction func loginButtonTapped(_ sender: UIButton) {
        presenter.loginButtonTapped(email: emailTextField.text, password: passwordTextField.text)
    }
    
    // --- Presenter의 명령을 수행하는 메소드들 (LoginView 프로토콜 구현) ---
    
    func enableLoginButton() {
        loginButton.isEnabled = true
        loginButton.backgroundColor = .blue
    }
    
    func disableLoginButton() {
        loginButton.isEnabled = false
        loginButton.backgroundColor = .gray
    }
    
    func showLoginError(message: String) {
        let alert = UIAlertController(title: "에러", message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "확인", style: .default))
        present(alert, animated: true)
    }
    
    func navigateToMainScreen() {
        print("메인 화면으로 이동합니다.")
        // 화면 전환 코드 구현
    }
    
    func showLoadingIndicator() { /* 로딩 스피너 보이기 */ }
    func hideLoadingIndicator() { /* 로딩 스피너 숨기기 */ }
}
```

MVP가 이뤄낸 성과와 새로운 문제는 다음과 같습니다.

*   **해결된 점 (장점):**
    *   **최고의 테스트 용이성:** `LoginPresenter`는 `import UIKit`이 필요 없는 순수한 Swift 클래스입니다. 따라서 가짜 `MockLoginView` 객체를 만들어 주입하면, "validateInput을 호출했을 때 `view.enableLoginButton`이 정확히 호출되는가?"와 같은 모든 로직을 시뮬레이터 없이 수 밀리초 만에 검증하는 **단위 테스트**가 완벽하게 가능해졌습니다.
    *   **명확한 역할 분리:** Controller의 비대화 문제가 해결되었습니다. View는 UI 코드만, Presenter는 프레젠테이션 로직만 담당하게 되어 코드의 가독성과 유지보수성이 크게 향상되었습니다.

*   **새로운 문제점:**
    *   **View와 Presenter의 1:1 강한 결합:** 비록 인터페이스를 통해 분리했지만, 결국 Presenter는 View가 어떤 기능들을 가지고 있는지(`enableLoginButton`, `showLoginError` 등) 속속들이 알아야만 합니다. 화면이 복잡해져 View에 기능이 추가될수록, `LoginView` 프로토콜과 `LoginPresenter`는 함께 비대해지며 서로에게 강하게 묶이는 경향이 있습니다.
    *   **반복적인 코드 (Boilerplate) 증가:** `showLoading()`, `hideLoading()`, `updateText(text: String)`, `showImage(image: UIImage)` 등, 모든 사소한 UI 변경 작업을 위해 개발자는 ①프로토콜에 메소드 선언, ②Presenter에서 해당 메소드 호출, ③View에서 메소드 구현이라는 3단계의 반복적인 작업을 계속해야 합니다. 이는 개발의 피로도를 높이는 원인이 됩니다.

결국 MVP는 '테스트'라는 큰 산을 넘었지만, '반복적인 명령'이라는 새로운 과제를 남겼습니다. 이 문제를 해결하기 위해, 아키텍처는 '명령'이 아닌 '상태'에 집중하기 시작합니다. 바로 MVVM의 등장입니다.

---

### 제4장: 상태 관리의 자동화와 선언형 패러다임의 완성, MVVM (Model-View-ViewModel)

MVP의 반복적인 명령과 1:1 결합 문제를 해결하기 위해 등장한 MVVM(Model-View-ViewModel)은 클라이언트 아키텍처의 패러다임을 근본적으로 바꾸었습니다. 핵심은 **데이터 바인딩(Data Binding)** 메커니즘을 통해, Presenter의 '수동 명령'을 '상태 변화에 대한 자동 반응'으로 전환한 것입니다.

#### **1. 핵심 구조**

*   **Model:** MVC, MVP와 동일합니다.
*   **View:** 화면 UI를 담당합니다. 가장 큰 특징은 더 이상 수동적으로 명령을 기다리지 않고, **ViewModel의 상태(State)를 구독(Observe)하고 있다가, 상태가 변경되면 스스로 UI를 갱신**한다는 점입니다.
*   **ViewModel:** 'View를 위한 Model'이라는 의미로, View와 Model 사이의 중재자입니다. View에 표시될 모든 상태(예: 사용자 이름 텍스트, 버튼 활성화 여부)와 View가 실행할 로직(커맨드, 예: 로그인 버튼 클릭 시 실행할 로직)을 가집니다. **가장 혁신적인 부분은 ViewModel은 View의 존재 자체를 전혀 알지 못한다는 것입니다.** ViewModel은 그저 자신의 상태를 변경할 뿐, 이 변화가 어떻게 UI에 반영될지는 신경 쓰지 않습니다.

#### **2. 동작 방식**

1.  View는 시작 시점에 자신의 UI 속성들을 ViewModel의 상태 프로퍼티에 **바인딩(Binding)**합니다. (예: `loginButton.isEnabled` 속성을 `viewModel.isLoginEnabled` 상태에 바인딩)
2.  사용자가 View와 상호작용합니다. (예: 텍스트 필드에 이메일 입력)
3.  **(양방향 바인딩)** View에 입력된 값은 데이터 바인딩을 통해 자동으로 ViewModel의 상태 프로퍼티에 반영됩니다. (`viewModel.email = "test@test.com"`)
4.  ViewModel은 자신의 프로퍼티가 변경될 때마다, 관련된 다른 상태 프로퍼티를 비즈니스 로직에 따라 업데이트합니다. (예: `email`과 `password` 상태가 변경되면, `isLoginEnabled` 상태가 `true` 또는 `false`로 자동 계산됨)
5.  **(단방향 바인딩)** View는 ViewModel의 `isLoginEnabled` 상태를 구독(바인딩)하고 있으므로, 이 값이 `true`로 바뀌는 것을 감지하고 **스스로** 버튼을 활성화시킵니다. ViewModel이 `view.enableButton()`과 같은 명령을 전혀 하지 않습니다.

#### **3. MVVM을 완성하는 핵심 기술들**

MVVM 패턴은 프레임워크나 라이브러리의 강력한 지원을 통해 진정으로 완성됩니다.

*   **데이터 바인딩 (Data Binding):** View와 ViewModel을 연결하는 '마법의 접착제'입니다. ViewModel의 데이터(상태)가 변경되면, 데이터 바인딩 라이브러리가 이를 감지하고 View의 UI 속성을 자동으로 업데이트합니다. 이를 통해 `textView.setText(...)` 와 같은 모든 UI 조작 코드가 사라지고, View는 "이 UI 속성은 저 상태와 같다"고 선언만 하면 됩니다.
*   **반응형 프로그래밍 (Reactive Programming) 라이브러리:** 데이터의 '흐름(Stream)'을 다루는 프로그래밍 패러다임입니다. 데이터가 단일 값이 아닌, 시간의 흐름에 따라 계속 변하는 스트림이라고 보고, 이 스트림을 구독(Subscribe)하거나, 여러 스트림을 조합(Combine), 변환(Map)하는 등의 작업을 통해 상태 변화를 효과적으로 전파합니다.
    *   **AAC (Android Architecture Components):** 구글은 MVVM 패턴을 공식적으로 지원하기 위해 AAC를 발표했습니다.
        *   **ViewModel:** 생명주기를 고려하여 UI 관련 데이터를 저장하고 관리합니다. 화면 회전과 같이 `Activity`가 재생성되는 상황에서도 데이터를 안전하게 보존하여 상태 유지를 쉽게 만듭니다.
        *   **LiveData:** 관찰 가능한(Observable) 데이터 홀더 클래스입니다. 안드로이드의 생명주기를 인지하여, View가 활성 상태(STARTED, RESUMED)일 때만 데이터를 업데이트하여 메모리 누수나 비정상 종료를 방지하는 안정적인 반응형 데이터 타입입니다.
    *   **SwiftUI & Combine (iOS):** Apple은 SwiftUI와 Combine 프레임워크를 통해 MVVM 패턴을 네이티브 차원에서 강력하게 지원합니다.
        *   **SwiftUI:** UI 자체를 상태의 함수로 정의하는 선언적 UI 프레임워크입니다. 데이터(상태)가 변경되면 UI가 자동으로 다시 그려지는 구조를 가지고 있어 MVVM에 매우 적합합니다.
        *   **Combine:** 데이터의 변경을 처리하고 전파하기 위한 Apple의 공식 반응형 프로그래밍 프레임워크입니다. ViewModel은 `@Published` 프로퍼티 래퍼를 통해 데이터의 변화를 외부에 알리고(Publish), View는 이를 구독(`onReceive`)하여 UI를 갱신합니다.

#### **4. 실제 프레임워크 예시: RxSwift/Combine을 활용한 iOS의 MVVM**

아래는 반응형 라이브러리인 RxSwift를 사용하여 MVVM 패턴을 구현한 상세 예시입니다.

```swift
import UIKit
import RxSwift
import RxCocoa

// Model 레이어는 동일 (AuthService)

// 1. ViewModel (UI 프레임워크 코드 없음! -> 순수한 로직)
// ViewModel은 View의 존재를 전혀 모릅니다. 오직 상태만 외부에 노출합니다.
class LoginViewModel {
    // --- 입력 (View로부터 받는 데이터 스트림) ---
    // BehaviorRelay는 값을 가질 수 있고, 그 값의 변화를 스트림으로 외부에 알립니다.
    let email = BehaviorRelay<String>(value: "")
    let password = BehaviorRelay<String>(value: "")
    
    // --- 출력 (View가 구독할 상태 스트림) ---
    let isLoginEnabled: Observable<Bool> // 버튼 활성화 여부 상태
    let loginResult: PublishSubject<Result<Void, Error>> = PublishSubject() // 로그인 결과 상태

    private let authService = AuthService()
    private let disposeBag = DisposeBag()

    init() {
        // 'isLoginEnabled' 상태는 'email'과 'password' 상태에 의해 자동으로 결정됩니다.
        // 이것이 바로 '반응형 프로그래밍'의 핵심입니다.
        isLoginEnabled = Observable.combineLatest(email, password) { email, password in
            // 상태를 조합하여 새로운 상태를 파생
            return email.contains("@") && password.count >= 8
        }
    }

    // View로부터 '로그인' 액션이 트리거될 때 호출될 함수 (커맨드)
    func loginButtonTapped() {
        let currentEmail = email.value
        let currentPassword = password.value
        
        authService.login(email: currentEmail, password: currentPassword) { [weak self] result in
            // 비즈니스 로직 수행 후, 결과 '상태'만 업데이트합니다.
            // View에게 어떻게 하라고 명령하지 않습니다.
            switch result {
            case .success:
                self?.loginResult.onNext(.success(()))
            case .failure(let error):
                self?.loginResult.onNext(.failure(error))
            }
        }
    }
}

// 2. View (이제 ViewModel의 상태를 '바인딩'하는 역할만 합니다.)
class LoginViewController: UIViewController {
    var viewModel = LoginViewModel()
    // disposeBag은 구독을 관리하여 메모리 누수를 방지합니다.
    let disposeBag = DisposeBag()

    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!

    override func viewDidLoad() {
        super.viewDidLoad()
        bindViewModel()
    }

    // MVVM의 핵심. View와 ViewModel을 연결하는 과정입니다.
    private func bindViewModel() {
        // --- 입력 바인딩 (View의 이벤트 -> ViewModel의 상태) ---
        
        // emailTextField의 텍스트가 변경될 때마다 그 값을 viewModel.email에 전달(바인딩)
        emailTextField.rx.text.orEmpty
            .bind(to: viewModel.email)
            .disposed(by: disposeBag)
        
        // passwordTextField의 텍스트가 변경될 때마다 그 값을 viewModel.password에 전달(바인딩)
        passwordTextField.rx.text.orEmpty
            .bind(to: viewModel.password)
            .disposed(by: disposeBag)

        // loginButton이 탭(tap)될 때마다 viewModel.loginButtonTapped 함수를 실행
        loginButton.rx.tap
            .subscribe(onNext: { [weak self] in
                self?.viewModel.loginButtonTapped()
            })
            .disposed(by: disposeBag)
            
        // --- 출력 바인딩 (ViewModel의 상태 -> View의 UI 속성) ---

        // viewModel.isLoginEnabled 상태가 변경될 때마다 그 값을 loginButton.rx.isEnabled 속성에 전달(바인딩)
        // 이 한 줄이 MVP의 enable/disableLoginButton 함수와 그 호출 코드를 모두 대체합니다.
        viewModel.isLoginEnabled
            .bind(to: loginButton.rx.isEnabled)
            .disposed(by: disposeBag)

        // isLoginEnabled 상태에 따라 버튼의 배경색도 자동으로 변경
        viewModel.isLoginEnabled
            .map { isEnabled in isEnabled ? UIColor.blue : UIColor.gray } // 상태를 UI 속성 값으로 변환
            .bind(to: loginButton.rx.backgroundColor)
            .disposed(by: disposeBag)

        // viewModel.loginResult 상태를 구독하여 결과에 따라 UI 처리
        viewModel.loginResult
            .subscribe(onNext: { [weak self] result in
                switch result {
                case .success:
                    print("로그인 성공! 메인 화면으로 이동합니다.")
                case .failure:
                    // 얼럿 표시 로직
                    let alert = UIAlertController(title: "로그인 실패", message: "에러 발생", preferredStyle: .alert)
                    self?.present(alert, animated: true)
                }
            })
            .disposed(by: disposeBag)
    }
}```

MVVM이 이뤄낸 궁극의 성과는 다음과 같습니다.

*   **완벽한 분리 (Decoupling):** ViewModel은 View를 전혀 알지 못합니다. `import UIKit`조차 필요 없습니다. 이로 인해 View 로직과 상태 관리 로직이 완벽하게 분리되어, ViewModel은 100% 단위 테스트가 가능하며 재사용성 또한 극대화됩니다.
*   **명령형 코드의 제거 → 선언형 코드로의 전환:** MVP의 `view.enableButton()` 같은 명령형 코드가 사라졌습니다. 대신 **"로그인 버튼의 활성화 상태(`isEnabled`)는 ViewModel의 `isLoginEnabled` 상태와 같다"** 는 관계를 **선언(bind)**할 뿐입니다. 개발자는 더 이상 '어떻게' UI를 업데이트할지 고민하지 않고, '무엇을' 보여줄지, 즉 상태 관리에만 집중하면 됩니다.
*   **상태 관리의 명확성:** View를 표현하는 데 필요한 모든 상태(`email`, `password`, `isLoginEnabled`, `loginResult` 등)가 ViewModel에 명시적으로 선언되어 있습니다. 복잡한 화면이라도 ViewModel의 상태 프로퍼티만 보면 어떤 상태들이 존재하는지 한눈에 파악할 수 있어, 상태를 추적하고 관리하기 매우 용이합니다.

---

### 최종 결론: 상태를 지배하는 아키텍처를 향한 위대한 여정

클라이언트 아키텍처의 발전사는 **'어떻게(How)'** UI를 조작할 것인가에 대한 고민에서 **'무엇(What)'** 을 보여줄 것인가에 대한 고민으로의 전환 과정이었습니다.

| 구분 | **1세대: 콜백 지옥/MVC** | **2세대: MVP** | **3세대: MVVM** |
| :--- | :--- | :--- | :--- |
| **핵심 철학** | 모든 것을 하나의 함수/컨트롤러에서 처리 | Presenter가 View에게 **명령** | ViewModel의 **상태**를 View가 **구독/바인딩** |
| **패러다임** | 명령형 (UI를 직접 조작) | 명령형 (UI 조작을 지시) | **선언형** (상태를 선언하면 UI가 반응) |
| **View-중재자 관계** | 강한 결합 | 1:1 강한 결합 (인터페이스 경유) | **느슨한 결합 (결합 없음)** |
| **테스트 용이성**| 어려움 | 높음 (Presenter 테스트 가능) | **매우 높음** (ViewModel 테스트 매우 용이) |
| **주요 동기**| 기본 구조 제공 | **테스트**와 **역할 분리** | **상태 관리 자동화**와 **반복 코드 제거** |

백엔드 아키텍처가 의존성 주입(DI)을 통해 각 컴포넌트의 결합을 끊어내고 유연성을 확보했다면, 클라이언트 아키텍처는 **데이터 바인딩**과 **반응형 프로그래밍**을 통해 View와 로직의 결합을 끊어내고 복잡한 상태를 효과적으로 관리하는 방향으로 진화했습니다.

오래 지속되고 복잡하게 얽히는 '상태'를 안정적으로 관리하고, 변화에 유연하며, 테스트 가능한 코드를 작성하는 능력. 이것이 바로 콜백 지옥에서 시작하여 MVVM에 이르는 기나긴 여정이 우리에게 가르쳐주는 핵심 교훈이자, 현대 클라이언트 애플리케이션 개발자가 갖춰야 할 가장 중요한 역량입니다.

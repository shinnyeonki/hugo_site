---
title: 기본적인 웹 서버를 처음부터 작성하기
date: 2025-06-09
lastmod: 2025-10-24T20:53:41+09:00
resource-path: 05.clipping/기본적인 웹 서버를 처음부터 작성하기.md
source: https://www.codeproject.com/Articles/859108/Writing-a-Web-Server-from-Scratch
author: 
published: 
description: For those who code
tags:
  - clippings
  - build-your-own-x
---
제목: 기본적인 웹 서버를 처음부터 작성하기 - CodeProject  
마크 클리프턴  
4.99/5 (102표)  
2015년 1월 2일  
CPOL 23분 읽기  
214151  

많은 요청에 의해, 여기에 제가 650줄 미만의 코드로 작성한 가벼운 웹 서버에 대한 내용을 설명합니다.

소개
---
주로 재미삼아, 저는 제 자신의 웹 서버를 작성하는 것이 무엇이 필요한지 알아보려고 했습니다. 그리고 매우 흥미로운 아이디어와 브라우저의 기대를 충족시키는 방법, 그리고 간단하고 빠른 웹 서버를 만드는 즐거움을 발견하게 되었습니다. 따라서 이 글(며칠 전에 여러 사람들에게 요청받은 것처럼)에서는 이 과정을 설명하려고 합니다. 현재 구현된 기능에는 다음과 같은 것들이 포함됩니다:

* 경로 설정
* 세션 관리자
* 인증
* 만료된 세션

웹 서버가 매우 가볍기 때문에 복잡한 플러그인 아키텍처를 구현할 필요는 없었습니다. 세 가지 핵심 파일이 있습니다:
* Listener.cs - HttpListener를 사용하여 연결을 수신 및 응답
* Router.cs - 경로 관리
* SessionManager.cs - 연결 세션 상태 관리

### 한마디로 소회(또는 몇 마디)
이 웹 서버가 무엇이 아닌지를 명확히 하겠습니다. 다음의 것들을 찾을 수 없습니다:
* ORM(객체관계매핑) - ORM은 웹 서버에서 절대적으로 사용되어서는 안 됩니다.
* MVC(모델뷰컨트롤러) - MVC 개념은 필요없는 아키텍처로, Ruby on Rails 개발자를 Microsoft 기술에 익숙하게 만들기 위한 것입니다.
* 웹 페이지 또는 특별한 문법으로 HTML 파일을 컴파일하지 않음 - 현대적인 jQuery 기반 컨트롤러(jqwidgets)와 JSON 및 AJAX를 사용한다면, C#이나 다른 언어 요소를 삽입하여 HTML 파일을 명령형적으로 변환하는 것은 불필요합니다. 그렇게 하면:
  * 페이지를 제공하는 속도가 느려짐
  * 뷰 상태를 결정하는 로직이 뷰에 혼합되어야 함
  * 복잡한 렌더링이 필요한 경우, 이를 더 나은 구조화된 방식으로 처리하는 것이 좋습니다.
* 어트리뷰트(Attribute) - 어트리뷰트는 직렬화를 위한 힌트를 주는 데만 사용해야 합니다. 그렇지 않다면 일반적으로 잘못된 설계를 촉진합니다. 예를 들어, 경로는 `Route` 기본 클래스와 `AuthenticatedRoute` 자식 클래스로 구현됩니다. 역할 기반 인증을 원하면, 빈 컨트롤러 함수를 장식하는 대신 파생 클래스를 작성하면 됩니다. MVC나 다른 프레임워크에서 제공하는 디자인 패턴을 강제로 사용하는 대신, 더 나은 객체 지향적 설계를 적용해야 합니다. 이는 반복되는 성능 저하를 초래하며, '이 메서드는 인증되었나요?', '이 메서드는 권한이 있나요?' 같은 작업을 반복적으로 반사적으로 확인하게 만듭니다. 다시 말하지만, 이는 끔찍한 설계입니다.
* IIS - 더 이상 필요 없는 불필요한 부하와 복잡한 설정 문제를 해결하기 위해 필요 없습니다.

무언가 아이러니한 점은(이것이 마지막 소회입니다), 제가 직접 웹 서버를 구현한 후, MVC Razor이나 Ruby on Rails와 같은 기술들이 실제로 웹 페이지를 제공하고 프로그래머가 서버 사이드 프로세스에 집중할 수 있도록 돕는 것보다 오히려 방해가 된다는 것을 깨달았습니다. 간단한 웹 서버를 사용하면, 저는 클라이언트 사이드 JavaScript, HTML, 구성 요소에 더 집중할 수 있습니다. 서버 사이드 프로세스에 주의를 기울이는 유일한 부분은 PUT 핸들러와 가끔씩 AJAX 요청입니다. MVC, 복잡한 라우팅 문법, 컨트롤러 함수를 장식하는 어트리뷰트 등은 모두 웹 애플리케이션 작성의 상태를 매우 열악하게 만듭니다.

소스 코드 저장소에 관해서
---
소스 코드는 GitHub에 호스팅되어 있습니다:
git clone https://github.com/cliftonm/BasicWebServer.git

이 문서 작성 과정에 관해서
---
저는 단순히 최종 웹 서버를 보여주는 대신, 공백 상태에서 웹 서버를 어떻게 구축하는지 단계별로 기록하는 것이 훨씬 더 흥미롭다고 생각합니다. 독자 여러분이 설계와 구현 결정 과정(좋거나 나쁜 것 모두)을 이해할 수 있도록 하고 싶습니다. 저는 이 접근 방식이 여러분에게 즐거움을 줄 것이라고 확신합니다.

Step 1 - HttpListener
---------------------
첫 번째 단계는 `HttpListener` 클래스를 작동시키는 것입니다. 낮은 수준의 소켓 대신 사용하는 이유는 `HttpListener`가 HTML 요청을 디코딩하는 등의 유용한 서비스를 제공하기 때문입니다. 성능이 낮을 수 있다는 사실은 알고 있지만, 저는 약간의 성능 저하에는 크게 신경 쓰지 않습니다.

웹 서버는 라이브러리로 구현되었습니다. 특정 웹 애플리케이션 실행 파일은 콘솔 애플리케이션입니다. 이 첫 단계에서는 웹 서버가 다음을 필요로 합니다:
using System.Net;
using System.Net.Sockets;
using System.Threading;

웹 서버는 상태가 거의 없으므로(세션 객체를 제외하고) 대부분의 동작을 정적 싱글톤으로 구현할 수 있습니다.

```csharp
namespace Clifton.WebServer
{
    /// <summary>
    /// A lean and mean web server.
    /// </summary>
    public static class Server
    {
        private static HttpListener listener;
        ...
    }
```

로컬 호스트의 IP 주소를 얻는다 가정하고 시작하겠습니다.
```csharp
/// <summary>
/// Returns list of IP addresses assigned to localhost network devices, such as hardwired ethernet, wireless, etc.
/// </summary>
private static List<IPAddress> GetLocalHostIPs()
{
    IPHostEntry host;
    host = Dns.GetHostEntry(Dns.GetHostName());
    List<IPAddress> ret = host.AddressList.Where(ip => ip.AddressFamily == AddressFamily.InterNetwork).ToList();
    return ret;
}
```

HttpListener 인스턴스를 초기화하고 로컬 호스트 접두사를 추가합니다.
```csharp
private static HttpListener InitializeListener(List<IPAddress> localhostIPs)
{
    HttpListener listener = new HttpListener();
    listener.Prefixes.Add("http://localhost/");
    // Listen to IP address as well.
    localhostIPs.ForEach(ip =>
    {
        Console.WriteLine("Listening on IP " + "http://" + ip.ToString() + "/");
        listener.Prefixes.Add("http://" + ip.ToString() + "/");
    });
    return listener;
}
```

웹 서버는 일반적으로 여러 로컬 호스트 IP를 가집니다. 예를 들어, 내 노트북은 유선 및 무선 "포트"에 각각 IP를 가지고 있습니다.

Sacha의 A Simple REST Framework에서 차용한 개념처럼, 동시 허용 연결 수를 제한하기 위한 세마포어(semaphore)를 설정합니다.
```csharp
public static int maxSimultaneousConnections = 20;
private static Semaphore sem = new Semaphore(maxSimultaneousConnections, maxSimultaneousConnections);
```

이것은 작업 스레드에서 실행되며 Task.Run을 사용하여 호출됩니다:
```csharp
/// <summary>
/// Begin listening to connections on a separate worker thread.
/// </summary>
private static void Start(HttpListener listener)
{
    listener.Start();
    Task.Run(() => RunServer(listener));
}

/// <summary>
/// Start awaiting for connections, up to the "maxSimultaneousConnections" value.
/// This code runs in a separate thread.
/// </summary>
private static void RunServer(HttpListener listener)
{
    while (true)
    {
        sem.WaitOne();
        StartConnectionListener(listener);
    }
}
```

마지막으로, 연결 리스너를 비동기적으로 구현합니다:
```csharp
/// <summary>
/// Await connections.
/// </summary>
private static async void StartConnectionListener(HttpListener listener)
{
    // Wait for a connection. Return to caller while we wait.
    HttpListenerContext context = await listener.GetContextAsync();
    // Release the semaphore so that another listener can be immediately started up.
    sem.Release();
    // We have a connection, do something...
}
```

그러면 다음과 같이 응답합니다:
```csharp
string response = "Hello Browser!";
byte[] encoded = Encoding.UTF8.GetBytes(response);
context.Response.ContentLength64 = encoded.Length;
context.Response.OutputStream.Write(encoded, 0, encoded.Length);
context.Response.OutputStream.Close();
```

그리고 공개적인 Start 메서드를 추가합니다:
```csharp
/// <summary>
/// Starts the web server.
/// </summary>
public static void Start()
{
    List<IPAddress> localHostIPs = GetLocalHostIPs();
    HttpListener listener = InitializeListener(localHostIPs);
    Start(listener);
}
```

콘솔 애플리케이션에서 서버를 시작할 수 있습니다:
```csharp
using System;
using Clifton.WebServer;
namespace ConsoleWebServer
{
    class Program
    {
        static void Main(string[] args)
        {
            Server.Start();
            Console.ReadLine();
        }
    }
}
```

그러면 시작됩니다:
### 항상 브라우저의 웹 콘솔 창을 확인하세요
브라우저의 웹 콘솔 창은 여러분이 무엇을 잘못했는지 알려줍니다. 예를 들어, 위의 테스트 사례에서 우리는 인코딩을 고려해야 한다는 것을 배웁니다. HTML에서 다음과 같이 해야 합니다:
```csharp
string response = "<html><head><meta http-equiv='content-type' content='text/html; charset=utf-8'/>
</head>Hello Browser!</html>";
```

이것은 단순한 예제이므로 지금은 이것으로 그만 두겠습니다. 나중에 우리가 더 많은 실수를 발견하게 될 것입니다!

Step 2 - 로깅
---------------
먼저 로깅을 추가합시다. 로깅은 어떤 종류의 요청이 우리의 웹 서버에 이루어지고 있는지 볼 수 있기 때문에 매우 유용합니다.
```csharp
Log(context.Request);
/// <summary>
/// Log requests.
/// </summary>
public static void Log(HttpListenerRequest request)
{
    Console.WriteLine(request.RemoteEndPoint + " " + request.HttpMethod + " /" + request.Url.AbsoluteUri.RightOf('/', 3));
}
```

원격 로거를 사용할 수도 있습니다. 예를 들어, 저는 여기에서 PaperTrailApp에 대해 이야기했습니다.

Log 호출을 세마포어를 해제한 직후에 추가합니다:
```csharp
Log(context.Request);
```

### 로깅 추가 후 관찰한 내용
로깅을 추가한 후 즉시 브라우저는 기본 페이지를 요청할 뿐만 아니라 favicon.ico도 요청한다는 것을 알게 됩니다!
우리는 이것에 대해 무언가를 해야 합니다!

Step 3 - 콘텐츠 제공: 기본 라우팅
--------------------------------
물론 웹 페이지를 C# 문자열로 작성하는 것은 바람직하지 않습니다. 따라서 우리의 웹 애플리케이션 구조를 간단히 만들어보겠습니다. 이 구조는 완전히 임의적이지만, 모든 것이 "Website" 폴더 아래에서 시작한다고 가정하겠습니다. "Website" 아래에는 다음과 같은 폴더들이 있습니다:
* Pages: 모든 페이지의 루트
* CSS: 모든 .css 및 관련 파일
* Scripts: 모든 .js 파일
* Images: 모든 이미지 파일

일부 기본 기능을 처리하기 위해 간단한 라우터를 설정해야 합니다. 우리의 첫 번째 버전은 단순히 URL 경로와 요청 확장자에 따라 "Website" 폴더 및 하위 폴더에서 파일을 찾아서 응답합니다. 먼저 URL 요청에서 몇 가지 정보를 추출합니다:
```csharp
HttpListenerRequest request = context.Request;
string path = request.RawUrl.LeftOf("?"); // Only the path, not any of the parameters
string verb = request.HttpMethod; // get, post, delete, etc.
string parms = request.RawUrl.RightOf("?"); // Params on the URL itself follow the URL and are separated by a ?
Dictionary<string, string> kvParams = GetKeyValues(parms); // Extract into key-value entries.
```

이제 이 정보를 라우터에 전달합니다:
```csharp
router.Route(verb, path, kvParams);
```

라우터는 정적일 수 있지만, 몇 가지 잠재적인 이점이 있으므로 실제로 인스턴스로 초기화하기로 결정했습니다:
```csharp
private static Router router = new Router();
```

웹 사이트 경로의 실제 경로는 조금 어색하게 얻어야 할 수 있습니다. 예를 들어, 저는 콘솔 프로그램을 bin\debug 폴더에서 실행 중입니다. 따라서 웹 사이트 경로는 실제로 "..\\..\\Website"입니다. 경로를 얻는 방법은 다음과 같습니다:
```csharp
public static string GetWebsitePath()
{
    // Our exe's path.
    string websitePath = Assembly.GetExecutingAssembly().Location;
    websitePath = websitePath.LeftOfRightmostOf("\\\\").LeftOfRightmostOf("\\\\").LeftOfRightmostOf("\\\\") + "\\\\Website";
    return websitePath;
}
```

웹 서버에 이 경로를 전달하여 라우터를 구성합니다:
```csharp
public static void Start(string websitePath)
{
    router.WebsitePath = websitePath;
    ...
```

몇 가지 확장자와 해당 로더 위치를 매핑하는 사전을 설정합니다. 다른 함수를 사용하여 데이터베이스에서 콘텐츠를 로드할 수도 있습니다.
```csharp
public class Router
{
    public string WebsitePath { get; set; }
    private Dictionary<string, ExtensionInfo> extFolderMap;
    public Router()
    {
        extFolderMap = new Dictionary<string, ExtensionInfo>() 
        {
            {"ico", new ExtensionInfo() {Loader=ImageLoader, ContentType="image/ico"}},
            {"png", new ExtensionInfo() {Loader=ImageLoader, ContentType="image/png"}},
            {"jpg", new ExtensionInfo() {Loader=ImageLoader, ContentType="image/jpg"}},
            {"gif", new ExtensionInfo() {Loader=ImageLoader, ContentType="image/gif"}},
            {"bmp", new ExtensionInfo() {Loader=ImageLoader, ContentType="image/bmp"}},
            {"html", new ExtensionInfo() {Loader=PageLoader, ContentType="text/html"}},
            {"css", new ExtensionInfo() {Loader=FileLoader, ContentType="text/css"}},
            {"js", new ExtensionInfo() {Loader=FileLoader, ContentType="text/javascript"}},
            {"", new ExtensionInfo() {Loader=PageLoader, ContentType="text/html"}},
        };
    }
    ...
```

주의할 점은 "확장자가 없는" 경우를 처리하는 것입니다. 이를 통해 콘텐츠가 기본적으로 HTML 페이지로 간주되도록 합니다.
또한 콘텐츠 타입을 설정하는 것도 중요합니다. 이를 하지 않으면 웹 콘솔에서 콘텐츠 타입이 특정 값으로 가정된다는 경고를 받게 됩니다.
마지막으로 로딩을 수행하는 함수를 지정하는 것도 주목해야 합니다.

### 이미지 로더
```csharp
/// <summary>
/// Read in an image file and returns a ResponsePacket with the raw data.
/// </summary>
private ResponsePacket ImageLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
    FileStream fStream = new FileStream(fullPath, FileMode.Open, FileAccess.Read);
    BinaryReader br = new BinaryReader(fStream);
    ResponsePacket ret = new ResponsePacket() { Data = br.ReadBytes((int)fStream.Length), ContentType = extInfo.ContentType };
    br.Close();
    fStream.Close();
    return ret;
}
```

### 파일 로더
```csharp
/// <summary>
/// Read in what is basically a text file and return a ResponsePacket with the text UTF8 encoded.
/// </summary>
private ResponsePacket FileLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
    string text = File.ReadAllText(fullPath);
    ResponsePacket ret = new ResponsePacket() { Data = Encoding.UTF8.GetBytes(text), ContentType = extInfo.ContentType, Encoding = Encoding.UTF8 };
    return ret;
}
```

### 페이지 로더
페이지 로더는 다음과 같은 옵션을 처리해야 합니다:
* foo.com
* foo.com\index
* foo.com\index.html
이 모든 경우에 Pages\index.html를 로드합니다.
```csharp
/// <summary>
/// Load an HTML file, taking into account missing extensions and a file-less IP/domain, 
/// which should default to index.html.
/// </summary>
private ResponsePacket PageLoader(string fullPath, string ext, ExtensionInfo extInfo)
{
    ResponsePacket ret = new ResponsePacket();
    if (fullPath == WebsitePath) // If nothing follows the domain name or IP, then default to loading index.html.
    {
        ret = Route(GET, "/index.html", null);
    }
    else
    {
        if (String.IsNullOrEmpty(ext))
        {
            // No extension, so we make it ".html"
            fullPath = fullPath + ".html";
        }
        // Inject the "Pages" folder into the path
        fullPath = WebsitePath + "\\Pages" + fullPath.RightOf(WebsitePath);
        ret = FileLoader(fullPath, ext, extInfo);
    }
    return ret;
}
```

몇 가지 도우미 클래스가 있습니다:
```csharp
public class ResponsePacket
{
    public string Redirect { get; set; }
    public byte[] Data { get; set; }
    public string ContentType { get; set; }
    public Encoding Encoding { get; set; }
}
internal class ExtensionInfo
{
    public string ContentType { get; set; }
    public Func<string, string, string, ExtensionInfo, ResponsePacket> Loader { get; set; }
}
```

이 모든 것을 통합하여 파일에서 콘텐츠를 로드하는 기본적인 라우터를 구현할 수 있습니다.
```csharp
public ResponsePacket Route(string verb, string path, Dictionary<string, string> kvParams)
{
    string ext = path.RightOf('.');
    ExtensionInfo extInfo;
    ResponsePacket ret = null;
    if (extFolderMap.TryGetValue(ext, out extInfo))
    {
        // Strip off leading '/' and reformat as with windows path separator.
        string fullPath = Path.Combine(WebsitePath, path);
        ret = extInfo.Loader(fullPath, ext, extInfo);
    }
    return ret;
}
```

마지막으로 테스트 응답을 제거하고 라우터에서 반환된 콘텐츠로 대체하는 작업을 진행해야 합니다:
```csharp
private static void Respond(HttpListenerResponse response, ResponsePacket resp)
{
    response.ContentType = resp.ContentType;
    response.ContentLength64 = resp.Data.Length;
    response.OutputStream.Write(resp.Data, 0, resp.Data.Length);
    response.ContentEncoding = resp.Encoding;
    response.StatusCode = (int)HttpStatusCode.OK;
    response.OutputStream.Close();
}
```

이제 이것으로 기본적인 웹 서버를 구현했습니다.

이제 HTML을 볼 수 있습니다:
```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<script type="text/javascript" src="/Scripts/jquery-1.11.2.min.js"></script>
<link type="css" rel="Stylesheet" href="/CSS/demo.css"/>
<title>Button Click Demo</title>
<script type="text/javascript">
$(document).ready(function () {
    $("#me").click(function () {
        alert("I've been clicked!");
    });
});
</script>
</head>
<body>
<div class="center-inner top-margin-50">
<input class="button" type="button" value="Click Me" id="me"/>
</div>
</body>
</html>
```

사이트 구조는 다음과 같습니다:

우리의 작은 데모 페이지는 잘 작동합니다!
여기에서 몇 가지 중요한 점을 알 수 있습니다:
1. 물론, favicon.ico가 로드되고 있습니다(당신이 궁금하다면, 팔mtree입니다).
2. 페이지는 물론 로드되고 있습니다.
3. 스타일 시트는 작동합니다.
4. jQuery 스크립트는 작동합니다.

이것은 모두 멋지고 잘 작동하지만:
* 알 수 없는 확장자는 처리되지 않습니다.
* 존재하지 않는 콘텐츠는 처리되지 않습니다.
* 콘텐츠 로딩 오류는 처리되지 않습니다.
* 동사는 항상 "get"으로 가정됩니다.
* 응용 프로그램은 로드된 콘텐츠(특히 HTML)를 조작할 기회가 없습니다.
* 라우팅을 재정의할 수 없습니다.
* 권한 있는 콘텐츠에 대한 개념이 없습니다.
* 세션 기간은 고려되지 않았습니다.
* 예외 처리는 고려되지 않았습니다.
* 리다이렉트는 처리되지 않습니다.

이러한 모든 문제를 해결해야 하지만, 이 시점에서 우리는 페이지를 CSS와 자바스크립트로 만들 수 있습니다.

여기서 드러난 몇 가지 중요한 점은 콘텐츠 파일의 실제 위치를 서버에서 완전히 속이는 것이 가능하다는 것입니다. 위 코드에서 모든 HTML 콘텐츠를 Pages 폴더 아래에 넣어 루트 위치를 속였습니다. 우리는 다른 것도 할 수 있습니다 - 데이터베이스에서 데이터를 로드하거나, 다른 서버와 통신하거나, 데이터로부터 동적으로 페이지를 생성하는 등. 이러한 기능들은 기본 콘텐츠 로딩을 넘어선 기능을 탐구하면서 살펴볼 것입니다.

Step 4 - 디테일에서 문제를 다루다
--------------------------------
이제 위에서 언급된 문제를 해결해 보겠습니다.

### 에러 페이지
우리는 몇 가지 에러 페이지를 추가할 것입니다. 현재는 모두 사용되지 않지만:
* 만료된 세션
* 권한 없음
* 페이지 없음
* 서버 오류
* 알 수 없는 형식

여기서 여러분은 서버가 만료된 세션과 인증 실패에 대해 알고 있다고 의아해할 수 있습니다. 하지만 이것은 매우 타당합니다. 이 에러는 라우팅에 필수적이지만, 에러 상태는 웹 애플리케이션에서 결정됩니다(서버에서 결정되지 않음). 서버가 하는 일은 단순히 웹 애플리케이션에서 상태를 질의하는 것입니다. 나중에 자세히 설명하겠습니다.

우리는 응용 프로그램이 에러에 대한 페이지 위치를 결정하도록 설정할 수 있어야 합니다. 이를 위해 서버에 다음 열거형을 추가합니다:
```csharp
public enum ServerError
{
    OK,
    ExpiredSession,
    NotAuthorized,
    FileNotFound,
    PageNotFound,
    ServerError,
    UnknownType,
}
```

이제 에러를 처리할 수 있습니다(예외를 던지지 않고). 우선 알 수 없는 확장자를 처리합니다:
```csharp
if (extFolderMap.TryGetValue(ext, out extInfo))
{
    ...
}
else
{
    ret = new ResponsePacket() { Error = Server.ServerError.UnknownType };
}
```

그리고 웹 애플리케이션이 에러 처리를 위해 제공할 수 있는 콜백을 사용합니다. 이 형태는 사용자가 이동해야 하는 페이지를 지정하는 것입니다.
```csharp
ResponsePacket resp = router.Route(verb, path, kvParams);
if (resp.Error != ServerError.OK)
{
    resp = router.Route("get", onError(resp.Error), null);
}
Respond(context.Response, resp);
```

웹 애플리케이션에서 직접적인 에러 처리기를 구현합니다:
```csharp
public static string ErrorHandler(Server.ServerError error)
{
    string ret = null;
    switch (error)
    {
        case Server.ServerError.ExpiredSession:
            ret = "/ErrorPages/expiredSession.html";
            break;
        case Server.ServerError.FileNotFound:
            ret = "/ErrorPages/fileNotFound.html";
            break;
        case Server.ServerError.NotAuthorized:
            ret = "/ErrorPages/notAuthorized.html";
            break;
        case Server.ServerError.PageNotFound:
            ret = "/ErrorPages/pageNotFound.html";
            break;
        case Server.ServerError.ServerError:
            ret = "/ErrorPages/serverError.html";
            break;
        case Server.ServerError.UnknownType:
            ret = "/ErrorPages/unknownType.html";
            break;
    }
    return ret;
}
```

물론 에러 처리기를 초기화해야 합니다:
```csharp
Server.onError = ErrorHandler;
```

이제 몇 가지 테스트를 해볼 수 있습니다. 물론 애플리케이션은 더 정교한 메시지를 원할 수 있습니다!

#### 알 수 없는 형식 오류
#### 페이지를 찾을 수 없음
#### 파일을 찾을 수 없음

### 리다이렉트
URL이 위의 에러 메시지에서 변경되지 않는 것을 눈치채셨을 겁니다. 이는 리다이렉트가 작동하지 않았기 때문입니다. 이제 이를 수정하겠습니다:
우리는 에러 핸들러가 항상 다른 페이지로 리다이렉트하도록 가정합니다. 따라서 응답을 처리하는 방식을 변경합니다. 이전에는 새로운 `ResponsePacket`를 가져와 브라우저에 해당 콘텐츠를 다시 보내고 있었습니다. 이제는 웹 애플리케이션이 우리에게 가리킬 페이지의 `Redirect` 속성을 설정하도록 합니다. 이는 기본적으로 모든 리다이렉트 메커니즘입니다.
```csharp
if (resp.Error != ServerError.OK)
{
    resp.Redirect = onError(resp.Error);
}
```
또한 `Respond` 메서드에서 약간의 리팩토링을 수행합니다:
```csharp
private static void Respond(HttpListenerRequest request, HttpListenerResponse response, ResponsePacket resp)
{
    if (String.IsNullOrEmpty(resp.Redirect))
    {
        response.ContentType = resp.ContentType;
        response.ContentLength64 = resp.Data.Length;
        response.OutputStream.Write(resp.Data, 0, resp.Data.Length);
        response.ContentEncoding = resp.Encoding;
        response.StatusCode = (int)HttpStatusCode.OK;
    }
    else
    {
        response.StatusCode = (int)HttpStatusCode.Redirect;
        response.Redirect("http://" + request.UserHostAddress + resp.Redirect);
    }
    response.OutputStream.Close();
}
```

참고로, 출력 스트림을 닫는 것은 매우 중요합니다. 닫지 않으면 브라우저가 데이터를 기다리다가 멈추게 될 수 있습니다.

이제 리다이렉트가 작동합니다:
#### 예외 처리
우리는 예외를 처리하기 위해 동일한 리다이렉트 메커니즘을 사용합니다. `GetContextAsync`의 연속 실행을 try-catch 블록으로 감쌉니다:
```csharp
catch(Exception ex)
{
    Console.WriteLine(ex.Message);
    Console.WriteLine(ex.StackTrace);
    resp = new ResponsePacket() { Redirect = onError(ServerError.ServerError) };
}
```

이렇게 처리된 시뮬레이션 오류는 다음과 같습니다:

Step 5 - 검토 및 추가 문제 해결
---------------------------------
현재 어디까지 왔나요?
* 알 수 없는 확장자는 처리되지 않습니다.
* 존재하지 않는 콘텐츠는 처리되지 않습니다.
* 콘텐츠 로딩 오류는 처리되지 않습니다.
* 동사는 항상 "get"으로 가정됩니다.
* 응용 프로그램은 로드된 콘텐츠(특히 HTML)를 조작할 기회가 없습니다.
* 라우팅을 재정의할 수 없습니다.
* 권한 있는 콘텐츠에 대한 개념이 없습니다.
* 세션 기간은 고려되지 않았습니다.
* 예외 처리는 고려되지 않았습니다.
* 리다이렉트는 처리되지 않습니다.

이제 동사를 처리하도록 하겠습니다. 특히 POST 동사를 처리할 것입니다. 이는 다음 세 가지 사항을 해결하는 데 도움이 됩니다.

### 동사
HTTP 요청에 동반될 수 있는 동사에는 여러 가지가 있습니다:
* OPTIONS
* GET
* HEAD
* POST
* PUT
* DELETE
* TRACE
* CONNECT

본질적으로 웹 서버는 동사에 대해 신경 쓰지 않습니다. 동사는 단순히 응답을 처리하기 위한 핸들러를 호출하는 추가적인 정보를 제공합니다. 이제까지 피했던 주제 중 하나가 컨트롤러입니다. 내가 구현한 웹 서버는 MVC 패턴을 강제하거나 웹 애플리케이션 개발자가 MVC 패턴을 따르도록 강제하지 않습니다. 대신 간단한 메커니즘을 제공하여 동사와 경로를 핸들러에 매핑합니다. 이것이 서버가 할 수 있는 모든 것입니다. 핸들러는 브라우저가 다른 페이지로 리다이렉트해야 하는지 아니면 현재 페이지에 머물러야 하는지를 결정합니다. 백그라운드에서 핸들러는 다른 작업을 수행할 수 있지만, 웹 서버의 관점에서 이는 서버가 신경 쓰는 모든 것입니다.

### 라우팅
우리는 기본적인 라우터를 추가하기로 합니다. 이는 `Route` 클래스로 구성됩니다:
```csharp
public class Route
{
    public string Verb { get; set; }
    public string Path { get; set; }
    public Func<Dictionary<string,string>, string> Action { get; set; }
}
```

Action 속성은 URL 매개변수를 전달하는 콜백 함수이며, 나중에 POST 매개변수를 처리할 것입니다.

우리는 라우터 테이블에 라우트를 추가하는 간단한 메서드를 추가합니다:
```csharp
public void AddRoute(Route route)
{
    routes.Add(route);
}
```

이제 라우터를 호출하여 애플리케이션 특정 핸들러를 실행할 수 있습니다. 라우터 메서드를 리팩토링합니다:
```csharp
public ResponsePacket Route(string verb, string path, Dictionary<string, string> kvParams)
{
    string ext = path.RightOfRightmostOf('.');
    ExtensionInfo extInfo;
    ResponsePacket ret = null;
    verb = verb.ToLower();
    if (extFolderMap.TryGetValue(ext, out extInfo))
    {
        string wpath = path.Substring(1).Replace('/', '\\\\'); // Strip off leading '/' and reformat as with windows path separator.
        string fullPath = Path.Combine(WebsitePath, wpath);
        Route route = routes.SingleOrDefault(r => verb == r.Verb.ToLower() && path == r.Path);
        if (route != null)
        {
            // Application has a handler for this route.
            string redirect = route.Action(kvParams);
            if (String.IsNullOrEmpty(redirect))
            {
                // Respond with default content loader.
                ret = extInfo.Loader(fullPath, ext, extInfo);
            }
            else
            {
                // Respond with redirect.
                ret = new ResponsePacket() { Redirect = redirect };
            }
        }
        else
        {
            // Attempt default behavior
            ret = extInfo.Loader(fullPath, ext, extInfo);
        }
    }
    else
    {
        ret = new ResponsePacket() { Error = Server.ServerError.UnknownType };
    }
    return ret;
}
```

이제 우리는 HTML 페이지에서 버튼을 클릭할 때 서버에 POST 요청을 보내도록 HTML 페이지를 수정하고, 핸들러에서 다른 페이지로 리다이렉트하도록 하겠습니다. 물론 이 모든 것을 자바스크립트에서 처리할 수 있지만, 우리는 여기서 서버 사이드 핸들러를 보여주기 위해 이렇게 구현합니다.

또한 요청 본문의 입력 스트림을 키-값 쌍으로 처리하고 로그로 매개변수를 기록하도록 합니다(요청 URL의 매개변수와 함께):
```csharp
private static async void StartConnectionListener(HttpListener listener)
{
    ...
    Dictionary<string, string> kvParams = GetKeyValues(parms); // Extract into key-value entries.
    string data = new StreamReader(context.Request.InputStream, context.Request.ContentEncoding).ReadToEnd();
    GetKeyValues(data, kvParams);
    Log(kvParams);
    ...
}
private static Dictionary<string, string> GetKeyValues(string data, Dictionary<string, string> kv = null)
{
    kv.IfNull(() => kv = new Dictionary<string, string>());
    data.If(d => d.Length > 0, (d) => d.Split('&').ForEach(keyValue => kv[keyValue.LeftOf('=')] = keyValue.RightOf('=')));
    return kv;
}
private static void Log(Dictionary<string, string> kv)
{
    kv.ForEach(kvp=>Console.WriteLine(kvp.Key+" : "+kvp.Value));
}
```

URL 매개변수와 POST 매개변수를 단일 키-값 쌍 컬렉션에 결합하는 것이 좋은 습관은 아니지만, 우리는 지금은 간단한 구현을 유지하기로 합니다.

새로운 HTML 페이지 /demo/redirect를 생성합니다:
```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>Redirect Demo</title>
<link type="text/css" rel="Stylesheet" href="/CSS/demo.css"/>
</head>
<body>
<form name="myform" action="/demo/redirect" method="post">
<div class="center-inner top-margin-50">
<input type="submit" class="button" value="Redirect Me" id='redirect' name="redirectButton" />
</div>
</body>
</html>
```

우리는 추가적인 작업을 하지 않고도 로그 추적과 동작을 살펴볼 수 있습니다:
우선 페이지가 로드될 때 GET 동사가 나타나고, 버튼을 클릭하면 POST 매개변수가 포함된 POST 요청이 나타납니다. 자체 웹 서버를 작성하는 것은 실제로 서버가 뒤에서 무엇을 하고 있는지 더 깊이 이해할 수 있게 해줍니다. 다음은 HTML과 관련된 몇 가지 주의 사항입니다:
1. 메서드 동사가 소문자여야 합니다. "POST"를 사용하면 Visual Studio의 IDE에서 이는 인식되지 않는 HTML5 동사로 경고합니다.
2. 흥미롭게도 HttpListenerRequest.HttpMethod 속성의 동사가 대문자로 표시됩니다!
3. 주의 깊게 살펴보면, 액션 경로는 HttpListenerRequest.Url.AbsoluteUri입니다.
4. POST 데이터가 패키징되는 방식에도 주의하세요. "키"는 HTML 요소의 이름이고 "값"은 HTML 요소의 값입니다. 공백이 값에 포함되어 있을 경우 공백이 "+"로 교체된다는 점에 주의하세요.

이제 이 동사와 경로에 대한 핸들러를 등록해 보겠습니다:
```csharp
static void Main(string[] args)
{
    string websitePath = GetWebsitePath();
    Server.onError = ErrorHandler;
    // register a route handler:
    Server.AddRoute(new Route() { Verb = Router.POST, Path = "/demo/redirect", Action = RedirectMe });
    Server.Start(websitePath);
    Console.ReadLine();
}
public static string RedirectMe(Dictionary<string, string> parms)
{
    return "/demo/clicked";
}
```

이제 버튼을 클릭하면 리다이렉트됩니다:
이제 매우 간단한 리팩토링을 통해 세 가지 문제를 해결했습니다:
* 동사는 항상 "get"으로 가정됩니다.
* 응용 프로그램은 로드된 콘텐츠(특히 HTML)를 조작할 기회가 없습니다.
* 라우팅을 재정의할 수 없습니다.

## Step 6 - 인증 및 세션 만료
----------------------------------------------
Step 5에서 구현한 매우 기본적인 라우트 핸들러를 개선하여 사용자에게 권한이 있는지 확인하고 세션이 만료되었는지 확인하는 기능을 추가하겠습니다.
*   사용자가 페이지를 볼 권한이 있는지 확인
*   세션이 만료되었는지 확인
위와 같은 보다 정교한 핸들러를 만들어 사용자가 커스터마이징할 수 있도록 하여, 예를 들어 역할 기반 인증과 같은 추가적인 기능을 추가할 수 있습니다.
### 세션 관리
먼저 간단한 `Session`과 `SessionManager` 클래스를 추가하겠습니다:
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using Clifton.ExtensionMethods;

namespace Clifton.WebServer
{
    /// <summary>
    /// 세션은 클라이언트의 IP에 연결됩니다.
    /// </summary>
    public class Session
    {
        public DateTime LastConnection { get; set; }
        public bool Authorized { get; set; }

        /// <summary>
        /// 컨트롤러에서 필요한 추가 정보를 유지하기 위해 사용할 수 있습니다.
        /// </summary>
        public Dictionary<string, string> Objects { get; set; }

        public Session()
        {
            Objects = new Dictionary<string, string>();
            UpdateLastConnectionTime();
        }

        public void UpdateLastConnectionTime()
        {
            LastConnection = DateTime.Now;
        }

        /// <summary>
        /// 마지막 요청이 지정된 만료 시간 초과 여부를 반환합니다.
        /// </summary>
        public bool IsExpired(int expirationInSeconds)
        {
            return (DateTime.Now - LastConnection).TotalSeconds > expirationInSeconds;
        }
    }

    public class SessionManager
    {
        /// <summary>
        /// 모든 세션을 추적합니다.
        /// </summary>
        protected Dictionary<IPAddress, Session> sessionMap = new Dictionary<IPAddress, Session>();

        // TODO: 오래된 세션을 제거할 방법이 필요합니다. 그렇지 않으면 서버에 수천 개의 불필요한 엔드포인트가 쌓일 수 있습니다.
        public SessionManager()
        {
            sessionMap = new Dictionary<IPAddress, Session>();
        }

        /// <summary>
        /// 이 원격 엔드포인트에 대한 세션을 생성하거나 이미 존재하면 반환합니다.
        /// </summary>
        public Session GetSession(IPEndPoint remoteEndPoint)
        {
            // 포트는 항상 변동되므로 IP 부분만 사용할 수 있습니다.
            Session session = sessionMap.CreateOrGet(remoteEndPoint.Address);
            return session;
        }
    }
}
```
`SessionManager`는 클라이언트의 엔드포인트 IP와 관련된 `Session` 인스턴스를 관리합니다. 주석에 언급된 대로, 매우 오래된 세션을 제거하는 방법이 필요합니다. 그렇지 않으면 서버에 수많은 불필요한 엔드포인트가 쌓이게 됩니다. `Session` 클래스에는 마지막 연결 시간을 관리하고 사용자가 특정 페이지를 볼 권한이 있는지 여부를 나타내는 유용한 속성이 포함되어 있습니다. 또한, 웹 애플리케이션에서 유지해야 할 키-값 쌍 딕셔너리를 제공합니다. 기본적이지만 실용적인 구조입니다.
이제 리스너 연속성에서 해당 엔드포인트 IP에 대한 세션을 가져올 수 있습니다:
```csharp
private static async void StartConnectionListener(HttpListener listener)
{
    ResponsePacket resp = null;

    // 연결을 기다립니다. 호출자를 기다리며 돌아옵니다.
    HttpListenerContext context = await listener.GetContextAsync();
    Session session = sessionManager.GetSession(context.Request.RemoteEndPoint);
    ...
    resp = router.Route(verb, path, kvParams);

    // 라우터(및 핸들러)가 먼저 세션 상태를 검사하도록 하기 위해 응답 후 세션의 마지막 연결 시간을 업데이트합니다.
    session.UpdateLastConnectionTime();
```
그냥 그렇게 간단합니다! 라우터 및 핸들러가 세션의 마지막 상태를 먼저 검사하도록 설정했기 때문에, 응답을 받은 후 세션의 마지막 연결 시간을 업데이트합니다.
세션 만료는 인증과 밀접하게 연관되어 있으므로 세션이 만료되면 `Authorized` 플래그가 자동으로 해제될 것으로 기대됩니다.
### 익명 vs. 인증된 라우트
이제 인증 체크와 세션 만료 체크를 위한 내장 기능을 추가해보겠습니다. 애플리케이션에서 사용할 수 있는 세 가지 클래스를 추가할 것입니다:
*   익명 라우트 핸들러
*   인증된 라우트 핸들러
*   인증된 만료 가능한 라우트 핸들러
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clifton.WebServer
{
    /// <summary>
    /// 라우트 핸들러의 기본 클래스입니다.
    /// </summary>
    public abstract class RouteHandler
    {
        protected Func<Session, Dictionary<string, string>, string> handler;

        public RouteHandler(Func<Session, Dictionary<string, string>, string> handler)
        {
            this.handler = handler;
        }

        public abstract string Handle(Session session, Dictionary<string, string> parms);
    }

    /// <summary>
    /// 페이지는 항상 보입니다.
    /// </summary>
    public class AnonymousRouteHandler : RouteHandler
    {
        public AnonymousRouteHandler(Func<Session, Dictionary<string, string>, string> handler)
            : base(handler)
        {
        }

        public override string Handle(Session session, Dictionary<string, string> parms)
        {
            return handler(session, parms);
        }
    }

    /// <summary>
    /// 페이지는 인증된 사용자만 볼 수 있습니다.
    /// </summary>
    public class AuthenticatedRouteHandler : RouteHandler
    {
        public AuthenticatedRouteHandler(Func<Session, Dictionary<string, string>, string> handler)
            : base(handler)
        {
        }

        public override string Handle(Session session, Dictionary<string, string> parms)
        {
            string ret;
            if (session.Authorized)
            {
                ret = handler(session, parms);
            }
            else
            {
                ret = Server.onError(Server.ServerError.NotAuthorized);
            }
            return ret;
        }
    }

    /// <summary>
    /// 페이지는 인증된 사용자만 볼 수 있으며 세션이 만료되지 않았습니다.
    /// </summary>
    public class AuthenticatedExpirableRouteHandler : AuthenticatedRouteHandler
    {
        public AuthenticatedExpirableRouteHandler(Func<Session, Dictionary<string, string>, string> handler)
            : base(handler)
        {
        }

        public override string Handle(Session session, Dictionary<string, string> parms)
        {
            string ret;
            if (session.IsExpired(Server.expirationTimeSeconds))
            {
                session.Authorized = false;
                ret = Server.onError(Server.ServerError.ExpiredSession);
            }
            else
            {
                ret = base.Handle(session, parms);
            }
            return ret;
        }
    }
}
```
이제 우리는 세션 인스턴스를 핸들러에 전달할 수 있습니다. 편리하죠!
웹 애플리케이션 라우팅 테이블을 `RouteHandler` 파생 클래스로 갱신해 보겠습니다. `Route` 클래스도 갱신됩니다:
```csharp
public class Route
{
    public string Verb { get; set; }
    public string Path { get; set; }
    public RouteHandler Handler { get; set; }
}
```
세션은 라우터에 전달되어 라우트 핸들러에 전달됩니다:
```csharp
public ResponsePacket Route(Session session, string verb, string path, Dictionary<string, string> kvParams)
{
    ...
    string redirect = route.Handler.Handle(session, kvParams);
    ...
```
이제 웹 애플리케이션을 갱신하여 핸들러의 종류를 지정할 수 있습니다. 예를 들어:
```csharp
Server.AddRoute(new Route() { Verb = Router.POST, Path = "/demo/redirect", Handler=new AnonymousRouteHandler(RedirectMe) });
```
물론, 우리의 핸들러는 이제 세션 인스턴스를 받습니다:
```csharp
public static string RedirectMe(Session session, Dictionary<string, string> parms)
{
    return "/demo/clicked";
}
```
인증된 플래그가 세션에 설정되지 않은 상태로 인증된 라우트를 만들어보겠습니다:
```csharp
Server.AddRoute(new Route() 
{ 
    Verb = Router.POST, 
    Path = "/demo/redirect", 
    Handler=new AuthenticatedRouteHandler(RedirectMe) 
});
```
"Redirect Me" 버튼을 클릭하면 "인증되지 않았습니다" 페이지를 볼 수 있습니다:
세션 만료 로직을 테스트하기 위해 동일한 것을 해보겠습니다:
```csharp
Server.AddRoute(new Route() 
{ 
    Verb = Router.POST, 
    Path = "/demo/redirect", 
    Handler=new AuthenticatedExpirableRouteHandler(RedirectMe) 
});
```
60초(서버에서 설정 가능) 후 "Redirect Me" 페이지에서:
웹사이트를 만들면서 인증/만료 처리가 종종 방해가 되곤 합니다. 그래서 인증을 속이는 기능을 구현해볼 수 있습니다. `onRequest`를 구현하면 서버에서 이를 호출합니다:
```csharp
public static Action<Session, HttpListenerContext> onRequest;
...
// 연결을 기다립니다. 호출자를 기다리며 돌아옵니다.
HttpListenerContext context = await listener.GetContextAsync();
Session session = sessionManager.GetSession(context.Request.RemoteEndPoint);
onRequest.IfNotNull(r => r(session, context));
```
항상 인증되고 만료되지 않는 세션을 구현할 수 있습니다:
```csharp
static void Main(string[] args)
{
    string websitePath = GetWebsitePath();
    Server.onError = ErrorHandler;
    // 만료되지 않으며 항상 인증됨
    Server.onRequest = (session, context) =>
    {
        session.Authorized = true;
        session.UpdateLastConnectionTime();
    };
}
```
---
### Step 7 - AJAX 쿼리
---------------------
AJAX 콜백에 대해 살펴보겠습니다. 어떤 작업이 필요한지 확인해 보겠습니다. 간단한 AJAX jQuery 스크립트를 포함한 HTML 페이지를 준비해 보겠습니다:
```html
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>AJAX Demo</title>
<script type="text/javascript" src="/Scripts/jquery-1.11.2.min.js"></script>
<link type="text/css" rel="Stylesheet" href="/CSS/demo.css"/>
<script type="text/javascript">
$(document).ready(function () {
    $("#me").click(function () {
        $.ajax({
            url: this.href,
            datatype: "json",
            async: true,
            cache: false,
            type: "put",
            data: {
                number: 5
            },
            success: function(data, status)
            {
                alert(data);
            }
        });
    });
});
</script>
</head>
<body>
<div class="center-inner top-margin-50">
    <input class="button" type="button" value="AJAX!" id="me"/>
</div>
</body>
</html>
```
요청이 이루어지고 있음을 확인할 수 있지만, 특별한 핸들러가 없으므로 서버는 페이지의 내용을 응답합니다. 이는 예상되는 결과입니다.
이제 라우트 핸들러를 등록해 보겠습니다:
```csharp
Server.AddRoute(new Route() 
{ 
    Verb = Router.PUT, 
    Path = "/demo/ajax", 
    Handler = new AnonymousRouteHandler(AjaxResponder) 
});
```
하지만 문제가 생겼습니다. 우리의 일반 핸들러는 리다이렉트를 기대하지만 데이터 응답을 받습니다:
```csharp
public static string AjaxResponder(Session session, Dictionary<string, string> parms)
{
    return "what???";
}
```
예상대로, 더 많은 리팩토링이 필요합니다. 핸들러는 응답에 더 세밀한 제어가 필요하므로 `ResponsePacket`를 반환하도록 변경해야 합니다. 예를 들어:
```csharp
public static ResponsePacket RedirectMe(Session session, Dictionary<string, string> parms)
{
    return Server.Redirect("/demo/clicked");
}

public static ResponsePacket AjaxResponder(Session session, Dictionary<string, string> parms)
{
    string data = "You said " + parms["number"];
    ResponsePacket ret = new ResponsePacket() { Data = Encoding.UTF8.GetBytes(data), ContentType = "text" };
    return ret;
}
```
이 변경으로 인해 몇몇 곳에서 핸들러 응답이 문자열이었던 부분을 수정해야 했습니다. 가장 중요한 코드 변경은 라우터 자체였습니다:
```csharp
Route handler = routes.SingleOrDefault(r => verb == r.Verb.ToLower() && path == r.Path);
if (handler != null)
{
    // 애플리케이션에서 이 경로에 대한 핸들러가 있습니다.
    ResponsePacket handlerResponse = handler.Handler.Handle(session, kvParams);
    if (handlerResponse == null)
    {
        // 기본 콘텐츠 로더로 응답합니다.
        ret = extInfo.Loader(session, fullPath, ext, extInfo);
    }
    else
    {
        // 리다이렉트로 응답합니다.
        ret = handlerResponse;
    }
}
```
하지만 이 변경은 약 5분 정도 걸렸고, 결과는 다음과 같습니다:
데이터를 JSON 또는 XML로 반환할 수도 있습니다. 이는 웹 서버와 독립적이지만, 올바른 콘텐츠 유형을 설정하는 것이 권장됩니다:
*   ContentType = "application/json"
*   ContentType = "application/xml"
### AJAX GET 동사
또한, GET 동사를 사용했을 때 어떻게 되는지 살펴보겠습니다:
GET 동사를 사용하면 매개변수들이 URL에 포함됩니다! 이 경로에 대한 핸들러를 작성해 보겠습니다:
```csharp
Server.AddRoute(new Route() 
{ 
    Verb = Router.GET, 
    Path = "/demo/ajax", 
    Handler = new AnonymousRouteHandler(AjaxGetResponder) 
});
```
GET 동사는 매개변수가 없는 경우(브라우저 요청)와 매개변수가 있는 경우 모두 처리해야 합니다:
흥미롭게도, 이제 브라우저를 사용하여 GET 응답을 테스트할 수 있습니다. URL을 확인해 보세요:
### 저게 무엇이야?
저곳의 밑줄(_)은 jQuery가 Internet Explorer의 캐싱을 피하기 위해 추가한 것입니다. GET 동작이고 캐시가 false로 설정된 경우에만 존재합니다. 무시하세요.
---
### Step 8 - 인터넷 vs. 인트라넷
------------------------------
### 로컬 vs. 공용 IP 주소
192.168... IP 주소로 로컬에서 웹 서버를 테스트하는 것은 괜찮지만, 사이트를 배포할 때는 어떻게 될까요? 저는 Amazon EC2 서버를 사용해 배포했고, 내부 IP와 공용 IP가 방화벽 뒤에 있다는 것을 발견했습니다(분명히). 라우터에서도 같은 현상을 볼 수 있습니다. 다음 코드는 Stack Overflow에서 찾은 것으로, 공용 IP를 얻는 데 사용할 수 있습니다(링크를 제공해 주셔서 감사합니다):
```csharp
public static string GetExternalIP()
{
    string externalIP;
    externalIP = (new WebClient()).DownloadString("http://checkip.dyndns.org/");
    externalIP = (new Regex(@"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}")).Matches(externalIP)[0].ToString();
    return externalIP;
}
```
아주 최선의 접근 방식은 아니지만 작동은 합니다.
여기서 중요한 점은 리다이렉트 시 공용 IP를 사용해야 하고, `UserHostAddress`를 사용해서는 안 된다는 것입니다:
```csharp
if (String.IsNullOrEmpty(publicIP))
{
    response.Redirect("http://" + request.UserHostAddress + resp.Redirect);
}
else
{
    response.Redirect("http://" + publicIP + resp.Redirect); 
}
```
위의 공용 IP를 얻는 코드는 다소 느릴 수 있고, 명확히 서버 시작 시에만 실행되어야 합니다. 또한 도메인이 실제로 등록되어 있다면 이 과정은 필요 없습니다.
### 도메인 이름
위의 코드는 도메인이 등록되지 않은 상태에서 테스트할 때 좋습니다. 하지만 분명히 우리는 사용자가 언제든지 리다이렉트를 할 때 IP 주소를 보길 바라지 않습니다. 실제 도메인 이름을 사용하는 경우에 대해 테스트해 본 적은 없습니다. 다만, 단순히 `publicIP`를 실제 도메인 이름으로 설정하면 됩니다:
```csharp
Server.publicIP="www.yourdomain.com";
```
---
### Step 9 - 서버 측 HTML을 동적으로 수정하고 싶다면 (왜 그렇게 해야 하는지)
--------------------------------------------------------------------------
저는 서문에서 말했듯이, jQuery, AJAX, 자바스크립트 및 전문적인 서드파티 컴포넌트를 사용하면 대부분의 경우 복잡한 서버 측 HTML 생성은 필요 없다고 생각합니다. 하지만 HTML을 서버 측에서 동적으로 수정해야 하는 이유는 한 가지 있습니다. 바로 CSRF 공격을 처리하기 위해서입니다.
### 크로스 사이트 리퀘스트 위조 (CSRF)
CSRF에 대한 좋은 설명과 이를 왜 신경 써야 하는지에 대한 이유를 여기에 제시합니다. 그러나 런타임 동적 코드 컴파일을 사용하여 필요한 HTML을 생성할 필요는 없습니다. 따라서 CSRF를 처리하고 일반적으로 서버 측 HTML 조작을 위해 웹 애플리케이션에서 HTML을 반환하기 전에 서버에서 사후 처리할 수 있는 기능을 추가할 것입니다. 이는 라우터에서 HTML을 바이트 배열로 인코딩하기 직전에 수행할 수 있습니다:
```csharp
string text = File.ReadAllText(fullPath);
text = Server.postProcess(session, text); // 사후 처리 옵션, 예를 들어 유효성 검사 토큰 추가.
```
서버에서 제공하는 기본 구현은 다음과 같습니다:
```csharp
public static string validationTokenScript = "<%AntiForgeryToken%>";
public static string validationTokenName = "__CSRFToken__";
private static string DefaultPostProcess(Session session, string html)
{
    string ret = html.Replace(validationTokenScript, 
    "<input name='" + 
    validationTokenName + 
    "' type='hidden' value='" + 
    session.Objects[validationTokenName].ToString() + 
    "' id='#__csrf__'" +
    "/>");
    return ret;
}
```
리팩토링 시간! 새로운 세션이 생성될 때 토큰이 만들어집니다:
```csharp
public Session GetSession(IPEndPoint remoteEndPoint)
{
    Session session;
    if (!sessionMap.TryGetValue(remoteEndPoint.Address, out session))
    {
        session = new Session();
        session.Objects[Server.validationTokenName] = Guid.NewGuid().ToString();
        sessionMap[remoteEndPoint.Address] = session;
    }
    return session;
}
```
기본적으로 POST가 아닌 모든 동사에 대해 CSRF 검사를 구현할 수 있습니다. 현재는 모든 동사를 대상으로 하고 있지만, 차후에는 선택적으로 더 세밀하게 적용해야 합니다:
```csharp
public ResponsePacket Route(Session session, string verb, string path, Dictionary<string, string> kvParams)
{
    string ext = path.RightOfRightmostOf('.');
    ExtensionInfo extInfo;
    ResponsePacket ret = null;
    verb = verb.ToLower();
    if (verb != GET)
    {
        if (!VerifyCSRF(session, kvParams))
        {
            // 여러 리턴점이 싫지만, 여기서는 매우 편리합니다!
            return Server.Redirect(Server.onError(Server.ServerError.ValidationError));
        }
    }
    ...
}

/// <summary>
/// CSRF 검증 토큰이 존재한다면 세션 값과 일치하는지 확인합니다.
/// 토큰이 존재하지 않는다면 콘솔에 경고를 출력합니다.
/// </summary>
private bool VerifyCSRF(Session session, Dictionary<string,string> kvParams)
{
    bool ret = true;
    string token;
    if (kvParams.TryGetValue(Server.validationTokenName, out token))
    {
        ret = session.Objects[Server.validationTokenName].ToString() == token;
    }
    else
    {
        Console.WriteLine("Warning - CSRF token is missing. Consider adding it to the request.");
    }
    return ret;
}
```
따라서 이 HTML을 보면:
```html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>Login</title>
<link type="text/css" rel="Stylesheet" href="/CSS/demo.css"/>
</head>
<body>
<form name="myform" action="/demo/redirect" method="post">
<%AntiForgeryToken%>
<div class="center-inner top-margin-50">
Username:&nbsp;
<input name="username"/>
</div>
<div class="center-inner top-margin-10">
Password:&nbsp;
<input type="password" name="password"/>
</div>
<div class="center-inner top-margin-10">
<input type="submit" value="Login"/>
</div>
</form>
</body>
</html>
```
소스를 검사하면 토큰을 볼 수 있습니다:
```html
<form name="myform" action="/demo/redirect" method="post">
<input name='__CSRFToken__' type='hidden' value='a9161119-de6f-4bb2-8e21-8d089d556c37'/>
```
콘솔 창에서 POST 요청을 보내면 다음과 같이 보입니다:
토큰이 누락된 경우 콘솔 창에서 다음과 같은 경고를 볼 수 있습니다:
### 기타 HTML 교체
서버에 더 나은 제어권이 있다면, 템플릿 툴을 사용하여 HTML에 자신만의 토큰 교체 기능을 추가할 수 있습니다. 예를 들어, 저는 Ruby on Rails에서 지원하는 Slim 언어 템플릿을 정말 좋아합니다. Slim 문법으로 위의 로그인 HTML은 다음과 같이 보입니다:
```slim
doctype html
html lang="en" xmlns="http://www.w3.org/1999/xhtml"
  head
    meta charset="utf-8" /
    title Login
    link href="/CSS/demo.css" rel="Stylesheet" type="text/css" /
  body
    form action="/demo/redirect" method="post" name="myform" 
      | <%AntiForgeryToken%
      .center-inner.top-margin-50
      | Username:&nbsp;
      input name="username" /
      .center-inner.top-margin-10
      | Password:&nbsp;
      input name="password" type="password" /
      .center-inner.top-margin-10
      input type="submit" value="Login" /
```
ASP.NET이나 Razor과 같은 환경에서는 사용할 수 없으며, Razor 파서 엔진을 교체하는 것은 복잡합니다. 그러나 우리는 자체 Slim to HTML 사후 파서를 쉽게 추가할 수 있습니다.
### 해결해야 할 문제들
----------------------
### CSRF와 AJAX
현재 위치에서 이 검증을 수행하기 때문에 AJAX POST/PUT/Delete 요청에서도 경고를 받습니다. 아마도 이것은 좋은 아이디어입니다. AJAX 시연 페이지는 다음과 같이 CSRF 토큰을 전달합니다:
```javascript
$(document).ready(function () {
    $("#me").click(function () {
        $.ajax({
            url: this.href,
            async: true,
            cache: false,
            type: "put",
            data: {
                number: 5,
                __CSRFToken__: $("#__csrf__").val()
            },
            success: function(data, status)
            {
                alert(data);
            }
        });
    });
});
```
이것은 아마도 일반적인 구현 방식은 아니며, 검증 실패 시 브라우저에서 흥미로운 동작이 나타날 수 있습니다(리다이렉트를 AJAX 응답으로 보내는 것은 약간 이상합니다). 이는 더 깊은 탐구로 이어질 수 있는 함정이며, AJAX 요청에도 검증 토큰이 있어야 하는지에 대한 결정은 독자에게 맡기겠습니다. 만약 검증 토큰을 빠뜨리면 콘솔에서 경고 메시지만 표시됩니다.
### HTTPS
현재 웹사이트는 HTTPS를 사용해야 하지만, 이는 다른 날로 미루겠습니다. 혹은 이 글의 부록이나 별도의 기사로 다룰 예정입니다.
### 매개변수 값 디코딩
매개변수 값을 디코딩하는 것도 좋을 것 같습니다. 예를 들어, "+"를 공백으로 교체하고 "%xx"를 실제 문자로 변환합니다.
### 사후 처리 체인
HTML을 사후 처리하는 것은 체인 가능성을 가지고 있으며, 투두 리스트에 포함되어 있습니다.
### 그 외의 것
더 할 수 있는 일이 많습니다!
### 결론
---------
무엇이 더 큰 문제로 다뤄져야 하나요? 무슨 잔혹한 실수를 저질렀나요?
아이디어는 웹 서버를 매우 작게 유지하는 것입니다. 총 네 개의 클래스(확장 메서드 포함)를 포함하며 전체 코드는 650줄 미만입니다.
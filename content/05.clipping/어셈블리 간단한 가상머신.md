---
title: 어셈블리 간단한 가상머신
source: https://web.archive.org/web/20200121100942/https://blog.felixangell.com/virtual-machine-in-c/
author:
  - "[[Felix Angell on Svbtle]]"
published: 2015-11-15
created: 2025-06-09
description: "Hacker News Dicussion Article discussion on Hacker News Introduction # Here’s the GitHub to show what we’ll be making. You can also compare your code to this repository in case you have any errors: GitHub Repository I felt like writing an article... | Felix Angell | Svbtle"
tags:
  - clippings
  - build-your-own-x

---
---

## 소개

다음은 우리가 만들고자 하는 결과물의 GitHub 저장소입니다. 오류가 발생하면 이 저장소의 코드와 비교해볼 수 있습니다: [GitHub 저장소](https://web.archive.org/web/20200121100942/https://www.github.com/felixangell/mac)

C 프로그래밍 언어로 나만의 가상 머신을 만드는 것에 대한 글을 쓰고 싶었습니다. 저는 컴파일러, 인터프리터, 파서, 가상 머신 등 낮은 수준의 응용 프로그램을 다루는 것을 좋아합니다. 그래서 가상 머신이 어떻게 작동하는지 배우는 것이 낮은 수준의 프로그래밍 영역에 입문하는 좋은 방법이라고 생각하여 이 글을 쓰게 되었습니다!

---

## 전제 조건 및 참고 사항

진행하기 전에 몇 가지 필요한 것이 있습니다:

- **GCC/Clang/..** — 저는 Clang을 사용하고 있지만, 어떤 최신 컴파일러든 사용할 수 있습니다.
- **텍스트 편집기** — (C 언어 작성 시) IDE보다 텍스트 편집기를 추천하며, 저는 Emacs를 사용할 것입니다.
- **기본 프로그래밍 지식** — 변수, 흐름 제어, 함수, 구조체 등 기본적인 내용만 있으면 됩니다.
- **GNU Make** — 동일한 명령어를 터미널에 반복해서 입력하여 코드를 컴파일하지 않도록 도와주는 빌드 시스템입니다.

---

## 왜 가상 머신을 작성해야 할까요?

다음은 **당신**이 가상 머신을 작성해야 하는 몇 가지 이유입니다:

- 컴퓨터가 어떻게 작동하는지에 대한 더 깊은 이해를 원한다면 이 글은 컴퓨터가 더 낮은 수준에서 무엇을 하는지 이해하는 데 도움이 될 것입니다. 가상 머신은 더 간단한 추상화 계층을 제공하며, 직접 만들어보는 것보다 더 좋은 학습 방법은 없습니다.
- 단순히 가상 머신에 대해 배우고 싶다면 재미있을 것입니다.
- 일부 프로그래밍 언어가 어떻게 작동하는지 더 자세히 알고 싶다면 도움이 될 것입니다. 예를 들어, 요즘 다양한 언어는 특정 언어를 위해 특별히 작성된 가상 머신을 대상으로 합니다. JVM, Lua의 VM, Facebook의 Hip-Hop VM (PHP/Hack) 등이 그 예입니다. C++ 프로그램에서 기계어 어셈블리까지도 상당히 큰 추상화가 있습니다. 생각해보면, 우리는 멋진 OOP 패러다임 언어로 가비지 컬렉션 및 모든 좋은 기능을 사용하여 프로그램을 작성할 때 많은 것을 당연하게 여깁니다.

### 명령어 집합

우리는 우리만의 명령어 집합을 구현할 것입니다. 비교적 간단할 것입니다. 레지스터 간 값 이동 또는 다른 명령어로 점프하는 것과 같은 명령어를 간략하게 다룰 것이지만, 이 글을 읽고 나면 이해할 수 있을 것입니다.

우리의 가상 머신은 `A`, `B`, `C`, `D`, `E`, `F`와 같은 레지스터 집합을 가질 것입니다. 이들은 범용 레지스터로, 어떤 값이든 저장하는 데 사용될 수 있습니다. 이는 x86의 `ip`, `flag`, `ds`와 같은 특수 목적 레지스터와는 대조됩니다.

프로그램은 읽기 전용 명령어 시퀀스가 될 것입니다. 가상 머신은 스택 기반 가상 머신으로, 값을 푸시하고 팝할 수 있는 스택과 몇 가지 레지스터를 사용할 수 있습니다. 스택 기반 가상 머신은 레지스터 기반 가상 머신보다 구현하기 훨씬 간단합니다.

더 이상 기다리지 않고, 우리가 구현할 명령어 집합의 예시를 보여드리겠습니다. 세미콜론은 해당 줄이 수행할 작업에 대한 주석입니다.

```
PSH 5       ; 스택에 5를 푸시합니다
PSH 10      ; 스택에 10을 푸시합니다
ADD         ; 스택 맨 위에 있는 두 값을 팝하여 더하고 스택에 푸시합니다
POP         ; 스택에서 값을 팝하고 디버깅을 위해 출력합니다
SET A 0     ; 레지스터 A를 0으로 설정합니다
HLT         ; 프로그램을 중지합니다
```

이것이 우리의 명령어 집합입니다. POP 명령어는 팝된 명령어를 출력할 것인데, 이것은 디버깅 목적입니다(ADD는 결과를 스택에 푸시하므로, 스택에서 값을 POP하여 결과가 있는지 확인할 수 있습니다).

또한 SET 명령어를 포함하여 레지스터에 접근하고 값을 쓰는 방법을 이해할 수 있도록 했습니다. MOV A, B (A의 값을 B로 이동)와 같은 명령어를 구현해 볼 수도 있습니다. HLT는 프로그램 실행을 완료했음을 나타내는 명령어입니다.

---

## 가상 머신은 어떻게 작동할까요?

가상 머신은 생각보다 간단합니다. "명령어 주기"라고 하는 간단한 패턴, 즉 **페치(fetch)**, **디코드(decode)**, **실행(execute)**을 따릅니다. 먼저 명령어 목록 또는 코드에서 다음 명령어를 가져오고, 그 다음 명령어를 디코드한 후 디코드된 명령어를 실행합니다.

---

## 프로젝트 구조

프로그래밍을 시작하기 전에 프로젝트를 설정해야 합니다. 프로젝트가 위치할 폴더가 필요하며, 저는 프로젝트를 `~/dev` 아래에 두는 것을 좋아합니다. 터미널에서 프로젝트를 설정하는 방법은 다음과 같습니다. 이는 `~/dev/` 디렉토리가 이미 있다고 가정하지만, 원하는 위치로 `cd`할 수 있습니다.

Bash

```
$ cd ~/dev/
$ mkdir mac
$ cd mac
$ mkdir src
```

위에서 우리는 `~/dev` 디렉토리 또는 프로젝트를 두려는 위치로 `cd`하고, 디렉토리를 만듭니다(저는 이 VM을 "mac"이라고 부르고 있습니다). 그런 다음 해당 디렉토리로 `cd`하고 코드가 위치할 `src` 디렉토리를 만듭니다.

---

## Makefile

우리의 Makefile은 비교적 간단합니다. 여러 파일로 분리할 필요가 없으며, 아무것도 포함하지 않으므로 몇 가지 플래그를 사용하여 파일만 컴파일하면 됩니다:

Makefile

```
SRC_FILES = main.c
CC_FLAGS = -Wall -Wextra -g -std=c11
CC = clang

all:
    ${CC} ${SRC_FILES} ${CC_FLAGS} -o mac
```

이것으로 당분간 충분할 것입니다. 나중에 항상 개선할 수 있지만, 제 역할을 하는 한 괜찮을 것입니다.

---

## 프로그램 명령어

이제 가상 머신 코드입니다. 먼저 프로그램에 대한 명령어를 정의해야 합니다. 이를 위해 `enum`을 사용할 수 있습니다. 우리의 명령어는 기본적으로 0부터 X까지의 숫자이기 때문입니다. 사실, 어셈블러 프로그램은 어셈블리 파일을 가져와 모든 연산 코드를 해당 숫자 값으로 (일종의) 변환합니다. 예를 들어, mac용 어셈블러를 작성했다면, 모든 `MOV` 연산 코드를 숫자 `0` 등으로 변환할 것입니다.

C

```
typedef enum {
    PSH,
    ADD,
    POP,
    SET,
    HLT
} InstructionSet;
```

이제 테스트 프로그램을 배열로 저장할 수 있습니다. 그래서 테스트를 위해 5와 6을 더한 다음 출력하는 간단한 프로그램을 작성할 것입니다.

참고: "출력"이라고 할 때, 실제로 "pop"을 호출하면 가상 머신이 팝된 값을 `printf`하도록 만들 것입니다. 실제로는 디버깅 목적이 아니라면 이렇게 하지 않을 것입니다.

명령어는 배열로 저장해야 하며, 문서 상단 어딘가에 정의할 것입니다. 헤더 파일에 넣을 수도 있습니다. 다음은 우리의 테스트 프로그램입니다:

C

```
const int program[] = {
    PSH, 5,
    PSH, 6,
    ADD,
    POP,
    HLT
};
```

위 프로그램은 스택에 `5`와 `6`을 푸시하고, `ADD` 명령어를 실행하여 스택에 있는 두 값을 팝하고, 서로 더한 다음 결과를 스택에 다시 푸시합니다. 그런 다음 디버깅 목적으로 `POP` 명령어가 값을 출력하도록 했기 때문에 결과를 팝합니다.

마지막으로, `HLT` 명령어는 프로그램을 종료한다는 의미입니다. 이는 흐름 제어가 있는 경우 프로그램을 언제든지 종료할 수 있도록 사용됩니다. 가상 머신은 명령어가 남아 있지 않으면 자연스럽게 종료될 것입니다.

이제 명령어 주기(페치, 디코드, 실행)를 구현해야 합니다. 기술적으로 아무것도 디코드할 필요는 없습니다. 이는 나중에 더 명확해질 것입니다.

---

## 현재 명령어 페치

프로그램을 배열로 저장했기 때문에 현재 명령어를 페치하는 것은 간단합니다. 가상 머신에는 일반적으로 **프로그램 카운터(Program Counter)**, **명령어 포인터(Instruction Pointer)** 등이라고 불리는 카운터가 있습니다. 이 이름들은 동의어이며 선택은 개인적인 선호도입니다. 일반적으로 PC 또는 IP로 축약됩니다.

이전에 프로그램 카운터를 레지스터로 저장할 것이라고 말했습니다. 그것은 나중에 할 것입니다. 지금은 코드 상단에 `ip`라는 변수를 만들고 `0`으로 설정할 것입니다.

```c
int ip = 0;
```

이 `ip`는 명령어 포인터를 의미합니다. 프로그램 자체는 정수 배열로 저장됩니다. `ip` 변수는 배열에서 현재 실행 중인 명령어를 나타내는 인덱스 역할을 합니다.


```c
int ip = 0;

int main() {
    int instr = program[ip];
    return 0;
}
```

`instr` 변수를 `printf`하면 `PSH` (또는 `0`)가 나올 것입니다. 이를 다음과 같이 페치 함수로 작성할 수 있습니다:

C

```
int fetch() {
    return program[ip];
}
```

이 함수는 호출될 때 현재 명령어를 반환합니다. 그럼 다음 명령어는 어떻게 할까요? 명령어 포인터를 증가시키기만 하면 됩니다:

C

```
int main() {
    int x = fetch(); // PSH
    ip++; // 명령어 포인터 증가
    int y = fetch(); // 5
}
```

그럼 이것을 어떻게 자동화할까요? 프로그램은 `HLT` 명령어를 통해 중단될 때까지 실행된다는 것을 알고 있습니다. 따라서 현재 명령어가 `HLT`가 될 때까지 계속 반복되는 무한 루프를 가지면 됩니다.

C

```
#include <stdbool.h> 

bool running = true;

int main() {
    while (running) {
        int x = fetch();
        if (x == HLT) running = false;
        ip++;
    }
}
```

이것은 완벽하게 작동하겠지만, 약간 지저분합니다. 우리가 하는 일은 각 명령어를 반복하고, 해당 명령어의 값이 `HLT`인지 확인하고, `HLT`이면 루프를 중지하고, 그렇지 않으면 명령어를 처리하고 반복하는 것입니다.

---

## 명령어 평가

이것이 우리 가상 머신의 핵심이지만, 더 잘할 수 있습니다. 가상 머신은 매우 간단하여 큰 `switch` 문을 작성할 수 있습니다. 사실, 이것은 속도 면에서 일반적으로 가장 좋은 방법입니다. 모든 명령어를 위한 HashMap이나 `execute` 메서드가 있는 추상 클래스 또는 인터페이스를 사용하는 것과는 대조적입니다.

`switch` 문의 각 `case`는 우리가 `enum`에서 정의한 명령어가 될 것입니다. `eval` 함수는 평가할 명령어를 단일 매개변수로 받습니다. 피연산자를 소비하는 경우가 아니면 이 함수에서는 명령어 포인터 증가를 수행하지 않을 것입니다.

C

```
void eval(int instr) {
    switch (instr) {
    case HLT:
        running = false;
        break;
    }
}
```

이것을 가상 머신의 메인 루프에 다시 추가해 봅시다:

C

```
bool running = true;
int ip = 0;

// instruction enum
// eval function
// fetch function

int main() {
    while (running) {
        eval(fetch());
        ip++; // 매 반복마다 ip 증가
    }
}
```

---

## 스택!

좋습니다, 완벽하게 작동할 것입니다. 이제 다른 명령어를 추가하기 전에 스택이 필요합니다. 스택은 매우 간단한 자료구조입니다. 연결 리스트 대신 배열을 사용할 것입니다. 스택의 크기가 고정되어 있으므로 크기 조정/복사에 대해 걱정할 필요가 없습니다. 그리고 캐시 효율성 측면에서 연결 리스트보다 배열을 사용하는 것이 더 나을 것입니다!

`ip`가 프로그램 배열을 인덱싱하는 것과 마찬가지로, 스택 배열에서 우리가 어디에 있는지 보여주는 스택 포인터(`sp`)가 필요합니다.

다음은 스택 자료구조의 시각화입니다:

C

```
[] // 비어 있음

PSH 5 // 스택 **맨 위**에 5를 넣습니다
[5]

PSH 6 // 스택 맨 위에 6
[5, 6]

POP // 맨 위에서 6을 팝합니다
[5]

POP // 5를 팝합니다
[] // 비어 있음

PSH 6 // 6을 푸시합니다...
[6]

PSH 5 // 등..
[6, 5]
```

스택 관점에서 프로그램을 분석해 봅시다:

C

```
PSH, 5,
PSH, 6,
ADD,
POP,
HLT
```

먼저 스택에 5를 푸시합니다.

C

```
[5]
```

그런 다음 6을 푸시합니다:

C

```
[5, 6]
```

그 다음 `ADD` 명령어는 이 값들을 기본적으로 팝하고 서로 더한 다음 결과를 스택에 푸시합니다:

C

```
[5, 6]

// 스택의 맨 위 값을 팝하고 'a'라는 변수에 저장합니다
a = pop; // a는 6을 포함합니다
[5] // 스택 내용

// 스택의 맨 위 값을 팝하고 'b'라는 변수에 저장합니다
b = pop; // b는 5를 포함합니다
[] // 스택 내용

// 이제 b와 a를 더합니다. 참고로 순서를 뒤집는데, 덧셈에서는
// 중요하지 않지만, 다른 잠재적인 명령어에서는
// 예를 들어 5 / 6은 6 / 5와 같지 않습니다
result = b + a;
push result // 결과를 스택에 푸시합니다
[11] // 스택 내용
```

스택 포인터는 어디에 사용될까요? 스택 포인터 또는 `sp`는 `-1`로 설정되며, 이는 비어 있음을 의미합니다. C에서 배열은 0부터 시작하는 인덱스를 가지므로, `sp`가 `0`이었다면 C 컴파일러가 임의의 숫자를 던져 넣을 것입니다. 배열의 메모리가 0으로 초기화되지 않기 때문입니다.

이제 3개의 값을 푸시하면 `sp`는 2가 됩니다. 다음은 3개의 값을 가진 배열입니다:

```
-> sp -1
    psh -> sp 0
    psh -> sp 1
    psh -> sp 3

  sp가 여기를 가리킵니다 (sp = 2)
        |
        V
[1, 5, 9]
 0  1  2 <- 배열 인덱스 또는 "주소"
```

이제 스택에서 값을 **팝**하면 스택 포인터를 감소시킵니다. 즉, 9를 팝하고 스택의 맨 위는 5가 됩니다:

```
sp가 여기를 가리킵니다 (sp = 1)
         |
         V
    [1, 5]
     0  1 <- 배열 인덱스입니다
```

스택의 맨 위를 보려면 현재 `sp`의 값을 보면 됩니다. 좋습니다, 스택이 어떻게 작동하는지 이해하셨기를 바랍니다! 여전히 혼란스럽다면 [위키백과](https://www.google.com/search?q=https://web.archive.org/web/20200121100942/https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\))의 이 글을 확인해 보세요.

C에서 스택을 구현하는 것은 비교적 간단합니다. `ip` 변수와 함께 `sp` 변수와 스택이 될 배열을 정의해야 합니다:

C

```
int ip = 0;
int sp = -1;
int stack[256];

...
```

이제 스택에 값을 푸시하려면 스택 포인터를 증가시킨 **다음** 현재 `sp` (방금 증가시킨)에 값을 설정합니다.

**여기서 순서가 매우 중요합니다!** 값을 먼저 설정하고 `sp`를 증가시키면 인덱스 `-1`의 메모리에 쓰게 되어 좋지 않은 동작이 발생할 수 있습니다!

C

```
// sp = -1
sp++; // sp = 0
stack[sp] = 5; // stack[0]의 값을 5로 설정
// 스택의 맨 위는 이제 [5]입니다
```

`eval` 함수에서 스택 푸시를 다음과 같이 추가할 수 있습니다:

C

```
void eval(int instr) {
    switch (instr) {
        case HLT: {
            running = false;
            break;
        }
        case PSH: {
            sp++;
            stack[sp] = program[++ip];
            break;
        }
    }
}
```

이전 `eval` 함수와 몇 가지 차이점이 있습니다. 첫째, `case` 절 주위에 중괄호가 있습니다. 이 트릭에 익숙하지 않다면, `case`에 변수를 정의할 수 있는 범위를 제공합니다.

둘째, program[++ip] 표현식입니다. 여기서 왜 그렇게 할까요? PSH 명령어에는 인수가 있기 때문입니다. PSH, 5. PSH 연산 코드 바로 뒤에 스택에 푸시하려는 값이 있습니다.

여기서 ip를 증가시켜 5를 가리키도록 한 다음, 프로그램 배열에서 해당 값에 접근합니다.

```
program = [ PSH, 5, PSH, 6, ]
          0   1  2   3

푸시할 때:
ip는 0에서 시작 (PSH)
ip++로 ip는 이제 1 (5)
sp++로 스택에 공간 할당
stack[sp] = program[ip], 스택에 5를 넣습니다
```

`POP` 명령어는 스택 포인터를 감소시키는 것만큼 간단합니다. 그러나 팝 명령어가 방금 팝한 값을 출력하도록 만들고 싶었습니다. 이 때문에 약간 더 많은 작업을 해야 합니다:

C

```
case POP: {
    // 스택의 값을 val_popped에 저장한 다음 스택 포인터를 감소시킵니다
    int val_popped = stack[sp--];

    // 출력합니다!
    printf("popped %d\n", val_popped);
    break;
}
```

마지막으로 `ADD` 명령어입니다. 이것은 이해하기 조금 더 까다로울 수 있으며, 변수를 도입하기 때문에 `case` 절에 대한 스코프 트릭이 필요한 부분입니다.

C

```
case ADD: {
    // 먼저 스택을 팝하여 'a'로 저장합니다
    int a = stack[sp--];

    // 그런 다음 스택의 맨 위를 팝하여 'b'로 저장합니다
    int b = stack[sp--];

    // 그런 다음 결과를 더하고 스택에 푸시합니다
    int result = b + a;
    sp++; // 스택 포인터 **먼저** 증가
    stack[sp] = result; // 스택의 맨 위에 값을 설정

    // 모두 완료!
    break;
}
```

특정 연산의 경우 여기서 순서가 중요하다는 점에 유의하십시오! 나눗셈을 구현하는 경우 다음과 같은 문제에 부딪힐 수 있습니다:

```
5 / 4 != 4 / 5
```

스택은 LIFO (Last In, First Out)입니다. 즉, 5를 푸시한 다음 4를 푸시하면 4를 팝한 다음 5를 팝할 것입니다. `pop() / pop()`을 수행하면 잘못된 표현식이 되므로 순서를 정확하게 파악하는 것이 중요합니다.

레지스터는 구현하기 매우 쉽습니다. `A`, `B`, `C`, `D`, `E`, `F` 레지스터가 있다고 언급했습니다. 명령어 집합에서 그랬듯이 `enum`을 사용할 수 있습니다.

C

```
typedef enum {
   A, B, C, D, E, F,
   NUM_OF_REGISTERS
} Registers;
```

`enum`의 마지막 멤버인 `NUM_OF_REGISTERS`는 더 추가하더라도 레지스터의 크기를 얻을 수 있는 작은 트릭입니다.

레지스터를 배열에 저장할 것입니다. `enum`을 사용하므로 A = 0, B = 1, C = 2 등입니다. 따라서 레지스터 A를 설정하려면 단순히 `register[A] = some_value`라고 말하면 됩니다.

C

```
int registers[NUM_OF_REGISTERS];
```

레지스터 `A`의 값을 출력하는 방법:

C

```
printf("%d\n", registers[A]); // 레지스터 A의 값을 출력
```

### 명령어 포인터

**분기는 어떻게 할까요?** 그것은 당신에게 맡기겠습니다! 명령어 포인터는 현재 명령어를 가리킵니다. 이제 이것이 가상 머신 소스 코드에 있으므로, 가장 좋은 방법은 가상 머신 프로그램에서 읽고 조작할 수 있는 레지스터로 명령어 포인터를 갖는 것입니다.

C

```
typedef enum {
    A, B, C, D, E, F, PC, SP,
    NUM_OF_REGISTERS
} Registers;
```

이제 코드를 수정하여 이러한 명령어 및 스택 포인터를 실제로 사용하도록 해야 합니다. 기존 코드베이스로 이를 수행하는 빠르고 더러운 방법은 상단의 `sp` 및 `ip` 변수를 제거하고 `#define`으로 바꾸는 것입니다:

C

```
#define sp (registers[SP])
#define ip (registers[IP])
```

이것은 코드를 많이 다시 작성할 필요 없이 괜찮은 해결책이 될 것이고 완벽하게 작동할 것입니다. 그러나 이것은 확장성이 좋지 않을 수 있으며 일부 코드를 별칭으로 사용하므로 이 방법을 사용하지 않는 것이 좋지만, 간단한 장난감 가상 머신에는 충분합니다.

코드에서 분기에 관해서는 힌트를 드리겠습니다. 새로운 `IP` 레지스터를 사용하면 이 `IP`에 다른 값을 써서 분기할 수 있습니다. 아래 샘플을 시도해보고 어떤 일이 일어나는지 확인해 보세요:

```
PSH 10
SET IP 0
```

많은 사람들이 익숙한 BASIC 프로그램과 유사합니다:

```
10 PRINT "Hello, World"
20 GOTO 10
```

그러나 우리는 스택에 지속적으로 값을 푸시하고 있기 때문에, 정의된 공간보다 더 많은 값을 푸시하면 결국 스택 오버플로가 발생할 것입니다.

각 '워드'가 명령어라는 점에 유의하십시오. 다음 프로그램을 고려하십시오:

```
;  이것들은 명령어입니다
PSH 10      ;  0 1
PSH 20      ;  2 3
SET IP 0    ;  4 5 6
```

두 번째 `SET` 명령어로 점프하려면 `IP` 레지스터를 `0` 대신 `2`로 설정해야 합니다.

### 마무리

이제 끝입니다! 프로젝트의 루트 디렉토리에서 `make`를 실행하면 가상 머신을 `./mac`으로 실행할 수 있습니다.

GitHub에서 소스 코드를 여기에서 확인할 수 있습니다. MOV 및 SET 명령어가 추가된 더 발전된 버전의 VM을 보려면 mac-improved 디렉토리를 확인하십시오.

이 글에서 구현한 가상 머신의 소스 코드는 mac.c에 있습니다.

이 주제에 관심이 있고 더 확장하고 싶다면 인터넷에 많은 자료가 있습니다. Notch는 DCPU-16을 작성했는데, 이는 폐기된 게임 0x10c를 위한 16비트 가상 머신입니다.

GitHub에는 DCPU-16의 구현이 몇 가지 있으니 확인해 볼 수 있습니다. 또한 Zilog Z80과 같은 간단한 CPU 에뮬레이션을 살펴볼 수도 있습니다.

이런 종류의 에뮬레이터를 작성하고 싶다면, 설명서를 확인하고 명령어 집합과 레지스터를 구현할 수 있는지 확인하십시오. 도움이 필요하면 GitHub에 몇 가지 구현이 있습니다.

이 글이 마음에 드셨다면 @felix_angell로 트윗해 주세요!

읽어주셔서 감사합니다!

135

추천

135

추천#### [지금 읽어보세요](https://web.archive.org/web/20200121100942/https://blog.felixangell.com/compilers-brief-and-brisk)

컴파일러 아키텍처에 대한 간략하고 빠른 개요

대부분의 컴파일러는 특정 아키텍처를 따릅니다: 서문 # 이 글에서는 이 아키텍처를 하나하나 자세히 분석할 예정입니다. 이 글은 인터넷에 있는 수많은 자료의 보충 자료로 생각하십시오... 계속 읽기 →

[원본 보기](https://web.archive.org/web/20200121100942/https://blog.felixangell.com/compilers-brief-and-brisk)
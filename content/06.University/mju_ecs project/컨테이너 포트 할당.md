---
title: 컨테이너 포트 할당
resource-path: 06.University/mju_ecs project/컨테이너 포트 할당.md
---
현재 코드는 순차적으로 포트를 검사하는 방식을 사용하고 있기 때문에, 특히 `BASE_PORT`에서 시작하여 `MAX_PORT`까지의 범위가 넓을 경우 검색 시간이 오래 걸릴 수 있습니다. 이를 개선하기 위해 다음과 같은 방법들을 고려할 수 있습니다.

---

## **1. 랜덤 포트 할당**
순차적으로 검사하는 대신, 주어진 범위 내에서 랜덤하게 포트를 선택하여 검사하면 평균적으로 더 빠르게 사용 가능한 포트를 찾을 수 있습니다.

### 수정된 코드
```java
import java.util.Random;

/**
 * 주어진 범위에서 사용 가능한 포트를 랜덤하게 찾습니다.
 *
 * @param startPort 시작 포트
 * @param endPort   종료 포트
 * @return 사용 가능한 포트 번호, 없으면 -1 반환
 */
private int findAvailablePort(int startPort, int endPort) {
    Random random = new Random();
    int attempts = 0;
    int maxAttempts = (endPort - startPort + 1); // 최대 시도 횟수

    while (attempts < maxAttempts) {
        int port = startPort + random.nextInt(endPort - startPort + 1);
        if (isPortAvailable(port)) {
            return port;
        }
        attempts++;
    }
    return -1; // 사용 가능한 포트가 없는 경우
}
```

### 장점
- 순차 검색보다 평균적으로 더 빠르게 사용 가능한 포트를 찾을 가능성이 높습니다.
- 랜덤성을 통해 특정 포트에 대한 경쟁 상태를 줄일 수 있습니다.

### 단점
- 매우 드물지만, 모든 포트가 사용 중인 경우 최악의 경우에도 많은 시도가 필요할 수 있습니다.

---

## **2. 할당된 포트 캐싱**
이미 할당된 포트를 관리하는 데이터 구조(예: `Set<Integer>`)를 사용하여, 중복 검사를 피하고 빠르게 사용 가능한 포트를 찾을 수 있습니다.

### 수정된 코드
```java
import java.util.HashSet;
import java.util.Set;

private static final Set<Integer> allocatedPorts = new HashSet<>();

/**
 * 주어진 범위에서 사용 가능한 포트를 빠르게 찾습니다.
 *
 * @param startPort 시작 포트
 * @param endPort   종료 포트
 * @return 사용 가능한 포트 번호, 없으면 -1 반환
 */
private synchronized int findAvailablePort(int startPort, int endPort) {
    for (int port = startPort; port <= endPort; port++) {
        if (!allocatedPorts.contains(port) && isPortAvailable(port)) {
            allocatedPorts.add(port); // 할당된 포트를 캐싱
            return port;
        }
    }
    return -1; // 사용 가능한 포트가 없는 경우
}

/**
 * 컨테이너 종료 시 할당된 포트를 해제합니다.
 *
 * @param port 해제할 포트
 */
private synchronized void releasePort(int port) {
    allocatedPorts.remove(port);
}
```

### 사용 예시
컨테이너가 종료될 때 할당된 포트를 해제하는 로직을 추가합니다:
```java
// ttydLauncherService에서 컨테이너 종료 시 호출
releasePort(port);
```

### 장점
- 이미 할당된 포트를 관리하므로 불필요한 검사를 피할 수 있습니다.
- 동기화(`synchronized`)를 통해 멀티스레드 환경에서도 안전하게 포트를 관리할 수 있습니다.

### 단점
- 메모리에 할당된 포트 목록을 유지해야 하며, 프로그램이 종료되면 목록이 사라집니다.

---

## **3. 운영체제의 임시 포트 활용**
Java의 `ServerSocket(0)`은 운영체제가 자동으로 사용 가능한 포트를 할당하도록 요청합니다. 이 방식은 가장 빠르고 간단하지만, 할당된 포트가 범위(`9000 ~ 36000`) 내에 있는지 보장되지 않습니다.

### 수정된 코드
```java
private int findAvailablePortInRange(int startPort, int endPort) {
    try (ServerSocket serverSocket = new ServerSocket(0)) { // OS가 임시 포트 할당
        int port = serverSocket.getLocalPort();
        if (port >= startPort && port <= endPort) {
            return port;
        }
    } catch (IOException e) {
        // 무시
    }
    return -1; // 범위 내의 포트를 할당할 수 없는 경우
}
```

### 장점
- 운영체제가 가장 빠르게 사용 가능한 포트를 제공합니다.
- 별도의 포트 검사 로직이 필요 없습니다.

### 단점
- 할당된 포트가 지정된 범위(`9000 ~ 36000`)를 벗어날 가능성이 있습니다.
- 특정 범위 내에서만 포트를 사용해야 하는 경우 적합하지 않을 수 있습니다.

---

## **4. 병렬 처리**
포트 검사를 병렬로 수행하여 성능을 향상시킬 수 있습니다. 예를 들어, 여러 스레드가 동시에 다른 포트를 검사하도록 할 수 있습니다.

### 수정된 코드
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

private int findAvailablePortParallel(int startPort, int endPort) {
    AtomicInteger availablePort = new AtomicInteger(-1);
    ExecutorService executor = Executors.newFixedThreadPool(10); // 10개의 스레드 사용

    for (int port = startPort; port <= endPort; port++) {
        int currentPort = port;
        executor.submit(() -> {
            if (availablePort.get() == -1 && isPortAvailable(currentPort)) {
                availablePort.set(currentPort);
            }
        });
    }

    executor.shutdown();
    while (!executor.isTerminated()) {
        // 모든 작업이 완료될 때까지 대기
    }

    return availablePort.get();
}
```

### 장점
- 병렬 처리를 통해 포트 검색 속도를 크게 향상시킬 수 있습니다.

### 단점
- 복잡도가 증가하며, 과도한 스레드 사용으로 인해 리소스를 많이 소비할 수 있습니다.

---

## **결론**
가장 적합한 방법은 요구사항과 환경에 따라 다릅니다:
1. **빠른 해결**: 랜덤 포트 할당(`Random`)을 사용하세요.
2. **안정성과 효율성**: 할당된 포트를 캐싱(`Set`)하는 방법을 추천합니다.
3. **범위 제한이 필요 없는 경우**: 운영체제의 임시 포트(`ServerSocket(0)`)를 활용하세요.
4. **대규모 환경**: 병렬 처리를 사용하여 성능을 최적화하세요.

추가적인 질문이나 요구사항이 있다면 말씀해주세요! 😊
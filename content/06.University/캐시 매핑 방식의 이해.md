---
title: 캐시 매핑 방식의 이해
date: 2025-06-10T17:50:28+09:00
lastmod: 2025-06-11T15:04:42+09:00
resource-path: 06.University/캐시 매핑 방식의 이해.md
aliases: 
tags:
  - architecture
  - university
---
### **공통 시스템 환경 설정**

- **주기억장치 용량**: 4KB (4096 바이트). 따라서 주소는 **12비트**가 필요합니다 (212=4096).
- **워드(Word)의 크기**: **4 바이트**. (32비트 시스템에서 흔히 볼 수 있는 구조)
- **블록(Block) 및 캐시 라인(Line) 크기**: 4 워드. 즉, 4워드×4바이트/워드=16바이트 입니다.
- **캐시 메모리 크기**: 256 바이트.
- **캐시 라인의 수**: 256바이트/16바이트/라인=16개의 라인을 가집니다.

메모리 주소는 **12비트**이며, 이 주소를 어떻게 `Tag`, `Line(or Set)`, `Word(or Offset)` 필드로 나누는지가 각 사상 방식의 핵심입니다.

- **Word(Offset) 필드**: 블록 크기가 16바이트이므로, 블록 내 특정 바이트를 가리키기 위해 log2​(16)=4비트가 필요합니다.

---

### ## 1. 직접 사상 방식 (Direct Mapping)

직접 사상 방식에서는 주기억장치의 각 블록이 캐시의 정해진 **단 하나의 라인**에만 저장될 수 있습니다.

- **주소 구조**
    
    - 캐시 라인이 16개이므로, 라인 번호를 지정하기 위해 log2​(16)=4비트가 필요합니다 (`Line` 필드).
    - 나머지 비트는 `Tag`가 됩니다: 12−4(Line)−4(Word)=4비트.
    
    | Tag (4비트) | Line (4비트) | Word (4비트) |
    
    | :---------: | :----------: | :----------: |
    
- **동작 예시**
    
    1. CPU가 메모리 주소 **150번지**(`0000 1001 0110`₂)의 데이터를 요청합니다.
    2. 주소를 분해합니다:
        - **Tag**: `0000`
        - **Line**: `1001` (9번 라인)
        - **Word**: `0110`
    3. 캐시는 **9번 라인**으로 가서 Tag를 확인합니다.
    4. 만약 9번 라인의 Tag가 `0000`과 일치하면 **캐시 히트(Hit)**가 발생하고, 해당 블록의 6번째(`0110`₂) 바이트를 CPU에 전달합니다.
    5. Tag가 다르거나 라인이 비어있으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치의 150번지가 포함된 블록(9번 블록, 144~159번지)을 통째로 가져와 캐시의 9번 라인에 저장하고, Tag 필드를 `0000`으로 갱신합니다.

---

### ## 2. 완전 연관 사상 방식 (Fully Associative Mapping)

완전 연관 사상 방식에서는 주기억장치의 블록이 캐시의 **어떤 라인으로든** 저장될 수 있습니다.

- **주소 구조**
    
    - 정해진 라인이 없으므로 `Line` 필드가 없습니다.
    - Tag가 주소의 대부분을 차지합니다: 12−4(Word)=8비트.
    
    | Tag (8비트) | Word (4비트) |
    | :---------: | :----------: |
    
- **동작 예시**
    
    1. CPU가 메모리 주소 **150번지**(`0000 1001 0110`₂)의 데이터를 요청합니다.
    2. 주소를 분해합니다:
        - **Tag**: `0000 1001`
        - **Word**: `0110`
    3. 캐시는 **모든 16개 라인의 Tag를 동시에 비교**하여 `0000 1001`과 일치하는 Tag가 있는지 찾습니다.
    4. 일치하는 Tag를 찾으면 **캐시 히트(Hit)**가 발생하고, 해당 블록의 6번째(`0110`₂) 바이트를 CPU에 전달합니다.
    5. 일치하는 Tag가 없으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치에서 해당 블록(144~159번지)을 가져와 캐시의 **비어있는 아무 라인**에 저장합니다. 만약 빈 라인이 없다면, 특정 교체 정책(예: LRU)에 따라 기존 라인 중 하나를 교체합니다.

---

### ## 3. 세트 연관 사상 방식 (Set-Associative Mapping)

세트 연관 사상은 직접 사상과 완전 연관 사상을 절충한 방식입니다. 캐시 라인들을 여러 개의 **세트(Set)**로 묶고, 블록은 정해진 세트 안의 어떤 라인으로든 저장될 수 있습니다.

여기서는 **2-Way 세트 연관 사상**을 예시로 들겠습니다. (하나의 세트가 2개의 라인을 가짐)

- **세트 계산**
    
    - 세트의 수 = 라인 수 / Way 수 = 16/2=8개의 세트.
- **주소 구조**
    
    - 세트 번호를 지정하기 위해 log2​(8)=3비트가 필요합니다 (`Set` 필드).
    - 나머지 비트는 `Tag`가 됩니다: 12−3(Set)−4(Word)=5비트.
    
    | Tag (5비트) | Set (3비트) | Word (4비트) |
    
    | :---------: | :---------: | :----------: |
    
- **동작 예시**
    
    1. CPU가 메모리 주소 **150번지**(`0000 1001 0110`₂)의 데이터를 요청합니다.
    2. 주소를 분해합니다:
        - **Tag**: `0000 1`
        - **Set**: `001` (1번 세트)
        - **Word**: `0110`
    3. 캐시는 **1번 세트**로 갑니다. 1번 세트에는 2개의 라인이 있습니다.
    4. 이 **두 라인의 Tag만**을 비교하여 `0000 1`과 일치하는지 확인합니다.
    5. 일치하는 Tag를 찾으면 **캐시 히트(Hit)**가 발생합니다.
    6. 일치하는 Tag가 없으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치에서 해당 블록을 가져와 **1번 세트 내의 비어있는 라인**에 저장합니다. 만약 1번 세트의 두 라인이 모두 사용 중이라면, 교체 정책에 따라 둘 중 하나를 교체합니다.

---

### ## 요약 비교

|   |   |   |   |   |
|---|---|---|---|---|
|**구분**|**주소 구조 (Tag-Index-Offset)**|**특징**|**장점**|**단점**|
|**직접 사상**|4 - 4 - 4|블록 → 특정 라인 (1:1)|구현이 간단하고 빠름|특정 라인에 충돌이 잦음 (Conflict Miss)|
|**완전 연관**|8 - 없음 - 4|블록 → 모든 라인 (1:N)|매우 유연하여 히트율이 높음|모든 태그를 비교해야 하므로 회로가 복잡하고 비쌈|
|**세트 연관**|5 - 3 - 4|블록 → 특정 세트 (1:K)|직접 사상과 완전 연관의 장점을 절충함|직접 사상보다 복잡하고 완전 연관보다 히트율이 낮을 수 있음|
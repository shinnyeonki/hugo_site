<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>android studio build sequence | My Test Site</title>
    

    
    
    <meta name="description" content="네, 제공해주신 Android Gradle 빌드 로그의 각 단계를 매우 자세하게 설명해 드리겠습니다. 이 로그는 Android Studio에서 &lsquo;Run&rsquo; 버튼을 누르거나 터미널에서 ./gradlew assembleDebug 명령을 실행했을 때 나타 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/android-studio-build-sequence/">

    
    
    
    <meta property="og:title" content="android studio build sequence">
    <meta property="og:description" content="네, 제공해주신 Android Gradle 빌드 로그의 각 단계를 매우 자세하게 설명해 드리겠습니다. 이 로그는 Android Studio에서 &lsquo;Run&rsquo; 버튼을 누르거나 터미널에서 ./gradlew assembleDebug 명령을 실행했을 때 나타 …">
    <meta property="og:url" content="http://localhost:1313/android-studio-build-sequence/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="android studio build sequence">
    <meta name="twitter:description" content="네, 제공해주신 Android Gradle 빌드 로그의 각 단계를 매우 자세하게 설명해 드리겠습니다. 이 로그는 Android Studio에서 &lsquo;Run&rsquo; 버튼을 누르거나 터미널에서 ./gradlew assembleDebug 명령을 실행했을 때 나타 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>android studio build sequence **page.html**</h1>
    <p>네, 제공해주신 Android Gradle 빌드 로그의 각 단계를 매우 자세하게 설명해 드리겠습니다. 이 로그는 Android Studio에서 &lsquo;Run&rsquo; 버튼을 누르거나 터미널에서 <code>./gradlew assembleDebug</code> 명령을 실행했을 때 나타나는 과정입니다.</p>
<h3 id="핵심-개념-증분-빌드-incremental-build-와"><strong>핵심 개념: 증분 빌드 (Incremental Build) 와 <code>UP-TO-DATE</code></strong></h3>
<p>로그를 이해하기 전에 가장 중요한 개념은 Gradle의 <strong>증분 빌드</strong> 기능입니다.</p>
<ul>
<li><strong>정의</strong>: Gradle은 각 작업(Task)의 입력(input)과 출력(output)을 기억합니다. 다음 빌드를 실행할 때, Gradle은 각 작업의 입력 파일(예: 소스 코드, 리소스 파일)이 마지막 빌드 이후 변경되었는지 확인합니다.</li>
<li><strong><code>UP-TO-DATE</code>의 의미</strong>: 만약 입력 파일에 아무런 변경이 없다면, Gradle은 해당 작업을 다시 실행하는 대신 이전에 생성했던 출력물을 그대로 재사용합니다. 이때 로그에 <code>UP-TO-DATE</code>라고 표시됩니다.</li>
<li><strong>결과</strong>: 이 기능 덕분에 코드를 전혀 수정하지 않고 다시 빌드하면, 모든 작업이 <code>UP-TO-DATE</code>가 되어 빌드가 매우 빠르게(로그에서는 1초) 완료됩니다.</li>
</ul>
<hr>
<h3 id="빌드-단계별-상세-설명"><strong>빌드 단계별 상세 설명</strong></h3>
<p>빌드 과정은 크게 <strong>리소스 처리 → 매니페스트 처리 → 코드 컴파일 → DEX 변환 → APK 패키징</strong>의 순서로 진행됩니다.</p>
<h4 id="1단계-준비-및-설정-preparation--setup"><strong>1단계: 준비 및 설정 (Preparation &amp; Setup)</strong></h4>
<ul>
<li>
<p><code>&gt; Task :app:preBuild</code> &amp; <code>&gt; Task :app:preDebugBuild</code></p>
<ul>
<li><strong>역할</strong>: 본격적인 빌드 전에 필요한 준비 작업을 수행합니다. 예를 들어, 빌드 과정에서 생성될 파일들을 저장할 폴더(<code>build/</code> 디렉토리)를 만들거나 초기 환경 설정을 합니다. <code>preDebugBuild</code>는 &lsquo;debug&rsquo; 빌드 유형에 특화된 준비 작업입니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:checkKotlinGradlePluginConfigurationErrors</code></p>
<ul>
<li><strong>역할</strong>: Kotlin Gradle 플러그인 설정에 오류가 없는지 확인합니다.</li>
<li><strong><code>SKIPPED</code></strong>: 이 작업은 특정 조건에서만 실행되거나, 필요 없다고 판단되면 건너뜁니다. 문제가 있는 상태가 아닙니다.</li>
</ul>
</li>
</ul>
<h4 id="2단계-리소스-처리-resource-processing"><strong>2단계: 리소스 처리 (Resource Processing)</strong></h4>
<p>이 단계에서는 앱의 모든 리소스(레이아웃 XML, 이미지, 문자열 등)를 처리합니다. 주로 <code>aapt2</code> 도구가 사용됩니다.</p>
<ul>
<li>
<p><code>&gt; Task :app:checkDebugAarMetadata</code></p>
<ul>
<li><strong>역할</strong>: 프로젝트가 의존하는 라이브러리(<code>.aar</code> 파일)들의 메타데이터가 올바른지 확인합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:processDebugNavigationResources</code> &amp; <code>&gt; Task :app:compileDebugNavigationResources</code></p>
<ul>
<li><strong>역할</strong>: Android Jetpack의 Navigation Component를 사용하는 경우, <code>res/navigation</code> 폴더 안의 XML 파일들을 처리하고 컴파일합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:generateDebugResValues</code> &amp; <code>&gt; Task :app:generateDebugResources</code></p>
<ul>
<li><strong>역할</strong>: <code>build.gradle</code> 파일에 정의된 <code>resValue</code> 같은 동적으로 생성되는 리소스 값들을 실제 리소스 파일로 만듭니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:mergeDebugResources</code></p>
<ul>
<li><strong>역할</strong>: 매우 중요한 단계입니다. 프로젝트의 기본 리소스(<code>src/main/res</code>), 디버그용 리소스(<code>src/debug/res</code>), 그리고 모든 라이브러리(AAR)에 포함된 리소스들을 하나로 합쳐서 단일 폴더에 모읍니다. 만약 같은 이름의 리소스가 여러 곳에 있다면, 정해진 우선순위에 따라 하나를 선택합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:packageDebugResources</code></p>
<ul>
<li><strong>역할</strong>: <code>aapt2</code>가 본격적으로 동작하는 핵심 단계입니다. <code>mergeDebugResources</code>에서 합쳐진 모든 리소스를 컴파일하고 연결(link)합니다. 이 과정에서 <code>R.java</code> 파일이 생성되고, 모든 리소스가 바이너리 형식으로 포함된 <code>resources.ap_</code>라는 중간 결과물이 만들어집니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:parseDebugLocalResources</code></p>
<ul>
<li><strong>역할</strong>: <code>packageDebugResources</code> 이후 생성된 리소스들을 파싱하여 다음 단계를 준비합니다.</li>
</ul>
</li>
</ul>
<h4 id="3단계-매니페스트-처리-manifest-processing"><strong>3단계: 매니페스트 처리 (Manifest Processing)</strong></h4>
<ul>
<li>
<p><code>&gt; Task :app:createDebugCompatibleScreenManifests</code></p>
<ul>
<li><strong>역할</strong>: 앱의 화면 호환성(screen compatibility)과 관련된 매니페스트 조각을 생성합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:extractDeepLinksDebug</code></p>
<ul>
<li><strong>역할</strong>: 매니페스트와 코드 내 어노테이션에서 딥링크(Deep Link) 정보를 추출합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:processDebugMainManifest</code>, <code>&gt; Task :app:processDebugManifest</code>, <code>&gt; Task :app:processDebugManifestForPackage</code></p>
<ul>
<li><strong>역할</strong>: 리소스 병합과 유사하게 <code>AndroidManifest.xml</code> 파일을 병합합니다. <code>src/main/AndroidManifest.xml</code>을 기본으로, 라이브러리의 매니페스트와 <code>src/debug/</code> 폴더의 매니페스트 조각들을 합칩니다. 이 과정에서 <code>build.gradle</code>에 정의된 <code>applicationId</code>, <code>versionCode</code> 같은 플레이스홀더 값들을 실제 값으로 교체하여 최종 매니페스트를 완성합니다.</li>
</ul>
</li>
</ul>
<h4 id="4단계-코드-컴파일-및-dex-변환-code-compilation--dexing"><strong>4단계: 코드 컴파일 및 DEX 변환 (Code Compilation &amp; Dexing)</strong></h4>
<p>이 단계에서는 Kotlin/Java 소스 코드를 컴파일하고, Android 런타임이 이해할 수 있는 DEX 파일로 변환합니다.</p>
<ul>
<li>
<p><code>&gt; Task :app:compileDebugKotlin</code></p>
<ul>
<li><strong>역할</strong>: Kotlin 컴파일러(<code>kotlinc</code>)를 사용하여 프로젝트의 모든 <code>.kt</code> 파일을 <code>.class</code> 파일(자바 바이트코드)로 컴파일합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:compileDebugJavaWithJavac</code></p>
<ul>
<li><strong>역할</strong>: Java 컴파일러(<code>javac</code>)를 사용하여 <code>.java</code> 파일을 <code>.class</code> 파일로 컴파일합니다.</li>
<li><strong><code>NO-SOURCE</code></strong>: 이 작업은 실행되었지만, 컴파일할 <code>.java</code> 소스 파일이 하나도 없었다는 의미입니다. 프로젝트가 100% Kotlin으로 작성되었을 가능성이 높습니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:mergeDebugShaders</code>, <code>&gt; Task :app:compileDebugShaders</code></p>
<ul>
<li><strong>역hal</strong>: OpenGL 셰이더(<code>.glsl</code> 파일)가 있다면 컴파일하고 병합합니다. (여기서는 <code>NO-SOURCE</code>이므로 셰이더 파일이 없습니다.)</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:mergeDebugAssets</code></p>
<ul>
<li><strong>역할</strong>: <code>assets</code> 폴더의 내용물을 병합합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:checkDebugDuplicateClasses</code></p>
<ul>
<li><strong>역할</strong>: 컴파일된 클래스 파일과 라이브러리들 사이에 중복된 클래스가 있는지 검사합니다. 중복 클래스는 앱 실행 시 충돌을 일으킬 수 있으므로 중요한 검증 과정입니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:desugarDebugFileDependencies</code></p>
<ul>
<li><strong>역할</strong>: Java 8 이상의 최신 언어 기능(람다, 스트림 API 등)을 이전 버전의 Android에서도 동작하도록 변환(Desugaring)하는 준비 작업을 합니다. <code>d8</code> 도구가 이 역할을 수행합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:dexBuilderDebug</code>, <code>&gt; Task :app:mergeProjectDexDebug</code>, <code>&gt; Task :app:mergeExtDexDebug</code>, <code>&gt; Task :app:mergeLibDexDebug</code></p>
<ul>
<li><strong>역할</strong>: <strong>DEXing</strong> 단계입니다. <code>d8</code> 도구를 사용하여 프로젝트의 모든 <code>.class</code> 파일(내 코드 + 라이브러리 코드)을 Dalvik Executable(<code>.dex</code>) 파일로 변환합니다. <code>.dex</code> 파일은 Android 런타임(ART)이 실행하는 파일 형식입니다. 클래스 파일이 매우 많으면 여러 개의 <code>.dex</code> 파일로 나뉠 수 있으며, 이 작업들은 그것들을 병합하는 역할도 합니다.</li>
</ul>
</li>
</ul>
<h4 id="5단계-네이티브-코드-및-최종-패키징-native-code--final-packaging"><strong>5단계: 네이티브 코드 및 최종 패키징 (Native Code &amp; Final Packaging)</strong></h4>
<p>이제 모든 재료(컴파일된 리소스, DEX 파일, 매니페스트 등)를 모아 최종 APK 파일을 만듭니다.</p>
<ul>
<li>
<p><code>&gt; Task :app:mergeDebugJniLibFolders</code> &amp; <code>&gt; Task :app:mergeDebugNativeLibs</code></p>
<ul>
<li><strong>역할</strong>: C/C++로 작성된 네이티브 라이브러리(<code>.so</code> 파일)가 있다면, 모든 소스(내 프로젝트, 라이브러리)에서 가져와 아키텍처별(arm64-v8a, x86_64 등)로 정리하여 병합합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:stripDebugDebugSymbols</code></p>
<ul>
<li><strong>역할</strong>: 네이티브 라이브러리에서 디버깅 심볼을 제거하여 파일 크기를 줄입니다. (디버그 빌드에서는 보통 이 작업이 최소한으로 수행되거나 건너뜁니다.)</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:validateSigningDebug</code></p>
<ul>
<li><strong>역할</strong>: APK에 서명할 준비가 되었는지 확인합니다. 디버그 빌드의 경우, 보통 SDK에 포함된 기본 디버그 키스토어로 자동 서명됩니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:packageDebug</code></p>
<ul>
<li><strong>역할</strong>: <strong>최종 APK 생성 단계입니다.</strong> 지금까지 만들어진 모든 결과물—컴파일된 리소스(<code>resources.ap_</code>), DEX 파일, 최종 매니페스트, 네이티브 라이브러리(<code>.so</code>), <code>assets</code>—을 하나의 압축 파일(<code>.apk</code>)로 묶습니다. 이 단계에서 <code>apksigner</code>를 사용하여 디버그 키로 APK에 서명하고, <code>zipalign</code>으로 최적화하는 과정도 포함됩니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:createDebugApkListingFileRedirect</code></p>
<ul>
<li><strong>역할</strong>: 생성된 APK 파일의 내용물 목록을 담은 메타데이터 파일을 생성합니다.</li>
</ul>
</li>
<li>
<p><code>&gt; Task :app:assembleDebug</code></p>
<ul>
<li><strong>역할</strong>: 최종 집계(aggregator) 작업입니다. 이 작업 자체는 아무 일도 하지 않지만, 디버그 APK를 만드는 데 필요한 위의 모든 작업들에 대한 의존성을 가지고 있습니다. 따라서 <code>assembleDebug</code> 작업이 성공적으로 완료되었다는 것은 디버그 APK가 성공적으로 생성되었음을 의미합니다.</li>
</ul>
</li>
</ul>
<h3 id="최종-결과"><strong>최종 결과</strong></h3>
<ul>
<li><strong><code>BUILD SUCCESSFUL in 1s</code></strong>: 빌드가 1초 만에 성공적으로 완료되었습니다.</li>
<li><strong><code>36 actionable tasks: 36 up-to-date</code></strong>: Gradle이 실행해야 할 작업은 총 36개였지만, 입력 파일이 변경되지 않았기 때문에 36개 모두 이전 결과물을 재사용하여 작업을 완료했다는 의미입니다.</li>
<li><strong><code>Build Analyzer results available</code></strong>: Android Studio는 이 빌드 과정의 성능을 분석한 결과를 제공합니다. 빌드가 느릴 때 원인을 파악하는 데 유용한 도구입니다.</li>
</ul>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
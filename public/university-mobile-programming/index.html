<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>university mobile programming | My Test Site</title>
    

    
    
    <meta name="description" content="kotlin 기본 문법 ​kotlin keyword 1. Hard Keywords (문법 구조에 필수적이며, 식별자로 절대 사용할 수 없음)
키워드 설명 as (cast) 타입 캐스팅 (val x = obj as String) as (import) 임포트 시 별칭 지정 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/university-mobile-programming/">

    
    
    
    <meta property="og:title" content="university mobile programming">
    <meta property="og:description" content="kotlin 기본 문법 ​kotlin keyword 1. Hard Keywords (문법 구조에 필수적이며, 식별자로 절대 사용할 수 없음)
키워드 설명 as (cast) 타입 캐스팅 (val x = obj as String) as (import) 임포트 시 별칭 지정 …">
    <meta property="og:url" content="http://localhost:1313/university-mobile-programming/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="university mobile programming">
    <meta name="twitter:description" content="kotlin 기본 문법 ​kotlin keyword 1. Hard Keywords (문법 구조에 필수적이며, 식별자로 절대 사용할 수 없음)
키워드 설명 as (cast) 타입 캐스팅 (val x = obj as String) as (import) 임포트 시 별칭 지정 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>university mobile programming **page.html**</h1>
    <h2 id="kotlin-기본-문법">kotlin 기본 문법</h2>
<h3 id="kotlin-keyword">​kotlin keyword</h3>
<h4 id="1-hard-keywords">1. Hard Keywords</h4>
<p><em>(문법 구조에 필수적이며, 식별자로 절대 사용할 수 없음)</em></p>
<table>
  <thead>
      <tr>
          <th>키워드</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>as</code> (cast)</td>
          <td>타입 캐스팅 (<code>val x = obj as String</code>)</td>
      </tr>
      <tr>
          <td><code>as</code> (import)</td>
          <td>임포트 시 별칭 지정 (<code>import foo.Bar as Baz</code>)</td>
      </tr>
      <tr>
          <td><code>as?</code></td>
          <td>안전한 타입 캐스팅 (실패 시 <code>null</code> 반환)</td>
      </tr>
      <tr>
          <td><code>break</code></td>
          <td>루프 또는 라벨 블록 탈출</td>
      </tr>
      <tr>
          <td><code>class</code></td>
          <td>클래스 정의</td>
      </tr>
      <tr>
          <td><code>continue</code></td>
          <td>현재 루프 반복 건너뛰기</td>
      </tr>
      <tr>
          <td><code>do</code></td>
          <td><code>do-while</code> 루프 시작</td>
      </tr>
      <tr>
          <td><code>else</code></td>
          <td><code>if</code> 조건의 대안 블록</td>
      </tr>
      <tr>
          <td><code>false</code></td>
          <td>불리언 상수: 거짓</td>
      </tr>
      <tr>
          <td><code>for</code></td>
          <td>컬렉션/범위 반복 (<code>for (i in list)</code>)</td>
      </tr>
      <tr>
          <td><code>fun</code></td>
          <td>함수 정의</td>
      </tr>
      <tr>
          <td><code>if</code></td>
          <td>조건 분기</td>
      </tr>
      <tr>
          <td><code>in</code></td>
          <td>범위/컬렉션 멤버 확인 또는 <code>for</code> 루프에서 사용</td>
      </tr>
      <tr>
          <td><code>!in</code></td>
          <td><code>in</code>의 부정</td>
      </tr>
      <tr>
          <td><code>interface</code></td>
          <td>인터페이스 정의</td>
      </tr>
      <tr>
          <td><code>is</code></td>
          <td>타입 확인 (<code>if (obj is String)</code>)</td>
      </tr>
      <tr>
          <td><code>!is</code></td>
          <td><code>is</code>의 부정</td>
      </tr>
      <tr>
          <td><code>null</code></td>
          <td>널 참조 값</td>
      </tr>
      <tr>
          <td><code>object</code></td>
          <td>싱글톤 객체 또는 익명 객체 정의</td>
      </tr>
      <tr>
          <td><code>package</code></td>
          <td>패키지 선언</td>
      </tr>
      <tr>
          <td><code>return</code></td>
          <td>함수 또는 라벨에서 반환</td>
      </tr>
      <tr>
          <td><code>super</code></td>
          <td>상위 클래스 참조</td>
      </tr>
      <tr>
          <td><code>this</code></td>
          <td>현재 객체 참조</td>
      </tr>
      <tr>
          <td><code>throw</code></td>
          <td>예외 발생</td>
      </tr>
      <tr>
          <td><code>true</code></td>
          <td>불리언 상수: 참</td>
      </tr>
      <tr>
          <td><code>try</code></td>
          <td>예외 처리 블록 시작</td>
      </tr>
      <tr>
          <td><code>typealias</code></td>
          <td>타입 별칭 정의</td>
      </tr>
      <tr>
          <td><code>typeof</code></td>
          <td>Kotlin/JS 전용; 일반 Kotlin에서는 사용되지 않음</td>
      </tr>
      <tr>
          <td><code>val</code></td>
          <td>읽기 전용 변수 선언</td>
      </tr>
      <tr>
          <td><code>var</code></td>
          <td>변경 가능한 변수 선언</td>
      </tr>
      <tr>
          <td><code>when</code></td>
          <td>다중 조건 분기 (<code>switch</code> 대체)</td>
      </tr>
      <tr>
          <td><code>while</code></td>
          <td>조건이 참일 동안 반복</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="2-soft-keywords">2. Soft Keywords</h4>
<p><em>(특정 문맥에서만 키워드로 동작하며, 일반 식별자로 사용 가능)</em></p>
<table>
  <thead>
      <tr>
          <th>키워드</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>by</code></td>
          <td>위임 구현 (<code>class C : B by b</code>)</td>
      </tr>
      <tr>
          <td><code>catch</code></td>
          <td><code>try-catch</code>에서 예외 처리 블록</td>
      </tr>
      <tr>
          <td><code>constructor</code></td>
          <td>주/부생성자 명시 (<code>class A constructor(...)</code>)</td>
      </tr>
      <tr>
          <td><code>delegate</code></td>
          <td>속성 위임 내부 식별자 (컴파일러용)</td>
      </tr>
      <tr>
          <td><code>dynamic</code></td>
          <td>Kotlin/JS에서 동적 타입 선언</td>
      </tr>
      <tr>
          <td><code>field</code></td>
          <td>커스텀 getter/setter 내 백킹 필드 참조</td>
      </tr>
      <tr>
          <td><code>file</code></td>
          <td>파일 레벨 식별자 (메타프로그래밍/컴파일러용)</td>
      </tr>
      <tr>
          <td><code>finally</code></td>
          <td><code>try-finally</code>에서 항상 실행되는 블록</td>
      </tr>
      <tr>
          <td><code>get</code></td>
          <td>속성 getter 정의 (<code>val x: Int get() = ...</code>)</td>
      </tr>
      <tr>
          <td><code>import</code></td>
          <td>패키지/클래스 임포트</td>
      </tr>
      <tr>
          <td><code>init</code></td>
          <td>초기화 블록 (<code>init { ... }</code>)</td>
      </tr>
      <tr>
          <td><code>param</code></td>
          <td>어노테이션 파라미터 식별자</td>
      </tr>
      <tr>
          <td><code>property</code></td>
          <td>속성 관련 메타정보 식별자</td>
      </tr>
      <tr>
          <td><code>receiver</code></td>
          <td>확장 함수 수신 객체 식별자</td>
      </tr>
      <tr>
          <td><code>set</code></td>
          <td>속성 setter 정의 (<code>var x: Int set(value) { ... }</code>)</td>
      </tr>
      <tr>
          <td><code>setparam</code></td>
          <td>setter 내 파라미터 식별자 (<code>value</code>)</td>
      </tr>
      <tr>
          <td><code>where</code></td>
          <td>제네릭 제약 조건 (<code>&lt;T&gt; where T : Comparable&lt;T&gt;</code>)</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="3-modifier-keywords">3. Modifier Keywords</h4>
<p><em>(선언에 대한 속성 또는 동작을 지정)</em></p>
<table>
  <thead>
      <tr>
          <th>키워드</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>actual</code></td>
          <td>멀티플랫폼 프로젝트에서 실제 구현 지정</td>
      </tr>
      <tr>
          <td><code>abstract</code></td>
          <td>추상 클래스 또는 멤버 (구현 없음)</td>
      </tr>
      <tr>
          <td><code>annotation</code></td>
          <td>어노테이션 클래스 정의</td>
      </tr>
      <tr>
          <td><code>companion</code></td>
          <td>컴패니언 객체 선언 (<code>companion object { }</code>)</td>
      </tr>
      <tr>
          <td><code>const</code></td>
          <td>컴파일 타임 상수 (<code>const val MAX = 100</code>)</td>
      </tr>
      <tr>
          <td><code>crossinline</code></td>
          <td>람다 내 non-local return 금지</td>
      </tr>
      <tr>
          <td><code>data</code></td>
          <td>데이터 클래스 (<code>equals</code>, <code>hashCode</code>, <code>toString</code> 자동 생성)</td>
      </tr>
      <tr>
          <td><code>enum</code></td>
          <td>열거 클래스 정의</td>
      </tr>
      <tr>
          <td><code>expect</code></td>
          <td>멀티플랫폼에서 예상 선언</td>
      </tr>
      <tr>
          <td><code>external</code></td>
          <td>외부(Native/JS) 구현 선언</td>
      </tr>
      <tr>
          <td><code>final</code></td>
          <td>오버라이드 불가 (기본값, 명시적 사용 드묾)</td>
      </tr>
      <tr>
          <td><code>infix</code></td>
          <td>중위 함수 (<code>a plus b</code> 대신 <code>a plus b</code>)</td>
      </tr>
      <tr>
          <td><code>inline</code></td>
          <td>함수/클래스를 호출 위치에 인라인 확장</td>
      </tr>
      <tr>
          <td><code>inner</code></td>
          <td>내부 클래스 (외부 클래스 인스턴스 참조 가능)</td>
      </tr>
      <tr>
          <td><code>internal</code></td>
          <td>같은 모듈 내에서만 접근 가능</td>
      </tr>
      <tr>
          <td><code>lateinit</code></td>
          <td>나중에 초기화되는 non-null <code>var</code></td>
      </tr>
      <tr>
          <td><code>noinline</code></td>
          <td>람다를 인라인하지 않음</td>
      </tr>
      <tr>
          <td><code>open</code></td>
          <td>오버라이드 가능 (기본은 <code>final</code>)</td>
      </tr>
      <tr>
          <td><code>operator</code></td>
          <td>연산자 오버로딩 함수 지정</td>
      </tr>
      <tr>
          <td><code>out</code></td>
          <td>공변성 제네릭 (<code>Producer&lt;out T&gt;</code>)</td>
      </tr>
      <tr>
          <td><code>override</code></td>
          <td>상위 클래스/인터페이스 멤버 재정의</td>
      </tr>
      <tr>
          <td><code>private</code></td>
          <td>선언된 스코프 내에서만 접근 가능</td>
      </tr>
      <tr>
          <td><code>protected</code></td>
          <td>하위 클래스까지 접근 가능</td>
      </tr>
      <tr>
          <td><code>public</code></td>
          <td>모든 곳에서 접근 가능 (기본 접근 수준)</td>
      </tr>
      <tr>
          <td><code>reified</code></td>
          <td>인라인 함수에서 제네릭 타입 실체화</td>
      </tr>
      <tr>
          <td><code>sealed</code></td>
          <td>제한된 하위 클래스 집합 (밀봉 클래스)</td>
      </tr>
      <tr>
          <td><code>suspend</code></td>
          <td>코루틴에서 사용 가능한 함수</td>
      </tr>
      <tr>
          <td><code>tailrec</code></td>
          <td>꼬리 재귀 최적화 함수</td>
      </tr>
      <tr>
          <td><code>vararg</code></td>
          <td>가변 인자 (<code>fun f(vararg args: Int)</code>)</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="4-special-identifiers">4. Special Identifiers</h4>
<p><em>(특정 문맥에서만 특별한 의미를 가지는 식별자)</em></p>
<table>
  <thead>
      <tr>
          <th>식별자</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>field</code></td>
          <td>커스텀 getter/setter 내에서 백킹 필드 참조 (<code>get() = field</code>)</td>
      </tr>
      <tr>
          <td><code>it</code></td>
          <td>람다 식에서 단일 파라미터의 암시적 이름 (<code>list.map { it * 2 }</code>)</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>✅ <strong>참고</strong>:</p>
<ul>
<li><code>field</code>는 속성 접근자 내에서만 특별한 의미를 가지며, 그 외에서는 일반 식별자로 사용 가능합니다.</li>
<li><code>it</code>은 람다 파라미터가 하나일 때 자동으로 사용되는 이름입니다.</li>
</ul>
</blockquote>
<h3 id="basic-data-type">basic data type</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> a: Boolean = <span style="color:#66d9ef">true</span>     <span style="color:#75715e">// 논리 (true, false)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> b: Byte = <span style="color:#ae81ff">123</span>         <span style="color:#75715e">// 8 트 정수 (-128 ~ 127) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> c: Short = <span style="color:#ae81ff">123</span>        <span style="color:#75715e">// 16비트 정수 (-32768 ~ 32767) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> d: Int = <span style="color:#ae81ff">123</span>          <span style="color:#75715e">// 32비트 정수 (-2 31 ~ 2 31 -1) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> e: Long = <span style="color:#ae81ff">123L</span>        <span style="color:#75715e">// 64비트 정수 (-2 63 ~ 2 63 -1) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> f: Float = <span style="color:#ae81ff">12.3F</span>      <span style="color:#75715e">// 32비트 부동 소수점
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> g: Double = <span style="color:#ae81ff">12.3</span>      <span style="color:#75715e">// 64비트 부동 소수점 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> h: Char = <span style="color:#e6db74">&#39;A&#39;</span>         <span style="color:#75715e">// 문자 (글자 하나)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> i: String= <span style="color:#e6db74">&#34;ABC&#34;</span>      <span style="color:#75715e">// 문자열
</span></span></span></code></pre></div><p>
        <img src="/08.media/20250924073639-1758666999815-image.png" alt=" (Image resource not found)" ></p>
<h2 id="안드로이드-컴포넌트란">안드로이드 컴포넌트란</h2>
<h3 id="android-component">android component</h3>
<p>안드로이드 앱은 네 가지 핵심 구성 요소, 즉 <strong>안드로이드 컴포넌트</strong>로 이루어져 있습니다.<br>
이들은 각각 다른 역할을 수행하며, 앱이 정상적으로 동작하도록 지원합니다.<br>
네 가지 컴포넌트는 다음과 같습니다:</p>
<h4 id="1-액티비티-activity">1. **액티비티 **(Activity)</h4>
<p>액티비티는 <strong>앱의 화면을 구성하는 컴포넌트</strong>입니다.<br>
사용자가 보는 하나의 화면(예: 로그인 화면, 메인 화면 등)은 하나의 액티비티로 표현됩니다.<br>
앱을 실행하면, 기본 액티비티가 시작되어 그 내용이 안드로이드 기기의 화면에 표시됩니다.<br>
따라서 <strong>화면을 출력하려면 반드시 액티비티를 만들어야 합니다</strong>.</p>
<h5 id="관련-폴더-및-파일">관련 폴더 및 파일:</h5>
<ul>
<li><strong><code>res/layout/</code></strong><br>
→ 액티비티의 UI를 정의하는 <strong>XML 레이아웃 파일</strong>이 위치합니다.<br>
예: <code>activity_main.xml</code>, <code>login_screen.xml</code><br>
→ <code>setContentView(R.layout.activity_main)</code>에서 참조됨.</li>
<li><strong><code>src/</code> (Kotlin/Java 소스 코드)</strong><br>
→ 각 액티비티는 <code>AppCompatActivity</code>를 상속하는 클래스로 구현됩니다.<br>
예: <code>MainActivity.kt</code></li>
<li><strong><code>AndroidManifest.xml</code></strong><br>
→ 모든 액티비티는 반드시 여기에 <code>&lt;activity&gt;</code> 태그로 등록되어야 합니다.<br>
→ LAUNCHER 액티비티는 <code>&lt;intent-filter&gt;</code>로 지정됩니다.</li>
<li><strong><code>res/values/strings.xml</code>, <code>colors.xml</code>, <code>dimens.xml</code> 등</strong><br>
→ 액티비티 UI에서 사용하는 텍스트, 색상, 크기 등의 값 정의.</li>
</ul>
<blockquote>
<p><strong>액티비티는 <code>res/layout/</code>과 가장 밀접</strong>하며, <code>AndroidManifest.xml</code>에 등록되고, <code>src/</code> 내 클래스로 구현됩니다.</p>
</blockquote>
<hr>
<h4 id="2-서비스-service">2. **서비스 **(Service)</h4>
<p>서비스는 <strong>백그라운드에서 장시간 작업을 수행하는 컴포넌트</strong>입니다.<br>
화면을 표시하지 않으며, 사용자와 직접 상호작용하지 않습니다.<br>
예를 들어, 음악 재생, 파일 다운로드, 위치 추적과 같은 작업은 앱이 백그라운드에 있어도 계속 실행되어야 하므로 서비스를 사용합니다.</p>
<h5 id="관련-폴더-및-파일-1">관련 폴더 및 파일:</h5>
<ul>
<li><strong><code>src/</code> (Kotlin/Java 소스 코드)</strong><br>
→ <code>Service</code> 또는 <code>IntentService</code>, <code>JobIntentService</code> 등을 상속하는 클래스로 구현.<br>
예: <code>MusicPlaybackService.kt</code></li>
<li><strong><code>AndroidManifest.xml</code></strong><br>
→ <code>&lt;service android:name=&quot;.MusicPlaybackService&quot; /&gt;</code>로 등록 필수.<br>
→ 권한이 필요한 경우 <code>&lt;uses-permission&gt;</code>과 함께 사용.</li>
<li><strong><code>res/</code> 폴더와의 관계</strong>:<br>
→ 서비스는 <strong>UI가 없으므로 <code>layout</code>이나 <code>drawable</code> 등과 직접적 연관 없음</strong>.<br>
→ 단, 알림(Notification)을 표시할 경우 <code>res/drawable/</code>의 아이콘을 사용할 수 있음.</li>
</ul>
<blockquote>
<p><strong>서비스는 주로 <code>src/</code>와 <code>AndroidManifest.xml</code>에 의존</strong>, 리소스 폴더와는 간접적 연관만 있음.</p>
</blockquote>
<hr>
<h4 id="3-콘텐츠-프로바이더-content-provider">3. **콘텐츠 프로바이더 **(Content Provider)</h4>
<p>콘텐츠 프로바이더는 <strong>앱 간에 데이터를 공유하는 컴포넌트</strong>입니다.<br>
안드로이드 기기에는 여러 앱이 설치되어 있고, 이들 사이에서 데이터를 안전하게 주고받을 필요가 있습니다.<br>
예를 들어, 카카오톡에서 프로필 사진을 변경할 때 갤러리 앱의 사진을 선택할 수 있습니다.<br>
이때 갤러리 앱은 자신의 이미지 데이터를 <strong>콘텐츠 프로바이더를 통해 공유</strong>하고, 카카오톡은 이를 통해 데이터에 접근합니다.</p>
<h5 id="관련-폴더-및-파일-2">관련 폴더 및 파일:</h5>
<ul>
<li><strong><code>src/</code></strong><br>
→ <code>ContentProvider</code>를 상속하는 클래스로 구현.<br>
예: <code>ContactProvider.kt</code></li>
<li><strong><code>AndroidManifest.xml</code></strong><br>
→ <code>&lt;provider&gt;</code> 태그로 등록 필수.<br>
→ <code>android:authorities</code> 속성으로 고유 URI 지정 (예: <code>com.example.app.provider</code>).</li>
<li><strong>데이터베이스 관련</strong>:<br>
→ 일반적으로 <code>Room</code>, <code>SQLiteOpenHelper</code>와 함께 사용되며, 이는 <code>src/</code> 내부에 구현됨.</li>
<li><strong><code>res/</code> 폴더와의 관계</strong>:<br>
→ 콘텐츠 프로바이더 자체는 리소스 폴더와 <strong>거의 무관</strong>.<br>
→ 단, 공유되는 데이터가 이미지일 경우 <code>res/drawable/</code> 또는 외부 저장소 경로를 반환할 수 있음.</li>
</ul>
<blockquote>
<p><strong>콘텐츠 프로바이더는 <code>src/</code>와 <code>AndroidManifest.xml</code> 중심</strong>, 리소스 폴더와는 거의 독립적.</p>
</blockquote>
<hr>
<h4 id="4-브로드캐스트-리시버-broadcast-receiver">4. **브로드캐스트 리시버 **(Broadcast Receiver)</h4>
<p>브로드캐스트 리시버는 <strong>시스템에서 발생하는 특정 이벤트에 반응하는 컴포넌트</strong>입니다.<br>
여기서 말하는 이벤트는 사용자의 터치나 클릭과 같은 화면 상의 동작이 아니라,<br>
<strong>시스템 수준의 이벤트</strong>를 의미합니다.<br>
예를 들어, 기기 부팅 완료, 배터리 잔량 부족, 네트워크 연결 상태 변경 등이 있습니다.<br>
이러한 이벤트가 발생하면, 등록된 브로드캐스트 리시버가 자동으로 실행되어 적절한 처리를 수행할 수 있습니다.</p>
<h5 id="관련-폴더-및-파일-3">관련 폴더 및 파일:</h5>
<ul>
<li><strong><code>src/</code></strong><br>
→ <code>BroadcastReceiver</code>를 상속하는 클래스로 구현.<br>
예: <code>BootReceiver.kt</code></li>
<li><strong><code>AndroidManifest.xml</code></strong><br>
→ 정적 등록 시 <code>&lt;receiver&gt;</code> 태그 사용.<br>
예: 기기 부팅 시 실행되려면 <code>&lt;intent-filter&gt;</code>에 <code>android.intent.action.BOOT_COMPLETED</code> 지정.</li>
<li><strong>동적 등록</strong>:<br>
→ 액티비티나 서비스 내에서 <code>registerReceiver()</code>로 코드 상에서 등록 가능 → 이 경우 Manifest 등록 불필요.</li>
<li><strong><code>res/</code> 폴더와의 관계</strong>:<br>
→ 리시버는 <strong>UI 없이 이벤트만 처리</strong>하므로 리소스 폴더와 거의 무관.<br>
→ 단, 이벤트 처리 결과로 알림을 띄울 경우 <code>res/drawable/</code> 아이콘 사용 가능.</li>
</ul>
<blockquote>
<p><strong>브로드캐스트 리시버는 <code>src/</code>와 <code>AndroidManifest.xml</code>에 의존</strong>, 리소스 폴더와는 거의 관련 없음.</p>
</blockquote>
<hr>
<h4 id="정리">정리</h4>
<table>
  <thead>
      <tr>
          <th>컴포넌트</th>
          <th>태그</th>
          <th>주요 역할</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>액티비티</strong></td>
          <td><code>&lt;activity&gt;</code></td>
          <td>화면 표시 및 사용자 인터페이스 제공</td>
      </tr>
      <tr>
          <td><strong>서비스</strong></td>
          <td><code>&lt;service&gt;</code></td>
          <td>백그라운드에서 장시간 작업 실행</td>
      </tr>
      <tr>
          <td><strong>콘텐츠 프로바이더</strong></td>
          <td><code>&lt;provider&gt;</code></td>
          <td>앱 간 데이터 공유</td>
      </tr>
      <tr>
          <td><strong>브로드캐스트 리시버</strong></td>
          <td><code>&lt;receiver&gt;</code></td>
          <td>시스템 이벤트 수신 및 처리</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="resource-folder-리소스-폴더-와-rjava">resource folder 리소스 폴더 와 R.java</h3>
<ul>
<li>drawable： 이미지 리소스</li>
<li>layout： UI 구성에필요한 XML 리소스</li>
<li>mipmap： 앱 아이콘 이미지</li>
<li>values： 문자열 등의 값으로 이용되는 리소스</li>
</ul>
<blockquote>
<p>R.java 는 <strong>모든 리소스를 컴포넌트 코드에서 참조할 수 있게 해주는 브릿지</strong> 역할</p>
</blockquote>
<blockquote>
<p>R.java 의 경우 AGP 3.6 부터 제거 되었고 현재 R.txt 와 R.jar 형태로만 존재한다</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ find app/build -name <span style="color:#e6db74">&#34;R.*&#34;</span>
</span></span><span style="display:flex;"><span>app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/processDebugResources/R.jar
</span></span><span style="display:flex;"><span>app/build/intermediates/runtime_symbol_list/debug/processDebugResources/R.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ jar -tf app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/processDebugResources/R.jar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 특정 리소스 파일 검색</span>
</span></span><span style="display:flex;"><span>$ grep -i <span style="color:#e6db74">&#34;person1\|send\|test&#34;</span> app/build/intermediates/runtime_symbol_list/debug/processDebugResources/R.txt
</span></span><span style="display:flex;"><span>int drawable abc_vector_test 0x7f070077
</span></span><span style="display:flex;"><span>int drawable person1 0x7f0700e4
</span></span><span style="display:flex;"><span>int drawable send 0x7f0700e5
</span></span><span style="display:flex;"><span>int drawable test_level_drawable 0x7f0700e6
</span></span><span style="display:flex;"><span>int id immediateStop 0x7f0800dc
</span></span><span style="display:flex;"><span>int layout ime_base_split_test_activity 0x7f0b002d
</span></span><span style="display:flex;"><span>int layout ime_secondary_split_test_activity 0x7f0b002e
</span></span></code></pre></div><h3 id="gui-기본-개념">GUI 기본 개념</h3>
<h4 id="관심사의-분리-separation-of-concerns">관심사의 분리 **(Separation of Concerns)</h4>
<p>모든 GUI 프레임워크는 다음 세 가지 책임을 <strong>명확히 분리</strong>하려는 목표를 공유합니다:</p>
<table>
  <thead>
      <tr>
          <th>역할</th>
          <th>책임</th>
          <th>핵심 질문</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>**1. 구조 **(Structure)</td>
          <td>화면에 <strong>무엇이 있는가</strong>?</td>
          <td>“어떤 컴포넌트들이 있고, 어떻게 배치되어 있는가?”</td>
      </tr>
      <tr>
          <td>**2. 스타일 **(Presentation)</td>
          <td>화면이 <strong>어떻게 보이는가</strong>?</td>
          <td>“색상, 크기, 여백, 폰트, 정렬은 어떻게 되는가?”</td>
      </tr>
      <tr>
          <td>**3. 동작 **(Behavior)</td>
          <td>화면이 <strong>어떻게 반응하는가</strong>?</td>
          <td>“버튼 클릭 시 무엇을 하며, 데이터는 어떻게 바뀌는가?”</td>
      </tr>
  </tbody>
</table>
<h4 id="각-역할의-구현-방식-플랫폼별-비교"><strong>각 역할의 구현 방식: 플랫폼별 비교</strong></h4>
<table>
  <thead>
      <tr>
          <th>역할</th>
          <th>**Web **(HTML/CSS/JS)</th>
          <th>**Android **(Jetpack Compose 제외)</th>
          <th>**iOS **(SwiftUI)</th>
          <th><strong>Flutter</strong></th>
          <th>**데스크톱 **(예: Qt)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>구조</strong><br>(무엇을 보여줄까?)</td>
          <td><strong>HTML</strong><br>→ 태그 기반 계층 구조</td>
          <td><strong>XML 레이아웃 파일</strong><br>→ <code>&lt;LinearLayout&gt;</code>, <code>&lt;TextView&gt;</code> 등</td>
          <td><strong>Swift 코드</strong><br>→ 선언적 뷰 DSL (<code>VStack</code>, <code>Text</code>, <code>Button</code>)</td>
          <td><strong>Dart 위젯 트리</strong><br>→ <code>Column</code>, <code>Text</code>, <code>ElevatedButton</code></td>
          <td>**QML **(Qt Modeling Language)<br>또는 <strong>C++ 위젯 트리</strong></td>
      </tr>
      <tr>
          <td><strong>스타일</strong><br>(어떻게 보일까?)</td>
          <td><strong>CSS</strong><br>→ 완전 분리된 스타일 시트<br>→ 클래스, 선택자, 반응형 디자인</td>
          <td><strong>XML 속성 + 스타일 리소스</strong><br>→ <code>android:padding</code>, <code>style=&quot;@style/MyButton&quot;</code><br>→ <code>dimens.xml</code>, <code>colors.xml</code></td>
          <td><strong>메서드 체인</strong><br>→ <code>.frame(width: 100)</code>, <code>.foregroundColor(.blue)</code><br>→ <code>ViewModifier</code>로 재사용</td>
          <td><strong>위젯 내장 속성</strong><br>→ <code>TextStyle</code>, <code>BoxDecoration</code>, <code>SizedBox</code><br>→ <code>ThemeData</code>로 전역 스타일 통일</td>
          <td>**QSS **(Qt Style Sheets)<br>또는 <strong>속성 바인딩</strong></td>
      </tr>
      <tr>
          <td><strong>동작</strong><br>(어떻게 반응할까?)</td>
          <td>**JavaScript **(또는 TypeScript)<br>→ DOM 이벤트, 상태 관리 (React/Vue 등)</td>
          <td><strong>Kotlin / Java</strong><br>→ <code>setOnClickListener</code>, ViewModel, LiveData</td>
          <td><strong>Swift</strong><br>→ <code>@State</code>, <code>@Binding</code>, <code>Button(action: { ... })</code></td>
          <td><strong>Dart</strong><br>→ 상태 관리 (<code>setState</code>, <code>Provider</code>, <code>Riverpod</code>)</td>
          <td><strong>C++ / JavaScript</strong><br>→ 슬롯/시그널, 이벤트 핸들러</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>💡 <strong>공통점</strong>:</p>
<ul>
<li>모두 <strong>트리 구조</strong>(Tree)로 UI를 표현 (DOM, View Hierarchy, Widget Tree 등)</li>
<li><strong>선언적</strong>(Declarative) 방식이 주류 (특히 최신 프레임워크)</li>
<li><strong>상태 → UI</strong>의 단방향 흐름을 지향</li>
</ul>
</blockquote>
<h4 id="추상화된-개념-이름-cross-platform-terminology">**추상화된 개념 이름 **(Cross-Platform Terminology)</h4>
<table>
  <thead>
      <tr>
          <th>개념</th>
          <th>설명</th>
          <th>대응 용어 예시</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>UI Tree / Element Tree</strong></td>
          <td>컴포넌트의 계층 구조</td>
          <td>DOM Tree, View Hierarchy, Widget Tree</td>
      </tr>
      <tr>
          <td><strong>Layout System</strong></td>
          <td>크기와 위치를 계산하는 방식</td>
          <td>CSS Box Model, Android LayoutParams, SwiftUI Auto Layout, Flutter RenderObject</td>
      </tr>
      <tr>
          <td><strong>Styling System</strong></td>
          <td>시각적 속성 관리 체계</td>
          <td>CSS, Android Themes, SwiftUI Modifiers, Flutter ThemeData</td>
      </tr>
      <tr>
          <td><strong>Reactivity / State Management</strong></td>
          <td>상태 변화 → UI 자동 갱신</td>
          <td>React Hooks, Android ViewModel, SwiftUI <code>@State</code>, Flutter <code>setState</code></td>
      </tr>
  </tbody>
</table>
<h4 id="진화-방향-선언적-ui와-통합"><strong>진화 방향: 선언적 UI와 통합</strong></h4>
<p>과거에는 <strong>명령형</strong>(Imperative) 방식이 일반적이었으나 (예: <code>button.setWidth(100)</code>),<br>
최근에는 <strong>선언적</strong>(Declarative) 방식이 표준이 되었습니다:</p>
<blockquote>
<p>“<strong>어떻게 그리는가</strong>”가 아니라,<br>
“<strong>어떤 상태일 때 어떤 UI를 원하는가</strong>”를 기술</p>
</blockquote>
<ul>
<li><strong>React</strong> → Virtual DOM + 선언적 JSX</li>
<li><strong>Jetpack Compose / SwiftUI / Flutter</strong> → 순수 함수형 UI, 상태 기반 재구성</li>
<li><strong>Web Components / CSS Container Queries</strong> → 웹도 선언적/컴포넌트 기반으로 진화 중</li>
</ul>
<h4 id="요약-gui-개발의-거시적-틀"><strong>요약: GUI 개발의 거시적 틀</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>                     ┌───────────────────────┐
</span></span><span style="display:flex;"><span>                     │      사용자 입력       │
</span></span><span style="display:flex;"><span>                     │   (터치, 클릭, 키보드)  │
</span></span><span style="display:flex;"><span>                     └──────────┬────────────┘
</span></span><span style="display:flex;"><span>                                ▼
</span></span><span style="display:flex;"><span>                     ┌───────────────────────┐
</span></span><span style="display:flex;"><span>                     │     동작 **(Behavior)    │ ← 프로그래밍 언어
</span></span><span style="display:flex;"><span>                     │   (상태 변경, 로직 처리)  │
</span></span><span style="display:flex;"><span>                     └──────────┬────────────┘
</span></span><span style="display:flex;"><span>                                ▼
</span></span><span style="display:flex;"><span>                     ┌───────────────────────┐
</span></span><span style="display:flex;"><span>                     │     구조 **(Structure)   │ ← 마크업 또는 선언적 코드
</span></span><span style="display:flex;"><span>                     │   (어떤 컴포넌트가 있는가)│
</span></span><span style="display:flex;"><span>                     └──────────┬────────────┘
</span></span><span style="display:flex;"><span>                                ▼
</span></span><span style="display:flex;"><span>                     ┌───────────────────────┐
</span></span><span style="display:flex;"><span>                     │     스타일 **(Style)     │ ← 시각적 속성
</span></span><span style="display:flex;"><span>                     │   (크기, 색상, 여백 등)   │
</span></span><span style="display:flex;"><span>                     └──────────┬────────────┘
</span></span><span style="display:flex;"><span>                                ▼
</span></span><span style="display:flex;"><span>                     ┌───────────────────────┐
</span></span><span style="display:flex;"><span>                     │      렌더링 엔진        │
</span></span><span style="display:flex;"><span>                     │ (브라우저, OS, 프레임워크)│
</span></span><span style="display:flex;"><span>                     └───────────────────────┘
</span></span></code></pre></div><hr>
<h4 id="general-sizing-strategies">General Sizing Strategies</h4>
<table>
  <thead>
      <tr>
          <th>종류</th>
          <th>설명</th>
          <th>대표 예시</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>**절대 크기 **(Absolute / Fixed Size)</td>
          <td>고정된 수치로 크기를 지정</td>
          <td><code>width: 200px</code>,<code>height: 100dp</code></td>
      </tr>
      <tr>
          <td>**상대 크기 **(Relative Size)</td>
          <td>부모, 형제, 화면 등 다른 요소에 비례해 크기 결정</td>
          <td><code>width: 50%</code>,<code>flex: 1</code>,<code>weight</code></td>
      </tr>
      <tr>
          <td>**콘텐츠 기반 크기 **(Content-based / Intrinsic Size)</td>
          <td>내부 콘텐츠에 따라 자동 조정</td>
          <td><code>wrap_content</code>,<code>width: fit-content</code>,<code>intrinsicContentSize</code></td>
      </tr>
      <tr>
          <td>**부모 기반 크기 **(Parent-filling Size)</td>
          <td>부모 컨테이너를 꽉 채움</td>
          <td><code>match_parent</code>,<code>width: 100%</code>,<code>flex: 1</code>(특정 상황)</td>
      </tr>
  </tbody>
</table>
<h4 id="결론">결론</h4>
<blockquote>
<p><strong>모든 현대 GUI 시스템은 “구조–스타일–동작”이라는 3층 구조를 따르며</strong>,<br>
플랫폼에 따라 표현 방식은 다르지만 <strong>동일한 설계 철학</strong>을 공유합니다.<br>
이 틀을 이해하면 <strong>어떤 UI 프레임워크든 빠르게 학습하고 전이할 수 있습니다</strong>.</p>
</blockquote>
<p>이 구조는 단순한 기술 분류를 넘어, <strong>효율적인 소프트웨어 설계 원칙</strong> 그 자체입니다.
현대 GUI**(Graphical User Interface)** 개발은 <strong>선언적</strong>(declarative) 접근 방식을 많이 사용하며, 이는 일반적으로 다음과 같은 <strong>3가지 핵심 역할 분담</strong>으로 구성됩니다:</p>
<h3 id="레이아웃-구성-방법">레이아웃 구성 방법</h3>
<ul>
<li>레이아웃 xml 을 통해 선언적으로 구성</li>
<li>엑티비티 코드로 작성하는 방법</li>
</ul>
<p>코드로 구성하는 방법</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity</span> : AppCompatActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 이름 문자열을 출력할 TextView 생성
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">val</span> name = TextView(<span style="color:#66d9ef">this</span>).apply {
</span></span><span style="display:flex;"><span>            typeface = <span style="color:#a6e22e">Typeface</span>.DEFAULT_BOLD
</span></span><span style="display:flex;"><span>            text = <span style="color:#e6db74">&#34;Lake Louise&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 이미지를 출력할 ImageView 생성
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">val</span> image = ImageView(<span style="color:#66d9ef">this</span>).apply {
</span></span><span style="display:flex;"><span>            setImageDrawable(<span style="color:#a6e22e">ContextCompat</span>.getDrawable(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">R</span>.drawable.lake_l))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 주소 문자열을 출력할 TextView 생성
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">val</span> address = TextView(<span style="color:#66d9ef">this</span>).apply {
</span></span><span style="display:flex;"><span>            typeface = <span style="color:#a6e22e">Typeface</span>.DEFAULT_BOLD
</span></span><span style="display:flex;"><span>            text = <span style="color:#e6db74">&#34;Lake Louise, AB, 캐나다&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 세로 방향 LinearLayout 생성 및 설정
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">val</span> layout = LinearLayout(<span style="color:#66d9ef">this</span>).apply {
</span></span><span style="display:flex;"><span>            orientation = <span style="color:#a6e22e">LinearLayout</span>.VERTICAL
</span></span><span style="display:flex;"><span>            gravity = <span style="color:#a6e22e">Gravity</span>.CENTER
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 뷰들을 LinearLayout에 추가
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            addView(name, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT)
</span></span><span style="display:flex;"><span>            addView(image, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT)
</span></span><span style="display:flex;"><span>            addView(address, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT, <span style="color:#a6e22e">LinearLayout</span>.<span style="color:#a6e22e">LayoutParams</span>.WRAP_CONTENT)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 최종 레이아웃을 화면에 설정
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        setContentView(layout)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="empty-views-activity-실행-흐름">Empty Views Activity 실행 흐름</h3>
<pre tabindex="0"><code>AndroidManifest.xml
&lt;intent-filter&gt; 내부에
&lt;action android:name=&#34;android.intent.action.MAIN&#34; /&gt;  
&lt;category android:name=&#34;android.intent.category.LAUNCHER&#34; /&gt;
가 있는 엑티비티를 열어야 한다
android:name=&#34;.MainActivity&#34;
이므로 MainAvtivity 를 컴포넌트(액티비티)를 실행
---
MainAvtivity.ks
setContentView(R.layout.activity_main) 에 따라
activity_main.xml 를 로드

---

레이아웃이 하는 일
**화면 전체를 차지하는 `ConstraintLayout`** 을 만들고,
그 안에 **&#34;Hello World!&#34; 텍스트를 정중앙에 표시**하며,
**코드에서 이 레이아웃을 `R.id.main`으로 참조**할 수 있도록 ID를 부여합니다.
</code></pre><h3 id="안드로이드-리소스-식별자-종류-및-사용-사례-종합표">안드로이드 리소스 식별자 종류 및 사용 사례 종합표</h3>
<table>
  <thead>
      <tr>
          <th>리소스 유형<br>(Resource Type)</th>
          <th>정의 위치<br>(Resource Directory / File)</th>
          <th>주요 목적</th>
          <th>XML에서 사용 예</th>
          <th>코드에서 참조 방식</th>
          <th>실제 사용 사례</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>id</code></strong></td>
          <td>레이아웃 XML 내부 (<code>android:id</code>)</td>
          <td>뷰를 코드에서 식별</td>
          <td><code>android:id=&quot;@+id/submit_button&quot;</code></td>
          <td><code>R.id.submit_button</code></td>
          <td><code>findViewById(R.id.submit_button)</code>로 버튼 제어</td>
      </tr>
      <tr>
          <td><strong><code>string</code></strong></td>
          <td><code>res/values/strings.xml</code></td>
          <td>텍스트 내용 관리, 다국어 지원</td>
          <td><code>android:text=&quot;@string/app_name&quot;</code></td>
          <td><code>R.string.app_name</code></td>
          <td><code>getString(R.string.welcome)</code>로 메시지 표시</td>
      </tr>
      <tr>
          <td><strong><code>color</code></strong></td>
          <td><code>res/values/colors.xml</code></td>
          <td>색상 값 정의 및 재사용</td>
          <td><code>android:textColor=&quot;@color/primary&quot;</code></td>
          <td><code>R.color.primary</code></td>
          <td><code>ContextCompat.getColor(context, R.color.error)</code></td>
      </tr>
      <tr>
          <td><strong><code>dimen</code></strong></td>
          <td><code>res/values/dimens.xml</code></td>
          <td>여백, 크기, 글자 크기 정의</td>
          <td><code>android:padding=&quot;@dimen/activity_margin&quot;</code></td>
          <td><code>R.dimen.activity_margin</code></td>
          <td><code>resources.getDimension(R.dimen.text_size)</code></td>
      </tr>
      <tr>
          <td><strong><code>style</code></strong></td>
          <td><code>res/values/styles.xml</code></td>
          <td>뷰 또는 앱 전체의 디자인 규칙 정의</td>
          <td><code>style=&quot;@style/CustomButton&quot;</code></td>
          <td><code>R.style.CustomButton</code></td>
          <td>액티비티 테마: <code>android:theme=&quot;@style/Theme.MyApp&quot;</code></td>
      </tr>
      <tr>
          <td><strong><code>layout</code></strong></td>
          <td><code>res/layout/</code> 폴더 내 XML 파일</td>
          <td>화면 UI 구조 정의</td>
          <td>— (파일 자체가 리소스)</td>
          <td><code>R.layout.activity_main</code></td>
          <td><code>setContentView(R.layout.activity_main)</code></td>
      </tr>
      <tr>
          <td><strong><code>drawable</code></strong></td>
          <td><code>res/drawable/</code> 폴더</td>
          <td>이미지, 아이콘, 벡터 그래픽</td>
          <td><code>android:src=&quot;@drawable/ic_home&quot;</code></td>
          <td><code>R.drawable.ic_home</code></td>
          <td><code>ImageView.setImageResource(R.drawable.logo)</code></td>
      </tr>
      <tr>
          <td><strong><code>mipmap</code></strong></td>
          <td><code>res/mipmap-*/</code> 폴더</td>
          <td><strong>앱 아이콘 전용</strong> 이미지</td>
          <td><code>android:icon=&quot;@mipmap/ic_launcher&quot;</code></td>
          <td><code>R.mipmap.ic_launcher</code></td>
          <td><code>AndroidManifest.xml</code>에서 앱 아이콘 지정</td>
      </tr>
      <tr>
          <td><strong><code>array</code></strong></td>
          <td><code>res/values/arrays.xml</code></td>
          <td>문자열/정수 배열 정의</td>
          <td>—</td>
          <td><code>R.array.countries</code></td>
          <td><code>resources.getStringArray(R.array.countries)</code></td>
      </tr>
      <tr>
          <td><strong><code>bool</code></strong></td>
          <td><code>res/values/bools.xml</code></td>
          <td>논리값 상수 정의</td>
          <td><code>android:enabled=&quot;@bool/is_pro&quot;</code></td>
          <td><code>R.bool.is_pro</code></td>
          <td><code>resources.getBoolean(R.bool.is_tablet)</code></td>
      </tr>
      <tr>
          <td><strong><code>integer</code></strong></td>
          <td><code>res/values/integers.xml</code></td>
          <td>정수 상수 정의</td>
          <td><code>android:max=&quot;@integer/max_count&quot;</code></td>
          <td><code>R.integer.max_count</code></td>
          <td><code>resources.getInteger(R.integer.retry_limit)</code></td>
      </tr>
      <tr>
          <td><strong><code>anim</code></strong></td>
          <td><code>res/anim/</code> 폴더</td>
          <td>뷰 애니메이션 정의</td>
          <td>—</td>
          <td><code>R.anim.fade_in</code></td>
          <td><code>overridePendingTransition(R.anim.slide_in, R.anim.slide_out)</code></td>
      </tr>
      <tr>
          <td><strong><code>animator</code></strong></td>
          <td><code>res/animator/</code> 폴더</td>
          <td>속성 애니메이션 (Property Animation)</td>
          <td>—</td>
          <td><code>R.animator.rotate</code></td>
          <td><code>AnimatorInflater.loadAnimator(context, R.animator.bounce)</code></td>
      </tr>
      <tr>
          <td><strong><code>menu</code></strong></td>
          <td><code>res/menu/</code> 폴더</td>
          <td>액션바, 컨텍스트 메뉴 정의</td>
          <td>—</td>
          <td><code>R.menu.main_menu</code></td>
          <td><code>menuInflater.inflate(R.menu.main_menu, menu)</code></td>
      </tr>
      <tr>
          <td><strong><code>xml</code></strong></td>
          <td><code>res/xml/</code> 폴더</td>
          <td>설정, 검색, 키보드 등 구조화된 데이터</td>
          <td>—</td>
          <td><code>R.xml.preferences</code></td>
          <td><code>PreferenceFragmentCompat</code>에서 설정 로드</td>
      </tr>
      <tr>
          <td><strong><code>font</code></strong></td>
          <td><code>res/font/</code> 폴더</td>
          <td>커스텀 글꼴 정의</td>
          <td><code>android:fontFamily=&quot;@font/nanum_gothic&quot;</code></td>
          <td><code>R.font.nanum_gothic</code></td>
          <td><code>ResourcesCompat.getFont(context, R.font.my_font)</code></td>
      </tr>
      <tr>
          <td><strong><code>raw</code></strong></td>
          <td><code>res/raw/</code> 폴더</td>
          <td>원시 데이터 파일 (오디오, JSON 등)</td>
          <td>—</td>
          <td><code>R.raw.sound_effect</code></td>
          <td><code>MediaPlayer.create(context, R.raw.bgm)</code></td>
      </tr>
      <tr>
          <td><strong><code>plurals</code></strong></td>
          <td><code>res/values/strings.xml</code></td>
          <td>복수형 문자열 (수량에 따라 문장 변경)</td>
          <td>—</td>
          <td><code>R.plurals.item_count</code></td>
          <td><code>resources.getQuantityString(R.plurals.item_count, 3, 3)</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="-참고-설명">📌 참고 설명</h4>
<ul>
<li>
<p><strong><code>@+id/</code> vs <code>@id/</code></strong>:</p>
<ul>
<li><code>@+id/name</code> → <strong>새로 생성</strong> (처음 사용 시)</li>
<li><code>@id/name</code> → <strong>기존 ID 참조</strong> (이미 정의된 경우)</li>
</ul>
</li>
<li>
<p><strong><code>drawable</code> vs <code>mipmap</code></strong>:</p>
<ul>
<li><code>drawable</code>: 일반 이미지 (버튼 아이콘, 배경 등)</li>
<li><code>mipmap</code>: <strong>앱 런처 아이콘 전용</strong> → 시스템이 다양한 해상도에서 안정적으로 표시</li>
</ul>
</li>
<li>
<p><strong><code>dimen</code> 단위</strong>:</p>
<ul>
<li><code>dp</code> → 화면 밀도 독립적 길이 (여백, 크기)</li>
<li><code>sp</code> → 사용자 글꼴 크기 설정 반영 (텍스트 크기)</li>
</ul>
</li>
<li>
<p><strong><code>plurals</code> 예시</strong> (<code>strings.xml</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;plurals</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;item_count&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span> <span style="color:#a6e22e">quantity=</span><span style="color:#e6db74">&#34;zero&#34;</span><span style="color:#f92672">&gt;</span>아이템 없음<span style="color:#f92672">&lt;/item&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span> <span style="color:#a6e22e">quantity=</span><span style="color:#e6db74">&#34;one&#34;</span><span style="color:#f92672">&gt;</span>%d개의 아이템<span style="color:#f92672">&lt;/item&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span> <span style="color:#a6e22e">quantity=</span><span style="color:#e6db74">&#34;other&#34;</span><span style="color:#f92672">&gt;</span>%d개의 아이템들<span style="color:#f92672">&lt;/item&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/plurals&gt;</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="뷰-클래스">뷰 클래스</h3>
<h4 id="android-레이아웃layout-및-ui-뷰view-종류">Android 레이아웃(Layout) 및 UI 뷰(View) 종류</h4>
<p>
        <img src="/08.media/20251012175105-1760259065907-image.png" alt=" (Image resource not found)" ></p>
<p>Android SDK에서 제공하는 주요 <strong>레이아웃(ViewGroup)</strong> 및 <strong>UI 뷰(View)</strong> 컴포넌트를 아래 표로 정리했습니다.</p>
<ul>
<li><strong>레이아웃</strong>(Layout/ViewGroup): 다른 뷰를 담을 수 있는 컨테이너 역할</li>
<li><strong>UI 뷰</strong>(View): 사용자와 직접 상호작용하거나 정보를 표시하는 위젯</li>
</ul>
<table>
  <thead>
      <tr>
          <th>분류</th>
          <th>클래스 이름</th>
          <th>설명</th>
          <th>주요 특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>**레이아웃 **(ViewGroup)</td>
          <td><code>LinearLayout</code></td>
          <td>자식 뷰를 수평(<code>horizontal</code>) 또는 수직(<code>vertical</code>)으로 배열</td>
          <td><code>layout_weight</code>, <code>orientation</code> 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>RelativeLayout</code></td>
          <td>자식 뷰 간 또는 부모 기준 상대 위치로 배치</td>
          <td><code>layout_alignParent*</code>, <code>layout_toRightOf</code> 등 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>ConstraintLayout</code></td>
          <td>유연하고 성능 좋은 제약 기반 레이아웃</td>
          <td><code>layout_constraint*</code> 속성, 플랫 계층 구조 가능</td>
      </tr>
      <tr>
          <td></td>
          <td><code>FrameLayout</code></td>
          <td>자식 뷰를 스택처럼 겹쳐 배치 (기본: 좌상단)</td>
          <td>간단한 오버레이, 프래그먼트 컨테이너로 자주 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>GridLayout</code></td>
          <td>그리드(행/열) 형태로 자식 뷰 배치</td>
          <td><code>row</code>, <code>column</code>, <code>span</code> 지정 가능</td>
      </tr>
      <tr>
          <td></td>
          <td><code>CoordinatorLayout</code></td>
          <td>자식 뷰 간 상호작용(예: 스크롤 동작) 지원</td>
          <td><code>Behavior</code> 기반, Material Design과 통합</td>
      </tr>
      <tr>
          <td></td>
          <td><code>ScrollView</code></td>
          <td>세로 스크롤 가능한 단일 자식 컨테이너</td>
          <td>자식은 하나만 허용 (보통 <code>LinearLayout</code> 등 포함)</td>
      </tr>
      <tr>
          <td></td>
          <td><code>HorizontalScrollView</code></td>
          <td>가로 스크롤 가능한 단일 자식 컨테이너</td>
          <td><code>ScrollView</code>의 수평 버전</td>
      </tr>
      <tr>
          <td></td>
          <td><code>RecyclerView</code></td>
          <td>대량 데이터 리스트/그리드 효율적 표시</td>
          <td><code>ViewHolder</code>, <code>LayoutManager</code>, <code>Adapter</code> 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>ViewPager</code> / <code>ViewPager2</code></td>
          <td>좌우 스와이프로 페이지 전환</td>
          <td><code>Fragment</code> 또는 뷰 페이징, <code>ViewPager2</code>는 <code>RecyclerView</code> 기반</td>
      </tr>
      <tr>
          <td></td>
          <td><code>AppBarLayout</code></td>
          <td><code>Toolbar</code> 등과 함께 스크롤 동작 통합</td>
          <td><code>CoordinatorLayout</code>과 함께 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>DrawerLayout</code></td>
          <td>슬라이딩 드로어(네비게이션 메뉴) 제공</td>
          <td>좌/우 사이드 메뉴 구현</td>
      </tr>
      <tr>
          <td></td>
          <td><code>SwipeRefreshLayout</code></td>
          <td>내부 뷰를 당겨서 새로고침</td>
          <td><code>onRefresh()</code> 콜백 제공</td>
      </tr>
      <tr>
          <td>**UI 뷰 **(View)</td>
          <td><code>TextView</code></td>
          <td>텍스트 표시</td>
          <td><code>text</code>, <code>textSize</code>, <code>textColor</code> 등</td>
      </tr>
      <tr>
          <td></td>
          <td><code>EditText</code></td>
          <td>사용자 텍스트 입력</td>
          <td><code>inputType</code>, <code>hint</code>, <code>imeOptions</code> 등</td>
      </tr>
      <tr>
          <td></td>
          <td><code>Button</code></td>
          <td>클릭 가능한 버튼</td>
          <td><code>text</code>, <code>onClick</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>ImageButton</code></td>
          <td>이미지 기반 버튼</td>
          <td><code>src</code>로 이미지 지정</td>
      </tr>
      <tr>
          <td></td>
          <td><code>ImageView</code></td>
          <td>이미지 표시</td>
          <td><code>src</code>, <code>scaleType</code>, <code>adjustViewBounds</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>CheckBox</code></td>
          <td>체크 가능 토글</td>
          <td><code>checked</code>, <code>onCheckedChanged</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>RadioButton</code></td>
          <td>라디오 버튼 (RadioButtonGroup 내 사용)</td>
          <td>단일 선택</td>
      </tr>
      <tr>
          <td></td>
          <td><code>RadioGroup</code></td>
          <td><code>RadioButton</code> 그룹 컨테이너</td>
          <td><code>ViewGroup</code>이지만 UI 위젯 성격 강함</td>
      </tr>
      <tr>
          <td></td>
          <td><code>Switch</code> / <code>ToggleButton</code></td>
          <td>ON/OFF 토글 스위치</td>
          <td><code>checked</code>, <code>textOn</code>/<code>textOff</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>ProgressBar</code></td>
          <td>진행 상태 표시</td>
          <td><code>indeterminate</code>, <code>progress</code>, <code>max</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>SeekBar</code></td>
          <td>사용자가 값을 드래그로 선택</td>
          <td><code>progress</code>, <code>thumb</code>, <code>onProgressChanged</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>RatingBar</code></td>
          <td>별점 평가 UI</td>
          <td><code>numStars</code>, <code>rating</code>, <code>stepSize</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>Spinner</code></td>
          <td>드롭다운 선택 목록</td>
          <td><code>Adapter</code>, <code>onItemSelected</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>AutoCompleteTextView</code></td>
          <td>입력 시 자동 완성 제안</td>
          <td><code>Adapter</code>, <code>threshold</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>WebView</code></td>
          <td>웹 콘텐츠 표시</td>
          <td>HTML/JavaScript 렌더링</td>
      </tr>
      <tr>
          <td></td>
          <td><code>SurfaceView</code> / <code>TextureView</code></td>
          <td>고성능 그래픽/비디오 렌더링</td>
          <td>별도 렌더링 스레드 사용</td>
      </tr>
      <tr>
          <td></td>
          <td><code>CardView</code></td>
          <td>그림자와 모서리 둥근 카드 UI</td>
          <td><code>cardElevation</code>, <code>cardCornerRadius</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>FloatingActionButton</code> (FAB)</td>
          <td>Material Design 플로팅 액션 버튼</td>
          <td><code>src</code>, <code>size</code>, <code>onClick</code></td>
      </tr>
      <tr>
          <td></td>
          <td><code>Toolbar</code></td>
          <td>액션바 대체 커스텀 타이틀바</td>
          <td>메뉴, 타이틀, 네비게이션 아이콘 포함 가능</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p><strong>참고</strong>:</p>
<ul>
<li>모든 뷰는 <code>android.view.View</code>를 상속하며, 레이아웃은 <code>android.view.ViewGroup</code> (View의 하위 클래스)를 상속합니다.</li>
<li>Material Components (예: <code>MaterialButton</code>, <code>TextInputLayout</code>) 등은 위 기본 위젯을 확장한 라이브러리 기반 뷰입니다.</li>
<li>커스텀 뷰를 직접 정의하여 사용할 수도 있습니다.</li>
</ul>
</blockquote>
<h4 id="android-뷰-속성-분류-레이아웃-속성-vs-ui-뷰-속성">Android 뷰 속성 분류: 레이아웃 속성 vs UI 뷰 속성</h4>
<p>Android에서 뷰(View)는 두 가지 주요 속성 범주로 나뉩니다:</p>
<ol>
<li>
<p><strong>레이아웃 (Layout Attributes)</strong>: 부모 레이아웃(ViewGroup)이 자식 뷰의 배치를 제어하기 위해 사용하는 속성입니다.<br>
→ 예: <code>android:layout_width</code>, <code>android:layout_height</code>, <code>app:layout_constraint...</code> 등<br>
→ 이 속성들은 <strong>자식 뷰에서 선언되지만, 실제로는 부모 레이아웃이 해석</strong>합니다.</p>
</li>
<li>
<p><strong>UI 뷰 속성(View Attributes)</strong>: 뷰 자체의 외형, 동작, 상태 등을 제어하는 속성입니다.<br>
→ 예: <code>android:text</code>, <code>android:background</code>, <code>android:onClick</code> 등<br>
→ 이 속성들은 <strong>해당 뷰 클래스 내부에서 직접 처리</strong>됩니다.</p>
</li>
</ol>
<p>아래 표는 대표적인 속성들을 분류한 것입니다.</p>
<table>
  <thead>
      <tr>
          <th>속성 이름</th>
          <th>범주</th>
          <th>설명</th>
          <th>사용 가능한 뷰/레이아웃</th>
          <th>추가</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:layout_width</code></td>
          <td>레이아웃 속성</td>
          <td>뷰의 가로 크기 지정 (<code>match_parent</code>, <code>wrap_content</code>, 고정값)</td>
          <td>모든 ViewGroup의 자식 뷰</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:layout_height</code></td>
          <td>레이아웃 속성</td>
          <td>뷰의 세로 크기 지정</td>
          <td>모든 ViewGroup의 자식 뷰</td>
          <td>ex)</td>
      </tr>
      <tr>
          <td><code>android:layout_margin*</code> (<code>top</code>, <code>bottom</code>, <code>start</code>, <code>end</code> 등)</td>
          <td>레이아웃 속성</td>
          <td>뷰 외부 여백 지정</td>
          <td>모든 ViewGroup의 자식 뷰</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:layout_gravity</code></td>
          <td>레이아웃 속성</td>
          <td>부모 내에서 뷰의 정렬 방식 (LinearLayout, FrameLayout 등에서 사용)</td>
          <td>LinearLayout, FrameLayout 자식</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:layout_weight</code></td>
          <td>레이아웃 속성</td>
          <td>LinearLayout에서 공간 배분 비율 지정</td>
          <td>LinearLayout 자식</td>
          <td></td>
      </tr>
      <tr>
          <td><code>app:layout_constraint*</code></td>
          <td>레이아웃 속성</td>
          <td>ConstraintLayout에서 제약 조건 정의</td>
          <td>ConstraintLayout 자식</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:layout_alignParent*</code></td>
          <td>레이아웃 속성</td>
          <td>RelativeLayout에서 부모 기준 정렬</td>
          <td>RelativeLayout 자식</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:layout_toRightOf</code>, <code>android:layout_below</code> 등</td>
          <td>레이아웃 속성</td>
          <td>RelativeLayout에서 다른 뷰 기준 배치</td>
          <td>RelativeLayout 자식</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:text</code></td>
          <td>UI 뷰 속성</td>
          <td>TextView 계열 뷰에 표시할 텍스트</td>
          <td>TextView, Button, EditText 등</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:background</code></td>
          <td>UI 뷰 속성</td>
          <td>뷰의 배경 지정 (색상, drawable 등)</td>
          <td>모든 View</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:padding*</code> (<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>, <code>start</code>, <code>end</code>)</td>
          <td>UI 뷰 속성</td>
          <td>뷰 내부 여백 지정</td>
          <td>모든 View</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:onClick</code></td>
          <td>UI 뷰 속성</td>
          <td>클릭 이벤트 핸들러 지정</td>
          <td>모든 View</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:visibility</code></td>
          <td>UI 뷰 속성</td>
          <td>뷰의 표시 여부 (<code>visible</code>, <code>invisible</code>: 자리 차지, <code>gone</code>: 자리 사라짐)</td>
          <td>모든 View</td>
          <td>코드에서 사용 : View.VISIBLE,  View.INVISIBLE</td>
      </tr>
      <tr>
          <td><code>android:enabled</code></td>
          <td>UI 뷰 속성</td>
          <td>뷰의 활성화 상태</td>
          <td>모든 View</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:src</code></td>
          <td>UI 뷰 속성</td>
          <td>ImageView에 표시할 이미지 리소스</td>
          <td>ImageView</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:hint</code></td>
          <td>UI 뷰 속성</td>
          <td>EditText의 힌트 텍스트</td>
          <td>EditText</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:textColor</code></td>
          <td>UI 뷰 속성</td>
          <td>텍스트 색상</td>
          <td>TextView 계열</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:gravity</code></td>
          <td>UI 뷰 속성</td>
          <td>뷰 내부 콘텐츠 정렬 방식</td>
          <td>TextView, Button 등 콘텐츠 포함 뷰</td>
          <td></td>
      </tr>
      <tr>
          <td><code>android:id</code></td>
          <td><strong>UI 뷰 속성</strong></td>
          <td>뷰의 고유 식별자 지정. 코드에서 참조하거나, 레이아웃 제약 조건에서 참조 가능</td>
          <td><strong>모든 View 및 ViewGroup</strong>(<code>TextView</code>,<code>Button</code>,<code>LinearLayout</code>,<code>ConstraintLayout</code>등 전부)</td>
          <td></td>
      </tr>
  </tbody>
</table>
<blockquote>
<p><strong>참고</strong>:</p>
<ul>
<li><code>layout_*</code> 접두사가 붙은 속성은 <strong>부모 레이아웃에 따라 다르게 해석</strong>되며, 해당 부모 레이아웃에서만 유효합니다.</li>
<li>일반 <code>android:*</code> 속성은 뷰 자체에 적용되며, 뷰 클래스가 지원해야 사용 가능합니다.</li>
<li><code>app:*</code> 네임스페이스는 커스텀 속성 또는 ConstraintLayout, Material Design 컴포넌트 등에서 사용됩니다.</li>
</ul>
</blockquote>
<ul>
<li><code>android:id=&quot;@+id/text&quot;</code>, <code>findViewByld()</code></li>
<li>width height 의 경우 3가지 방식 사용가능
<ul>
<li>수치 : px, dp</li>
<li>match_parent : 부모의 크기 전체</li>
<li>wrap_content : 자신의 적절한 크기</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>프로퍼티</strong>(property) == <strong>필드 + getter + setter</strong> 내부적으로는 여전히 private 필드가 있고, public getter/setter 메서드가 생성 즉 문법적 설탕</p>
</blockquote>
<h4 id="inputtype-속성값"><code>inputType</code> 속성값</h4>
<table>
  <thead>
      <tr>
          <th>속성값</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>none</code></td>
          <td>입력 유형을 지정하지 않은 상태. 모든 문자 입력 가능하며 줄바꿈 가능</td>
      </tr>
      <tr>
          <td><code>text</code></td>
          <td>문자열 한 줄 입력</td>
      </tr>
      <tr>
          <td><code>textCapCharacters</code></td>
          <td>대문자 입력 모드 (모든 문자가 자동으로 대문자)</td>
      </tr>
      <tr>
          <td><code>textCapWords</code></td>
          <td>각 단어의 첫 글자를 자동으로 대문자로 입력</td>
      </tr>
      <tr>
          <td><code>textCapSentences</code></td>
          <td>각 문장의 첫 글자를 자동으로 대문자로 입력</td>
      </tr>
      <tr>
          <td><code>textMultiLine</code></td>
          <td>여러 줄 입력 가능</td>
      </tr>
      <tr>
          <td><code>textNoSuggestions</code></td>
          <td>단어 입력 시 키보드의 추천 단어(자동 완성)를 표시하지 않음</td>
      </tr>
      <tr>
          <td><code>textUri</code></td>
          <td>URL 입력 모드 (URL에 적합한 키보드 레이아웃 제공)</td>
      </tr>
      <tr>
          <td><code>textEmailAddress</code></td>
          <td>이메일 주소 입력 모드 (이메일 형식에 맞는 키보드 제공)</td>
      </tr>
      <tr>
          <td><code>textPassword</code></td>
          <td>비밀번호 입력 모드. 입력한 문자는 점(●)으로 표시되며, 키보드는 영문자, 숫자, 특수 문자만 표시</td>
      </tr>
      <tr>
          <td><code>textVisiblePassword</code></td>
          <td><code>textPassword</code>와 동일하나, 입력한 문자가 그대로 보임 (가시적 비밀번호)</td>
      </tr>
      <tr>
          <td><code>number</code></td>
          <td>숫자만 입력 가능한 모드</td>
      </tr>
      <tr>
          <td><code>numberSigned</code></td>
          <td><code>number</code>와 동일하나, 부호(마이너스 <code>-</code>) 입력 가능</td>
      </tr>
      <tr>
          <td><code>numberDecimal</code></td>
          <td><code>number</code>와 동일하나, 소수점(<code>.</code>) 입력 가능</td>
      </tr>
      <tr>
          <td><code>numberPassword</code></td>
          <td>숫자 키만 사용 가능하며, 입력 내용은 점(●)으로 표시 (숫자 기반 비밀번호)</td>
      </tr>
      <tr>
          <td><code>phone</code></td>
          <td>전화번호 입력 모드 (전화기 스타일 키패드 제공)</td>
      </tr>
  </tbody>
</table>
<h4 id="뷰-바인딩--findviewbyld-대신-뷰를-찾는-방법">뷰 바인딩 : findViewByld() 대신 뷰를 찾는 방법</h4>
<p>build.gradle 파일을 열고 android 영역에 viewBinding.isEnabled = true를 설정<br>
레이아웃 XML 파일에 등록된 뷰 객체를 포함하는 클래스가 자동으로 만들어진다</p>
<p>자동으로 만들어 지는 클래스의 이름은 레이아웃 XML 파일명을 따릅니다. 첫 글자를 대문자
로 하고 밑줄<code>(_)</code>은 빼고 뒤에 오는 단어를 대문자로 만든 후 ‘Binding’을 추가합니다. 예를 들
어 다음과 같습니다.
• activity_main.xml -&gt; ActivityMainBinding
• item_main.xml -&gt; ItemMainBinding</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity</span> : AppCompatActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 바인딩 객체 획득
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">val</span> binding = <span style="color:#a6e22e">ActivityMainBinding</span>.inflate(layoutInflater)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 액티비티 화면 출력
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        setContentView(binding.root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 뷰 객체 이용 (visibleBtn 클릭 시 targetView 보이기)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        binding.visibleBtn.setOnClickListener {
</span></span><span style="display:flex;"><span>            binding.targetView.visibility = <span style="color:#a6e22e">View</span>.VISIBLE
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 뷰 객체 이용 (invisibleBtn 클릭 시 targetView 숨기기)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        binding.invisibleBtn.setOnClickListener {
</span></span><span style="display:flex;"><span>            binding.targetView.visibility = <span style="color:#a6e22e">View</span>.INVISIBLE
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>뷰 바인딩 의도적 비 활성화 tools:viewBindingIgnore=&ldquo;true&rdquo; 를 레이아웃 안에 넣는다</p>
</blockquote>
<h4 id="linear-layout">Linear Layout</h4>
<p>직선 배치</p>
<ul>
<li><strong>android:orientation=&ldquo;vertical&rdquo;</strong>: 자식 뷰를 <strong>세로 방향</strong>으로, 위에서 아래로 쌓습니다. (열, Column)</li>
<li><strong>android:orientation=&ldquo;horizontal&rdquo;</strong>: 자식 뷰를 <strong>가로 방향</strong>으로, 왼쪽에서 오른쪽으로 쌓습니다. (행, Row)</li>
</ul>
<h5 id="layout_weight-속성">layout_weight 속성</h5>
<p><strong>핵심 원리: <code>layout_weight</code>는 &ldquo;남은 공간&quot;에 작동한다</strong></p>
<ol>
<li>먼저, <strong><code>layout_width</code> 또는 <code>layout_height</code>가 고정값이나 <code>wrap_content</code>인 자식 뷰들</strong>의 크기를 계산합니다.</li>
<li>그 후, <strong>부모 레이아웃의 전체 크기에서 이미 사용된 공간을 뺀 &ldquo;남은 공간</strong>&ldquo;을 계산합니다.</li>
<li>이 <strong>남은 공간을 <code>layout_weight</code> 비율에 따라 분배</strong>합니다.</li>
</ol>
<blockquote>
<p>🔑 따라서, <strong>&ldquo;남은 공간이 존재해야 <code>layout_weight</code>가 효과를 발휘&rdquo;</strong> 합니다.</p>
</blockquote>
<h5 id="세로-방향-linearlayout-orientationvertical-기준">세로 방향 LinearLayout (<code>orientation=&quot;vertical&quot;</code>) 기준</h5>
<table>
  <thead>
      <tr>
          <th>상위 레이아웃의 <code>height</code></th>
          <th>자식 뷰의 <code>layout_height</code></th>
          <th><code>layout_weight</code> 효과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>match_parent</code></td>
          <td><code>0dp</code></td>
          <td>✅ <strong>효과 있음</strong> → 남은 공간이 있음</td>
      </tr>
      <tr>
          <td><code>wrap_content</code></td>
          <td><code>0dp</code></td>
          <td>❌ <strong>거의 효과 없음</strong> → 남은 공간 ≈ 0</td>
      </tr>
      <tr>
          <td><code>match_parent</code></td>
          <td><code>wrap_content</code> + <code>weight</code></td>
          <td>⚠️ <strong>비추천</strong> → 예측 불가능한 동작</td>
      </tr>
      <tr>
          <td><code>wrap_content</code></td>
          <td><code>wrap_content</code> + <code>weight</code></td>
          <td>❌ <strong>의미 없음</strong> → 공간이 없음</td>
      </tr>
  </tbody>
</table>
<h5 id="gravity-속성">Gravity 속성</h5>
<p><strong>핵심 원리: <code>gravity</code>는 &ldquo;내부 정렬&rdquo;, <code>layout_gravity</code>는 &ldquo;외부 정렬&rdquo;</strong>
두 속성은 정렬 대상이 완전히 다릅니다.</p>
<ol>
<li><strong><code>android:gravity</code></strong>: <strong>뷰 자신 내부의 콘텐츠</strong>(예: 텍스트, 아이콘)를 정렬합니다.
<ul>
<li><em>“내 안에 있는 글자를 어디에 둘까?”</em></li>
</ul>
</li>
<li><strong><code>android:layout_gravity</code></strong>: <strong>부모 레이아웃 안에서 뷰 자체</strong>를 정렬합니다.
<ul>
<li><em>“부모 공간 안에서 나를 어디에 둘까?”</em></li>
</ul>
</li>
</ol>
<blockquote>
<p>🔑 LinearLayout에서는 <code>layout_gravity</code>가 레이아웃의 <strong>주축(orientation)과 수직인 방향으로만 작동</strong>합니다. 주축 방향으로는 정렬할 수 없습니다.</p>
</blockquote>
<h5 id="linearlayout-방향-기준">LinearLayout 방향 기준</h5>
<table>
  <thead>
      <tr>
          <th>LinearLayout 방향</th>
          <th><code>layout_gravity</code>가 <strong>유효한 축</strong></th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>vertical</code> (세로)</td>
          <td><strong>수평 축</strong> (<code>left</code>, <code>center_horizontal</code>, <code>right</code>)</td>
          <td>✅ 자식 뷰를 좌/우/가운데로 정렬 가능</td>
      </tr>
      <tr>
          <td><code>vertical</code> (세로)</td>
          <td><strong>수직 축</strong> (<code>top</code>, <code>bottom</code> 등)</td>
          <td>❌ <strong>무시됨</strong> (이미 위에서 아래로 쌓고 있음)</td>
      </tr>
      <tr>
          <td><code>horizontal</code> (가로)</td>
          <td><strong>수직 축</strong> (<code>top</code>, <code>center_vertical</code>, <code>bottom</code>)</td>
          <td>✅ 자식 뷰를 상/하/가운데로 정렬 가능</td>
      </tr>
      <tr>
          <td><code>horizontal</code> (가로)</td>
          <td><strong>수평 축</strong> (<code>left</code>, <code>right</code> 등)</td>
          <td>❌ <strong>무시됨</strong> (이미 왼쪽에서 오른쪽으로 쌓고 있음)</td>
      </tr>
  </tbody>
</table>
<h5 id="layout_weight-예시">layout_weight 예시</h5>
<h6 id="경우-1-부모가-match_parent--layout_weight">경우 1: 부모가 <code>match_parent</code> → <strong><code>layout_weight</code> 작동</strong></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span> <span style="color:#960050;background-color:#1e0010">&lt;!--</span> <span style="color:#960050;background-color:#1e0010">전체</span> <span style="color:#960050;background-color:#1e0010">화면</span> <span style="color:#960050;background-color:#1e0010">--</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    android:orientation=&#34;vertical&#34;&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">/&gt;</span> <span style="color:#75715e">&lt;!-- 남은 공간 전부 차지 --&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><p>→ 화면 전체 중 <strong>남은 공간 = 전체 높이</strong> → <code>weight</code>가 잘 작동.</p>
<h6 id="경우-2-부모가-wrap_content--layout_weight">경우 2: 부모가 <code>wrap_content</code> → <strong><code>layout_weight</code> 무시됨</strong></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span> <span style="color:#960050;background-color:#1e0010">&lt;!--</span> <span style="color:#960050;background-color:#1e0010">콘텐츠</span> <span style="color:#960050;background-color:#1e0010">크기만</span> <span style="color:#960050;background-color:#1e0010">--</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    android:orientation=&#34;vertical&#34;&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><p>→ 부모는 &ldquo;자식 크기만큼만&rdquo; 높이를 갖습니다.<br>
→ 자식은 <code>0dp</code>이므로 <strong>처음에 높이 = 0</strong> → <strong>남은 공간 = 0</strong> → <code>weight</code>가 <strong>0을 나누는 꼴</strong> → <strong>버튼이 보이지 않음</strong>.</p>
<h6 id="예시-3-혼합된-height-설정--weight-세로-linearlayout">예시 3: <strong>혼합된 height 설정 + weight (세로 LinearLayout)</strong></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;vertical&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 고정 높이 헤더 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;60dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;헤더&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#FFCDD2&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- wrap_content인 콘텐츠 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;이건 짧은 설명입니다.&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#BBDEFB&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- weight로 남은 공간 차지 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;남은 공간 전체 (weight=1)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#C8E6C9&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 또 다른 weight 뷰 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;남은 공간의 2/3 (weight=2)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#FFCC80&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>부모: <code>height=&quot;match_parent&quot;</code> → <strong>전체 화면</strong></li>
<li>먼저 <code>60dp</code> 헤더 + <code>wrap_content</code> 텍스트 뷰가 공간을 차지</li>
<li><strong>남은 공간</strong> = 전체 높이 − (60dp + 텍스트 높이)</li>
<li>이 남은 공간을 <strong>weight 비율 1:2</strong>로 나눔:
<ul>
<li>첫 번째 버튼: <strong>1/3</strong></li>
<li>두 번째 버튼: <strong>2/3</strong></li>
</ul>
</li>
</ul>
<p>✅ <strong><code>layout_weight</code>가 잘 작동</strong> — 부모가 <code>match_parent</code>이기 때문.</p>
<hr>
<h6 id="예시-4-부모가">예시 4: <strong>부모가 <code>wrap_content</code>인 중첩 LinearLayout → weight 무시됨</strong></h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;vertical&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:padding=</span><span style="color:#e6db74">&#34;16dp&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- ⚠️ 이 LinearLayout은 wrap_content! --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;vertical&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#E0E0E0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;버튼 A (weight=1)&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;버튼 B (weight=1)&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;이 텍스트는 항상 보임&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#FFF9C4&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 아래는 정상적으로 작동하는 예 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_marginTop=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;이 버튼은 전체 화면의 남은 공간 차지&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#C8E6C9&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>
<p><strong>중첩된 내부 LinearLayout</strong>:</p>
<ul>
<li><code>height=&quot;wrap_content&quot;</code> → <strong>자식 크기만 계산</strong></li>
<li>자식 버튼들은 <code>height=&quot;0dp&quot;</code> → <strong>초기 높이 = 0</strong></li>
<li><code>TextView</code>만 <code>wrap_content</code> → <strong>실제 높이 있음</strong></li>
<li><strong>남은 공간 = 0</strong> → <strong>두 weight 버튼은 높이 0 → 화면에 보이지 않음!</strong></li>
<li>오직 <code>TextView</code>만 회색 배경 영역에 표시됨.</li>
</ul>
</li>
<li>
<p><strong>외부 LinearLayout의 마지막 버튼</strong>:</p>
<ul>
<li>부모는 <code>match_parent</code> → <strong>남은 공간 있음</strong></li>
<li><code>layout_weight=&quot;1&quot;</code> → <strong>화면 하단에 정상 표시</strong></li>
</ul>
</li>
</ul>
<p>✅ 이 예시는 <strong>중첩 레이아웃에서 부모 크기 설정이 weight 동작을 완전히 바꾼다</strong>는 점을 보여줍니다.</p>
<h6 id="-핵심-교훈">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>상황</th>
          <th><code>layout_weight</code> 동작</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>부모가 <code>match_parent</code> 또는 고정 높이</td>
          <td>✅ <strong>정상 작동</strong> — 남은 공간 분배</td>
      </tr>
      <tr>
          <td>부모가 <code>wrap_content</code></td>
          <td>❌ <strong>거의 항상 무시</strong> — 남은 공간 없음</td>
      </tr>
      <tr>
          <td><code>wrap_content</code> + <code>layout_weight</code> 혼합</td>
          <td>⚠️ <strong>비추천</strong> — 성능 저하 + 예측 불가</td>
      </tr>
      <tr>
          <td>중첩 레이아웃</td>
          <td>🔍 <strong>각 레이어별로 부모 크기 확인 필수</strong></td>
      </tr>
  </tbody>
</table>
<h5 id="gravity-속성-예시">Gravity 속성 예시</h5>
<h5 id="gravity와-layout_gravity의-핵심-차이"><code>gravity</code>와 <code>layout_gravity</code>의 핵심 차이</h5>
<ul>
<li>
<p><strong><code>android:gravity</code></strong>: <strong>뷰 내부 콘텐츠</strong>의 정렬 방식을 지정합니다.<br>
→ <em>“내 안에 있는 텍스트나 자식 요소를 어디에 놓을까?”</em></p>
</li>
<li>
<p><strong><code>android:layout_gravity</code></strong>: <strong>부모 레이아웃 내에서 해당 뷰 자체</strong>의 위치를 지정합니다.<br>
→ <em>“부모 안에서 나를 어디에 놓을까?”</em></p>
</li>
</ul>
<blockquote>
<p>🔑 두 속성은 <strong>완전히 다른 대상</strong>에 작용하므로 혼동하지 말 것.</p>
</blockquote>
<hr>
<h6 id="linearlayout-기준-동작-원리">LinearLayout 기준 동작 원리</h6>
<p>LinearLayout은 자식 뷰를 <strong>한 방향</strong>(수평 또는 수직)으로만 배치하므로,<br>
<code>layout_gravity</code>는 <strong>그 반대 방향</strong>에서만 효과를 발휘합니다.</p>
<table>
  <thead>
      <tr>
          <th>LinearLayout 방향</th>
          <th><code>layout_gravity</code>가 <strong>유효한 축</strong></th>
          <th>예시</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>horizontal</code></td>
          <td><strong>수직 축</strong> (<code>top</code>, <code>center_vertical</code>, <code>bottom</code>)</td>
          <td>버튼을 위/가운데/아래로 정렬</td>
      </tr>
      <tr>
          <td><code>vertical</code></td>
          <td><strong>수평 축</strong> (<code>left</code>, <code>center_horizontal</code>, <code>right</code>)</td>
          <td>버튼을 왼쪽/가운데/오른쪽으로 정렬</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>⚠️ 같은 축(예: <code>vertical</code>에서 <code>layout_gravity=&quot;top&quot;</code>)은 무시됩니다.<br>
→ LinearLayout은 수직 방향으로 자식을 쌓기 때문에, <strong>수직 위치는 이미 결정됨</strong>.</p>
</blockquote>
<hr>
<h6 id="예시-1-수직-linearlayout에서-layout_gravity-사용">예시 1: 수직 LinearLayout에서 <code>layout_gravity</code> 사용</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;vertical&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#E0E0E0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;center_horizontal&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;가운데 정렬&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;right&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;오른쪽 정렬&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:gravity=</span><span style="color:#e6db74">&#34;center&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;이 텍스트는 뷰 안에서 가운데&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#BBDEFB&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>수직 방향 → <code>layout_gravity</code>는 <strong>수평 정렬만 제어</strong>.</li>
<li>첫 번째 버튼: 부모 내에서 <strong>가로 중앙</strong>.</li>
<li>두 번째 버튼: 부모 내에서 <strong>오른쪽</strong>.</li>
<li>TextView: <code>gravity=&quot;center&quot;</code> → <strong>자신의 내부 텍스트를 가로·세로 중앙 정렬</strong> (단, 높이가 <code>wrap_content</code>라 세로 중앙은 시각적으로 미약).</li>
</ul>
<p>✅ <code>layout_gravity</code>는 <strong>부모 기준</strong>, <code>gravity</code>는 <strong>자기 내부 기준</strong>.</p>
<hr>
<h6 id="예시-2-수평-linearlayout에서-layout_gravity-사용">예시 2: 수평 LinearLayout에서 <code>layout_gravity</code> 사용</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;200dp&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;horizontal&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#E0E0E0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;top&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;위&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;center_vertical&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;세로 중앙&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;bottom&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;아래&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>수평 방향 → <code>layout_gravity</code>는 <strong>수직 정렬만 제어</strong>.</li>
<li>각 버튼이 부모 높이(<code>200dp</code>) 내에서 <strong>상단, 중앙, 하단</strong>에 위치.</li>
</ul>
<blockquote>
<p>💡 부모 높이가 <code>wrap_content</code>라면 모든 버튼이 붙어 있어 <code>layout_gravity</code> 효과가 <strong>시각적으로 보이지 않음</strong>.<br>
→ <strong>부모에 충분한 여유 공간이 있어야 <code>layout_gravity</code>가 드러남</strong>.</p>
</blockquote>
<hr>
<h6 id="예시-3-gravity-vs-layout_gravity-혼합">예시 3: <code>gravity</code> vs <code>layout_gravity</code> 혼합</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;300dp&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;150dp&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;vertical&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#FFEBEE&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;0dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_weight=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:gravity=</span><span style="color:#e6db74">&#34;center&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;center_horizontal&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;gravity=center\n(layout_gravity는 무시됨)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#B2DFDB&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><code>TextView</code>는 수직 LinearLayout의 자식 → <code>layout_gravity=&quot;center_horizontal&quot;</code>는 <strong>유효</strong>.
<ul>
<li>하지만 <code>layout_width=&quot;match_parent&quot;</code>이므로 <strong>가로로 이미 꽉 찬 상태</strong> → <code>layout_gravity</code> 효과 없음.</li>
</ul>
</li>
<li><code>gravity=&quot;center&quot;</code> → <strong>내부 텍스트가 가로·세로 중앙 정렬</strong>.</li>
</ul>
<p>✅ <strong><code>layout_width=&quot;match_parent&quot;</code>일 때는 <code>layout_gravity</code>가 무의미</strong>할 수 있음.<br>
→ 정렬을 원하면 <code>wrap_content</code> + <code>layout_gravity</code> 조합 사용.</p>
<hr>
<h6 id="-핵심-교훈-1">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>대상</th>
          <th>주의 사항</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:gravity</code></td>
          <td><strong>뷰 내부 콘텐츠</strong> (텍스트, 아이콘 등)</td>
          <td>뷰 크기가 콘텐츠보다 커야 효과 시각화</td>
      </tr>
      <tr>
          <td><code>android:layout_gravity</code></td>
          <td><strong>부모 내에서의 뷰 위치</strong></td>
          <td>LinearLayout 방향의 <strong>반대 축</strong>에서만 작동</td>
      </tr>
      <tr>
          <td>조합 사용 시</td>
          <td>두 속성은 독립적</td>
          <td><code>match_parent</code>와 <code>layout_gravity</code>는 충돌 가능</td>
      </tr>
      <tr>
          <td>부모 크기</td>
          <td><code>wrap_content</code>면 정렬 효과 미약</td>
          <td><strong>여유 공간 확보 필수</strong></td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>✅ <strong>명심</strong>:</p>
<ul>
<li><code>gravity</code> → “내 속 내용 정렬”</li>
<li><code>layout_gravity</code> → “나를 부모 안에서 정렬”</li>
<li>LinearLayout에서는 <strong>정렬 가능한 축이 제한됨</strong>.
네, 요청하신 형식과 스타일에 맞춰 <code>RelativeLayout</code>에 대한 설명을 작성해 드리겠습니다.</li>
</ul>
</blockquote>
<hr>
<h4 id="relativelayout">RelativeLayout</h4>
<p>상대 레이아웃</p>
<p><strong>핵심 원리: 모든 뷰는 ID를 통해 서로, 또는 부모와의 &lsquo;관계&rsquo;를 통해 위치가 결정된다.</strong></p>
<p>RelativeLayout은 자식 뷰들을 직선으로 쌓는 LinearLayout과 달리, 다른 뷰(Sibling)나 부모 레이아웃(Parent)을 기준으로 상대적인 위치를 지정하는 매우 유연한 레이아웃입니다. &ldquo;A의 아래에 B를 놓아라&rdquo;, &ldquo;C를 부모의 오른쪽에 붙여라&rdquo; 와 같은 규칙들의 조합으로 화면을 구성합니다.</p>
<blockquote>
<p>🔑 <strong>ID 지정이 필수적</strong>입니다. 관계를 설정하려면 기준이 될 뷰에 <code>android:id</code>가 반드시 있어야 합니다.</p>
</blockquote>
<hr>
<h5 id="relativelayout의-주요-배치-규칙">RelativeLayout의 주요 배치 규칙</h5>
<p>RelativeLayout의 속성은 크게 3가지 그룹으로 나눌 수 있습니다.</p>
<ol>
<li><strong>다른 뷰(Sibling)를 기준으로 위치 지정</strong>
<ul>
<li><em>“버튼 B를 버튼 A의 오른쪽에 두겠다”</em></li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:layout_above=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 ID를 가진 뷰의 <strong>위쪽</strong>에 배치합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_below=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 ID를 가진 뷰의 <strong>아래쪽</strong>에 배치합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_toLeftOf=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 ID를 가진 뷰의 <strong>왼쪽</strong>에 배치합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_toRightOf=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 ID를 가진 뷰의 <strong>오른쪽</strong>에 배치합니다.</td>
      </tr>
  </tbody>
</table>
<ol start="2">
<li><strong>다른 뷰(Sibling)를 기준으로 정렬</strong>
<ul>
<li><em>“버튼 B의 상단 라인을 이미지 A의 상단 라인에 맞추겠다”</em></li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:layout_alignTop=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 뷰와 <strong>위쪽</strong> 가장자리를 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignBottom=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 뷰와 <strong>아래쪽</strong> 가장자리를 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignLeft=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 뷰와 <strong>왼쪽</strong> 가장자리를 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignRight=&quot;@+id/기준뷰&quot;</code></td>
          <td>지정한 뷰와 <strong>오른쪽</strong> 가장자리를 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignBaseline=&quot;@+id/기준뷰&quot;</code></td>
          <td>텍스트 뷰의 경우, **텍스트 기준선(Baseline)**을 맞춥니다.</td>
      </tr>
  </tbody>
</table>
<ol start="3">
<li><strong>부모(Parent) 레이아웃을 기준으로 정렬</strong>
<ul>
<li><em>“이 버튼을 화면 정중앙에 놓겠다”</em></li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:layout_alignParentTop=&quot;true&quot;</code></td>
          <td>부모의 <strong>위쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignParentBottom=&quot;true&quot;</code></td>
          <td>부모의 <strong>아래쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignParentLeft=&quot;true&quot;</code></td>
          <td>부모의 <strong>왼쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_alignParentRight=&quot;true&quot;</code></td>
          <td>부모의 <strong>오른쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_centerHorizontal=&quot;true&quot;</code></td>
          <td>부모의 <strong>수평 중앙</strong>에 배치합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_centerVertical=&quot;true&quot;</code></td>
          <td>부모의 <strong>수직 중앙</strong>에 배치합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_centerInParent=&quot;true&quot;</code></td>
          <td>부모의 <strong>수평 및 수직 중앙</strong>에 배치합니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="relativelayout-예시">RelativeLayout 예시</h5>
<h6 id="예시-1-기본적인-상대-위치-지정">예시 1: 기본적인 상대 위치 지정</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;RelativeLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 기준점이 될 버튼 A --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/buttonA&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;버튼 A (기준)&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 버튼 A의 아래, 오른쪽에 위치 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/buttonB&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_below=</span><span style="color:#e6db74">&#34;@id/buttonA&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_toRightOf=</span><span style="color:#e6db74">&#34;@id/buttonA&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;버튼 B&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/RelativeLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><strong><code>buttonA</code></strong>: 아무런 규칙이 없으므로 부모의 좌측 상단(0,0)에 위치합니다.</li>
<li><strong><code>buttonB</code></strong>: <code>buttonA</code>의 아래(<code>layout_below</code>)이면서 동시에 오른쪽(<code>layout_toRightOf</code>)에 위치하게 됩니다.</li>
</ul>
<hr>
<h6 id="예시-2-부모-기준-정렬-화면-우측-하단에-버튼-배치">예시 2: 부모 기준 정렬 (화면 우측 하단에 버튼 배치)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;RelativeLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;화면 콘텐츠&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:textSize=</span><span style="color:#e6db74">&#34;24sp&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 부모의 오른쪽, 아래쪽에 붙이기 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_alignParentRight=</span><span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_alignParentBottom=</span><span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_margin=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;플로팅 버튼&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/RelativeLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>Floating Action Button과 유사한 UI를 만들 때 유용합니다.</li>
<li><code>layout_alignParentRight=&quot;true&quot;</code> 와 <code>layout_alignParentBottom=&quot;true&quot;</code> 두 규칙을 통해 <strong>부모의 우측 하단 코너</strong>에 뷰를 고정시킵니다.</li>
</ul>
<hr>
<h6 id="예시-3-복합적인-실제-레이아웃-프로필-ui">예시 3: 복합적인 실제 레이아웃 (프로필 UI)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;RelativeLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:padding=</span><span style="color:#e6db74">&#34;16dp&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 1. 프로필 이미지 (기준점 1) --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;ImageView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/profile_image&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;60dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;60dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_alignParentLeft=</span><span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_centerVertical=</span><span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:src=</span><span style="color:#e6db74">&#34;@mipmap/ic_launcher&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 2. 시간 텍스트 (기준점 2) --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/timestamp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_alignParentRight=</span><span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;2시간 전&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 3. 사용자 이름 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/user_name&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_toRightOf=</span><span style="color:#e6db74">&#34;@id/profile_image&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_toLeftOf=</span><span style="color:#e6db74">&#34;@id/timestamp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_marginLeft=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;Android User&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:textSize=</span><span style="color:#e6db74">&#34;18sp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:textStyle=</span><span style="color:#e6db74">&#34;bold&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 4. 설명 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/description&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_below=</span><span style="color:#e6db74">&#34;@id/user_name&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_alignLeft=</span><span style="color:#e6db74">&#34;@id/user_name&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_marginTop=</span><span style="color:#e6db74">&#34;4dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;RelativeLayout은 유연합니다.&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/RelativeLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><strong><code>profile_image</code></strong>: 부모의 <strong>왼쪽</strong>에 붙고 <strong>수직 중앙</strong> 정렬.</li>
<li><strong><code>timestamp</code></strong>: 부모의 <strong>오른쪽</strong>에 붙음.</li>
<li><strong><code>user_name</code></strong>: <code>profile_image</code>의 <strong>오른쪽</strong>이면서 <code>timestamp</code>의 <strong>왼쪽</strong>에 위치하여, 두 뷰 사이에 공간을 채웁니다.</li>
<li><strong><code>description</code></strong>: <code>user_name</code>의 <strong>아래</strong>에 위치하며, 왼쪽 라인을 <code>user_name</code>과 <strong>동일하게 맞춥니다</strong>(<code>layout_alignLeft</code>).</li>
</ul>
<p>✅ 이처럼 여러 뷰의 관계를 사슬처럼 엮어 복잡한 UI를 효과적으로 만들 수 있습니다.</p>
<hr>
<h6 id="-relativelayout의-주의사항">⚠️ <code>RelativeLayout</code>의 주의사항</h6>
<ol>
<li>
<p><strong>순환 종속성 (Circular Dependency)</strong></p>
<ul>
<li>A 뷰가 B 뷰의 오른쪽에(<code>toRightOf=&quot;B&quot;</code>) 있고, B 뷰가 A 뷰의 오른쪽에(<code>toRightOf=&quot;A&quot;</code>) 있도록 서로를 참조하면 앱이 비정상 종료될 수 있습니다. 뷰의 관계는 한 방향으로만 흐르도록 설계해야 합니다.</li>
</ul>
</li>
<li>
<p><strong>성능 문제</strong></p>
<ul>
<li>뷰의 위치를 결정하기 위해 레이아웃 계산을 두 번(Two measurement passes) 수행하는 경우가 많아, 뷰가 매우 많은 복잡한 구조에서는 성능 저하를 유발할 수 있습니다.</li>
<li>중첩된 <code>RelativeLayout</code>은 성능에 더욱 좋지 않습니다.</li>
</ul>
</li>
<li>
<p><strong>기준점 부재</strong></p>
<ul>
<li>뷰에 아무런 위치 규칙을 주지 않으면, 기본값으로 <strong>부모의 좌측 상단 (0, 0)에 겹쳐서</strong> 표시됩니다. 의도치 않게 뷰들이 겹쳐 보인다면 위치 규칙이 누락되었는지 확인해야 합니다.</li>
</ul>
</li>
</ol>
<h6 id="-핵심-교훈-2">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>핵심 개념</strong></td>
          <td><strong>ID를 통한 관계 설정.</strong> 뷰들이 서로 또는 부모를 기준으로 위치를 잡습니다.</td>
      </tr>
      <tr>
          <td><strong>장점</strong></td>
          <td>중첩을 줄이면서 복잡하고 유연한 UI를 만들 수 있습니다.</td>
      </tr>
      <tr>
          <td><strong>단점</strong></td>
          <td>뷰가 많아지면 관계가 복잡해지고, XML 가독성이 떨어지며 성능 저하가 발생할 수 있습니다.</td>
      </tr>
      <tr>
          <td><strong>주의사항</strong></td>
          <td>순환 종속성 오류를 피하고, 기준점 ID를 명확히 해야 합니다.</td>
      </tr>
      <tr>
          <td><strong>현대적 대안</strong></td>
          <td><strong><code>ConstraintLayout</code></strong>. <code>RelativeLayout</code>의 모든 기능과 그 이상을 제공하면서 성능이 더 뛰어나고, 강력한 편집기(Layout Editor)를 지원합니다. <strong>새로운 레이아웃을 작성할 때는 <code>ConstraintLayout</code> 사용이 적극 권장됩니다.</strong></td>
      </tr>
  </tbody>
</table>
<h4 id="framelayout">FrameLayout</h4>
<p>프레임 레이아웃</p>
<p><strong>핵심 원리: 뷰를 겹겹이 쌓는 가장 단순한 레이아웃</strong></p>
<p>마치 투명한 종이를 포개듯, 나중에 추가된 뷰가 가장 위에 올라오는 구조입니다. 자식 뷰들은 기본적으로 부모의 좌측 상단에 쌓이기 시작합니다.</p>
<blockquote>
<p>🔑 위치를 제어하려면 <code>layout_gravity</code>를, 화면에 보이거나 숨기려면 <code>visibility</code> 속성을 함께 사용합니다.</p>
</blockquote>
<hr>
<h5 id="framelayout의-주요-속성">FrameLayout의 주요 속성</h5>
<p>LinearLayout이나 RelativeLayout처럼 복잡한 위치 지정 규칙은 없습니다. 대신 다음 두 속성이 핵심적인 역할을 합니다.</p>
<ol>
<li>
<p><strong><code>android:layout_gravity</code></strong>: <strong>부모 FrameLayout 안에서 자식 뷰를 정렬</strong>합니다.</p>
<ul>
<li><em>“나를 부모 프레임 안에서 어디에 둘까?”</em></li>
<li><code>center</code>, <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> 값을 조합하여 사용합니다. (예: <code>top|right</code>)</li>
</ul>
</li>
<li>
<p><strong><code>android:visibility</code></strong>: <strong>뷰를 화면에 보여줄지 여부를 결정</strong>합니다.</p>
<ul>
<li><code>visible</code>: 뷰를 화면에 보여줍니다. (기본값)</li>
<li><code>invisible</code>: 뷰를 화면에서 숨기지만, <strong>차지하던 공간은 그대로 유지</strong>됩니다.</li>
<li><code>gone</code>: 뷰를 화면에서 숨기고, <strong>차지하던 공간도 함께 사라집니다</strong>.</li>
</ul>
</li>
</ol>
<hr>
<h5 id="framelayout-예시">FrameLayout 예시</h5>
<h6 id="예시-1-기본적인-뷰-겹치기와-정렬">예시 1: 기본적인 뷰 겹치기와 정렬</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;FrameLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;200dp&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#E0E0E0&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 배경이 될 이미지 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;ImageView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:scaleType=</span><span style="color:#e6db74">&#34;centerCrop&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:src=</span><span style="color:#e6db74">&#34;@drawable/background_image&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 이미지 위에 겹쳐질 텍스트 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;bottom|right&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_margin=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;Sample Text&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:textColor=</span><span style="color:#e6db74">&#34;@android:color/white&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;#80000000&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:padding=</span><span style="color:#e6db74">&#34;8dp&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/FrameLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><code>ImageView</code>가 먼저 추가되어 배경처럼 맨 아래에 깔립니다.</li>
<li>그 위에 <code>TextView</code>가 겹쳐집니다.</li>
<li><code>TextView</code>는 <code>layout_gravity=&quot;bottom|right&quot;</code> 속성으로 인해 프레임의 <strong>우측 하단</strong>에 위치하게 됩니다.</li>
</ul>
<hr>
<h6 id="예시-2-visibility를-이용한-뷰-전환-로딩-화면">예시 2: <code>visibility</code>를 이용한 뷰 전환 (로딩 화면)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;FrameLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 로딩이 끝나면 보여줄 콘텐츠 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;ImageView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_image&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:src=</span><span style="color:#e6db74">&#34;@drawable/my_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:visibility=</span><span style="color:#e6db74">&#34;invisible&#34;</span> <span style="color:#f92672">/&gt;</span> <span style="color:#75715e">&lt;!-- 처음엔 숨김 --&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 로딩 중에 보여줄 프로그레스 바 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;ProgressBar</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/loading_indicator&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;center&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:visibility=</span><span style="color:#e6db74">&#34;visible&#34;</span> <span style="color:#f92672">/&gt;</span> <span style="color:#75715e">&lt;!-- 처음엔 보임 --&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/FrameLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>처음 화면에서는 <code>ProgressBar</code>만 중앙에 보입니다.</li>
<li>코드(Activity/Fragment)에서 데이터 로딩이 완료되면 <code>visibility</code> 속성을 동적으로 변경합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// 로딩 완료 후
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>binding.loadingIndicator.visibility = <span style="color:#a6e22e">View</span>.GONE     <span style="color:#75715e">// 프로그레스 바 숨기기 (공간도 제거)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>binding.contentImage.visibility = <span style="color:#a6e22e">View</span>.VISIBLE    <span style="color:#75715e">// 이미지 보여주기
</span></span></span></code></pre></div><p>✅ <code>FrameLayout</code>은 이렇게 <strong>같은 공간에서 서로 다른 뷰를 번갈아 보여줘야 할 때</strong> 매우 유용합니다.</p>
<hr>
<h5 id="-핵심-교훈-3">💡 핵심 교훈</h5>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>핵심 기능</strong></td>
          <td><strong>뷰 겹치기 (Stacking)</strong>. 나중에 선언된 뷰가 위에 온다.</td>
      </tr>
      <tr>
          <td><strong>위치 지정</strong></td>
          <td><code>android:layout_gravity</code>를 사용하여 부모 내에서 정렬한다.</td>
      </tr>
      <tr>
          <td><strong>동적 제어</strong></td>
          <td><code>android:visibility</code> 속성 (<code>visible</code>, <code>invisible</code>, <code>gone</code>)을 이용해 뷰를 제어하는 것이 핵심 용도.</td>
      </tr>
      <tr>
          <td><strong>주요 용도</strong></td>
          <td>- <strong>화면 전환</strong>: 탭(Tab) 화면처럼 한 번에 하나의 화면만 보여줄 때.<br>- <strong>UI 오버레이</strong>: 비디오 위의 재생 버튼, 이미지 위의 프로그레스 바 등.</td>
      </tr>
      <tr>
          <td><strong>단순함</strong></td>
          <td>단 하나의 자식 뷰를 담는 가장 간단한 컨테이너로도 사용된다. (예: <code>Fragment</code>를 담는 컨테이너)</td>
      </tr>
  </tbody>
</table>
<h4 id="gridlayout">GridLayout</h4>
<p>표 (격자) 레이아웃</p>
<p><strong>핵심 원리: 뷰를 보이지 않는 표(spreadsheet)의 셀에 순서대로 배치한다.</strong></p>
<p>GridLayout은 자식 뷰들을 행(row)과 열(column)으로 구성된 격자무늬에 배치하는 레이아웃입니다. LinearLayout처럼 한 방향으로 뷰를 추가하지만, 지정된 행/열의 개수를 채우면 자동으로 다음 줄로 넘어가는 특징이 있습니다.</p>
<blockquote>
<p>🔑 <code>orientation</code>으로 주된 흐름 방향을 정하고, <code>columnCount</code> 또는 <code>rowCount</code>로 한 줄에 몇 개의 뷰를 넣을지 결정합니다.</p>
</blockquote>
<hr>
<h5 id="gridlayout의-기본-배치-규칙">GridLayout의 기본 배치 규칙</h5>
<p>GridLayout 자체에 설정하는 속성들입니다.</p>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:orientation</code></td>
          <td>뷰를 배치할 주된 방향을 결정합니다.<br>- <code>horizontal</code> (기본값): 왼쪽 → 오른쪽으로 채우고, 꽉 차면 아래로 줄바꿈.<br>- <code>vertical</code>: 위 → 아래로 채우고, 꽉 차면 오른쪽으로 줄바꿈.</td>
      </tr>
      <tr>
          <td><code>android:columnCount</code></td>
          <td><strong>가로 방향으로 배치할 열의 개수</strong>를 지정합니다. <code>orientation=&quot;horizontal&quot;</code>일 때 핵심 속성입니다.</td>
      </tr>
      <tr>
          <td><code>android:rowCount</code></td>
          <td><strong>세로 방향으로 배치할 행의 개수</strong>를 지정합니다. <code>orientation=&quot;vertical&quot;</code>일 때 핵심 속성입니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="자식-뷰의-핵심-속성">자식 뷰의 핵심 속성</h5>
<p>각각의 자식 뷰에 설정하여 위치, 크기, 병합을 제어합니다.</p>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>android:layout_row</code></td>
          <td>뷰가 위치할 <strong>행의 인덱스</strong>(0부터 시작)를 직접 지정합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_column</code></td>
          <td>뷰가 위치할 <strong>열의 인덱스</strong>(0부터 시작)를 직접 지정합니다.</td>
      </tr>
      <tr>
          <td><code>android:layout_rowSpan</code></td>
          <td>현재 뷰가 <strong>세로로 몇 개의 셀을 병합(차지)할지</strong> 지정합니다. (기본값: 1)</td>
      </tr>
      <tr>
          <td><code>android:layout_columnSpan</code></td>
          <td>현재 뷰가 <strong>가로로 몇 개의 셀을 병합(차지)할지</strong> 지정합니다. (기본값: 1)</td>
      </tr>
      <tr>
          <td><code>android:layout_gravity</code></td>
          <td><strong>셀 안에서 뷰를 정렬</strong>하거나, <strong>뷰를 늘려 셀을 채우도록</strong> 합니다.<br>- <code>center</code>, <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>: 셀 내부 정렬<br>- <code>fill</code>, <code>fill_horizontal</code>, <code>fill_vertical</code>: 뷰를 확장하여 셀 공간 채우기</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="gridlayout-예시">GridLayout 예시</h5>
<h6 id="예시-1-기본적인-그리드-배치-계산기-키패드">예시 1: 기본적인 그리드 배치 (계산기 키패드)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;GridLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:columnCount=</span><span style="color:#e6db74">&#34;3&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:orientation=</span><span style="color:#e6db74">&#34;horizontal&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;6&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/GridLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><code>columnCount=&quot;3&quot;</code>이므로 버튼이 가로로 3개씩 배치됩니다.</li>
<li>4번째 버튼(<code>text=&quot;4&quot;</code>)은 자동으로 다음 줄의 첫 번째 칸으로 넘어갑니다.</li>
</ul>
<hr>
<h6 id="예시-2-셀-병합columnspan과-채우기gravityfill">예시 2: 셀 병합(<code>columnSpan</code>)과 채우기(<code>gravity=&quot;fill&quot;</code>)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;GridLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:columnCount=</span><span style="color:#e6db74">&#34;4&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 이 뷰는 가로 4칸을 모두 차지 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_columnSpan=</span><span style="color:#e6db74">&#34;4&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;fill_horizontal&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:textSize=</span><span style="color:#e6db74">&#34;48sp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:gravity=</span><span style="color:#e6db74">&#34;right&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;8&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;9&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 이 뷰는 세로 2칸을 차지 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_rowSpan=</span><span style="color:#e6db74">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_gravity=</span><span style="color:#e6db74">&#34;fill_vertical&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/GridLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><strong>TextView</strong>: <code>layout_columnSpan=&quot;4&quot;</code>로 <strong>4개의 열을 병합</strong>하여 한 줄을 모두 차지합니다. <code>layout_gravity=&quot;fill_horizontal&quot;</code>로 너비를 꽉 채웁니다.</li>
<li><strong>&rsquo;=&rsquo; 버튼</strong>: <code>layout_rowSpan=&quot;2&quot;</code>로 <strong>2개의 행을 병합</strong>하여 세로로 긴 버튼이 됩니다. <code>layout_gravity=&quot;fill_vertical&quot;</code>로 높이를 꽉 채웁니다.</li>
</ul>
<p>✅ <code>Span</code> 속성은 셀을 병합할 뿐, 뷰의 크기를 늘리지는 않습니다. <strong>뷰를 실제로 확장하려면 <code>layout_gravity</code>의 <code>fill</code> 계열 값</strong>을 함께 사용해야 합니다.</p>
<hr>
<h6 id="예시-3-특정-위치-지정-row-column">예시 3: 특정 위치 지정 (<code>row</code>, <code>column</code>)</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;GridLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:columnCount=</span><span style="color:#e6db74">&#34;3&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:rowCount=</span><span style="color:#e6db74">&#34;3&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;A (0,0)&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- (0,1)은 비워둠 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;B (0,2)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_column=</span><span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- C 버튼을 (2,1) 위치에 강제 배치 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span> <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;C (2,1)&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_row=</span><span style="color:#e6db74">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_column=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/GridLayout&gt;</span>
</span></span></code></pre></div><ul>
<li>뷰를 순서대로 배치하지 않고, <code>layout_row</code>와 <code>layout_column</code>을 이용해 원하는 셀에 직접 배치할 수 있습니다.</li>
<li>지정되지 않은 셀은 빈 공간으로 남게 됩니다.</li>
</ul>
<hr>
<h6 id="-gridlayout-사용-시-주의점-및-tablelayout과의-비교">⚠️ GridLayout 사용 시 주의점 및 TableLayout과의 비교</h6>
<ul>
<li><strong><code>TableLayout</code>과의 차이</strong>:
<ul>
<li><code>TableLayout</code>은 <code>&lt;TableRow&gt;</code> 태그로 각 행을 명시적으로 선언해야 해서 구조가 더 경직됩니다.</li>
<li><code>GridLayout</code>은 <code>columnCount</code>나 <code>rowCount</code>만 지정하면 자동으로 줄바꿈을 처리해 훨씬 유연합니다.</li>
</ul>
</li>
<li><strong><code>layout_gravity</code>의 중요성</strong>: 셀 병합(<code>Span</code>)이나 공간 채우기를 할 때 <code>layout_gravity</code> 속성을 올바르게 사용하는 것이 매우 중요합니다.</li>
<li><strong>현대적 대안</strong>: <code>ConstraintLayout</code>은 가이드라인(Guideline)과 체인(Chain) 기능을 통해 <code>GridLayout</code>보다 더 복잡하고 유연한 그리드 시스템을 평평한 구조(flat hierarchy)로 구현할 수 있어, 복잡한 화면에서는 성능상 더 유리할 수 있습니다.</li>
</ul>
<hr>
<h6 id="-핵심-교훈-4">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>핵심 개념</strong></td>
          <td><strong>자동 줄바꿈</strong>이 되는 격자무늬(Grid) 레이아웃.</td>
      </tr>
      <tr>
          <td><strong>주요 속성</strong></td>
          <td><code>orientation</code>, <code>columnCount</code> / <code>rowCount</code>로 전체 구조를 잡는다.</td>
      </tr>
      <tr>
          <td><strong>자식 뷰 제어</strong></td>
          <td><code>layout_span</code>으로 셀을 병합하고, <code>layout_gravity</code>로 셀을 채우거나 정렬한다.</td>
      </tr>
      <tr>
          <td><strong>장점</strong></td>
          <td><code>TableLayout</code>보다 유연하고 적은 코드로 격자 UI를 만들 수 있다.</td>
      </tr>
      <tr>
          <td><strong>주요 용도</strong></td>
          <td>계산기, 갤러리 썸네일, 대시보드 메뉴 등 표 형태의 UI 구성.</td>
      </tr>
  </tbody>
</table>
<h4 id="constraintlayout">ConstraintLayout</h4>
<p>제약 레이아웃</p>
<p><strong>핵심 원리: 모든 뷰는 다른 뷰 또는 부모와의 &lsquo;제약(Constraint)&rsquo; 관계로 위치가 결정된다.</strong></p>
<p>ConstraintLayout은 RelativeLayout의 유연함과 LinearLayout의 비율 배치를 합친 것보다 더 강력한 레이아웃입니다. 뷰의 각 가장자리(상, 하, 좌, 우)에 있는 **앵커 포인트(Anchor Point)**를 다른 뷰의 앵커 포인트나 부모 레이아웃에 &lsquo;연결&rsquo;하여 위치를 정의합니다. 이를 통해 중첩 없이도 매우 복잡하고 반응형인 UI를 만들 수 있습니다.</p>
<blockquote>
<p>🔑 <strong>모든 뷰는 최소 하나 이상의 수평 제약과 수직 제약이 있어야 위치가 확정</strong>됩니다. 제약이 없으면 뷰는 (0,0) 좌표(좌측 상단)에 표시됩니다.</p>
</blockquote>
<hr>
<h5 id="constraintlayout의-주요-제약-규칙">ConstraintLayout의 주요 제약 규칙</h5>
<p>속성들은 <code>누구의(Source)</code> <code>어느 쪽(Anchor)</code>을 <code>누구의(Target)</code> <code>어느 쪽(Anchor)</code>에 연결할지 정의합니다.</p>
<p><strong><code>app:layout_constraint[SourceAnchor]_to[TargetAnchor]Of=&quot;[TargetID]&quot;</code></strong> 형식입니다.</p>
<ol>
<li><strong>상대 위치 지정 (다른 뷰 또는 부모 기준)</strong>
<ul>
<li><em>“이 뷰의 왼쪽(Start)을 저 뷰의 오른쪽(End)에 연결하겠다”</em></li>
<li><em>“이 뷰의 상단(Top)을 부모(parent)의 상단(Top)에 연결하겠다”</em></li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>app:layout_constraintStart_toStartOf</code></td>
          <td><strong>왼쪽</strong> 가장자리를 대상의 <strong>왼쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintStart_toEndOf</code></td>
          <td><strong>왼쪽</strong> 가장자리를 대상의 <strong>오른쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintEnd_toStartOf</code></td>
          <td><strong>오른쪽</strong> 가장자리를 대상의 <strong>왼쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintEnd_toEndOf</code></td>
          <td><strong>오른쪽</strong> 가장자리를 대상의 <strong>오른쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintTop_toTopOf</code></td>
          <td><strong>위쪽</strong> 가장자리를 대상의 <strong>위쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintTop_toBottomOf</code></td>
          <td><strong>위쪽</strong> 가장자리를 대상의 <strong>아래쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintBottom_toTopOf</code></td>
          <td><strong>아래쪽</strong> 가장자리를 대상의 <strong>위쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintBottom_toBottomOf</code></td>
          <td><strong>아래쪽</strong> 가장자리를 대상의 <strong>아래쪽</strong> 가장자리에 맞춥니다.</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>💡 <strong>Start/End vs Left/Right</strong>: <code>Start/End</code>는 RTL(Right-to-Left) 언어 환경을 지원하므로 <code>Left/Right</code>보다 사용이 권장됩니다.</p>
</blockquote>
<ol start="2">
<li><strong>크기 조정 (Dimension Constraints)</strong>
<ul>
<li>뷰의 너비나 높이를 제약 조건에 따라 동적으로 결정합니다.</li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th><code>layout_width</code> / <code>layout_height</code> 값</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>[고정값]</code> (예: <code>50dp</code>)</td>
          <td>뷰의 크기를 고정된 값으로 지정합니다.</td>
      </tr>
      <tr>
          <td><code>wrap_content</code></td>
          <td>뷰 내부의 콘텐츠에 맞게 크기를 조절합니다.</td>
      </tr>
      <tr>
          <td><code>0dp</code> (<strong>match_constraint</strong>)</td>
          <td><strong>가장 중요.</strong> 제약 조건이 허용하는 한 최대한의 공간을 차지하도록 크기를 확장합니다. LinearLayout의 <code>layout_weight</code>와 유사한 역할을 합니다.</td>
      </tr>
  </tbody>
</table>
<ol start="3">
<li><strong>중앙 정렬과 편향 (Bias)</strong>
<ul>
<li>양쪽(수평 또는 수직)으로 제약이 걸렸을 때, 뷰를 해당 공간 내에서 정렬합니다.</li>
</ul>
</li>
</ol>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>app:layout_constraintHorizontal_bias</code></td>
          <td>수평 제약 공간 내에서 뷰의 위치를 조절합니다. (0.0=왼쪽, 0.5=중앙, 1.0=오른쪽)</td>
      </tr>
      <tr>
          <td><code>app:layout_constraintVertical_bias</code></td>
          <td>수직 제약 공간 내에서 뷰의 위치를 조절합니다. (0.0=위쪽, 0.5=중앙, 1.0=아래쪽)</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="constraintlayout-예시">ConstraintLayout 예시</h5>
<h6 id="예시-1-기본적인-제약-관계-설정-프로필-ui">예시 1: 기본적인 제약 관계 설정 (프로필 UI)</h6>
<p>제공된 텍스트의 카카오톡 UI 예시를 XML 코드로 분석한 것입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;androidx.constraintlayout.widget.ConstraintLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:app=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res-auto&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:padding=</span><span style="color:#e6db74">&#34;16dp&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 1. 프로필 이미지: 부모의 왼쪽, 위쪽에 고정 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;ImageView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/imageView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;50dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;50dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintStart_toStartOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:srcCompat=</span><span style="color:#e6db74">&#34;@drawable/ic_launcher_background&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 2. 시간 텍스트: 부모의 오른쪽, 위쪽에 고정 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/dateView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;9월 7일&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintEnd_toEndOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 3. 제목 텍스트: 이미지의 오른쪽, 이미지의 위쪽 라인에 정렬 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/titleView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_marginStart=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;카카오톡&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintStart_toEndOf=</span><span style="color:#e6db74">&#34;@+id/imageView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;@+id/imageView&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 4. 메시지 텍스트: 이미지의 오른쪽, 이미지의 아래쪽 라인에 정렬 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/messageView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_marginStart=</span><span style="color:#e6db74">&#34;16dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;[기기 로그인 알림]&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintBottom_toBottomOf=</span><span style="color:#e6db74">&#34;@+id/imageView&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintStart_toEndOf=</span><span style="color:#e6db74">&#34;@+id/imageView&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><strong><code>imageView</code></strong>: <strong>왼쪽</strong>은 <strong>부모의 왼쪽</strong>에, <strong>위쪽</strong>은 <strong>부모의 위쪽</strong>에 연결.</li>
<li><strong><code>dateView</code></strong>: <strong>오른쪽</strong>은 <strong>부모의 오른쪽</strong>에, <strong>위쪽</strong>은 <strong>부모의 위쪽</strong>에 연결.</li>
<li><strong><code>titleView</code></strong>: <strong>왼쪽</strong>은 <code>imageView</code>의 <strong>오른쪽</strong>에 연결, <strong>위쪽</strong>은 <code>imageView</code>의 <strong>위쪽</strong>과 정렬.</li>
<li><strong><code>messageView</code></strong>: <strong>왼쪽</strong>은 <code>imageView</code>의 <strong>오른쪽</strong>에 연결, <strong>아래쪽</strong>은 <code>imageView</code>의 <strong>아래쪽</strong>과 정렬.</li>
</ul>
<p>✅ 각 뷰가 다른 뷰나 부모와 어떻게 관계를 맺는지 명확하게 보여줍니다.</p>
<hr>
<h6 id="예시-2-0dpmatch_constraint와-bias를-이용한-동적-크기-및-중앙-정렬">예시 2: <code>0dp(match_constraint)</code>와 Bias를 이용한 동적 크기 및 중앙 정렬</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;androidx.constraintlayout.widget.ConstraintLayout</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:app=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res-auto&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 1. 부모의 중앙에 위치시키기 --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Button</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/center_button&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:text=</span><span style="color:#e6db74">&#34;정중앙 버튼&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintStart_toStartOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintEnd_toEndOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintBottom_toBottomOf=</span><span style="color:#e6db74">&#34;parent&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">&lt;!-- 상하좌우를 모두 부모에 연결하면 자동으로 중앙 정렬됨 --&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- 2. 남은 공간을 모두 차지하는 텍스트뷰 (0dp) --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;TextView</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/header_text&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;0dp&#34;</span> <span style="color:#960050;background-color:#1e0010">&lt;!--</span> <span style="color:#960050;background-color:#1e0010">제약에</span> <span style="color:#960050;background-color:#1e0010">따라</span> <span style="color:#960050;background-color:#1e0010">너비가</span> <span style="color:#960050;background-color:#1e0010">결정됨</span> <span style="color:#960050;background-color:#1e0010">--</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        android:layout_height=&#34;wrap_content&#34;
</span></span><span style="display:flex;"><span>        android:layout_marginHorizontal=&#34;16dp&#34;
</span></span><span style="display:flex;"><span>        android:text=&#34;이 텍스트는 양 옆의 공간을 채웁니다&#34;
</span></span><span style="display:flex;"><span>        android:gravity=&#34;center&#34;
</span></span><span style="display:flex;"><span>        app:layout_constraintStart_toStartOf=&#34;parent&#34;
</span></span><span style="display:flex;"><span>        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
</span></span><span style="display:flex;"><span>        app:layout_constraintBottom_toTopOf=&#34;@+id/center_button&#34;
</span></span><span style="display:flex;"><span>        android:layout_marginBottom=&#34;16dp&#34;/&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span>
</span></span></code></pre></div><ul>
<li><strong><code>center_button</code></strong>: 뷰의 <strong>상/하/좌/우 앵커를 모두 부모에 연결</strong>하면, 뷰는 부모의 정중앙에 위치하게 됩니다. <code>bias</code> 값을 조정하여 중앙이 아닌 다른 위치로 옮길 수도 있습니다.</li>
<li><strong><code>header_text</code></strong>: <code>layout_width=&quot;0dp&quot;</code>로 설정하고 왼쪽과 오른쪽을 부모에 연결하여, <strong>부모의 너비에서 마진을 뺀 나머지 공간을 모두 차지</strong>하게 됩니다. 이는 LinearLayout의 <code>weight</code>와 비슷한 효과를 냅니다.</li>
</ul>
<hr>
<h6 id="-constraintlayout의-주의사항">⚠️ <code>ConstraintLayout</code>의 주의사항</h6>
<ol>
<li>
<p><strong>제약 누락 (Missing Constraints)</strong></p>
<ul>
<li>수평 또는 수직 제약 중 하나라도 없으면, 해당 축의 위치가 확정되지 않아 뷰가 레이아웃의 (0,0) 위치로 이동합니다. 레이아웃 편집기는 이런 경우 경고를 표시해 줍니다.</li>
</ul>
</li>
<li>
<p><strong>XML의 복잡성</strong></p>
<ul>
<li>뷰가 많아지고 제약이 복잡해지면 XML 코드가 길고 가독성이 떨어질 수 있습니다. 따라서 안드로이드 스튜디오의 **레이아웃 편집기(Layout Editor)**를 사용하는 것이 거의 필수적입니다.</li>
</ul>
</li>
<li>
<p><strong>성능</strong></p>
<ul>
<li><code>ConstraintLayout</code>은 **평평한 뷰 계층(Flat View Hierarchy)**을 만들도록 설계되었습니다. <code>LinearLayout</code>이나 <code>RelativeLayout</code>을 여러 번 중첩하는 것보다 단일 <code>ConstraintLayout</code>을 사용하는 것이 일반적으로 렌더링 성능에 훨씬 유리합니다.</li>
</ul>
</li>
</ol>
<h6 id="-핵심-교훈-5">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>핵심 개념</strong></td>
          <td>**ID와 앵커 포인트(Anchor Point)**를 연결하는 **&lsquo;제약&rsquo;**으로 뷰의 위치와 크기를 정의합니다.</td>
      </tr>
      <tr>
          <td><strong>장점</strong></td>
          <td>**평평한 계층 구조(Flat Hierarchy)**로 중첩 없이 복잡한 UI 구현이 가능하며, 이는 <strong>성능에 유리</strong>합니다. 매우 유연하고 강력합니다.</td>
      </tr>
      <tr>
          <td><strong>단점</strong></td>
          <td>XML 코드가 길고 복잡해질 수 있어, <strong>레이아웃 편집기 사용이 거의 필수적</strong>입니다.</td>
      </tr>
      <tr>
          <td><strong>주의사항</strong></td>
          <td>모든 뷰는 <strong>수평/수직 제약이 모두 필요</strong>합니다. 제약 누락 시 뷰가 의도치 않은 위치(0,0)로 이동할 수 있습니다.</td>
      </tr>
      <tr>
          <td><strong>현대적 위치</strong></td>
          <td><strong>현재 안드로이드 UI 개발의 표준 레이아웃</strong>입니다. 새로운 화면을 구성할 때 가장 먼저 고려해야 하며, <code>RelativeLayout</code>을 완벽히 대체합니다.</td>
      </tr>
  </tbody>
</table>
<h3 id="사용자-이벤트-처리">사용자 이벤트 처리</h3>
<ul>
<li>터치 이벤트
<ul>
<li>터치 이벤트 종류</li>
<li>터치 이벤트 발생 좌표</li>
</ul>
</li>
<li>키 이벤트</li>
</ul>
<h3 id="사용자-이벤트-처리-1">사용자 이벤트 처리</h3>
<p>안드로이드 앱은 사용자의 다양한 상호작용(터치, 키 입력 등)에 반응해야 합니다. 이는 <strong>이벤트 기반 프로그래밍(Event-driven Programming)</strong> 모델을 통해 이루어집니다. 사용자가 행동을 취하면 시스템이 &lsquo;이벤트&rsquo; 객체를 생성하여 앱에 전달하고, 앱은 이 이벤트를 처리할 &lsquo;리스너(Listener)&rsquo; 또는 &lsquo;콜백(Callback)&rsquo; 함수를 통해 특정 로직을 수행합니다.</p>
<h4 id="터치-이벤트">터치 이벤트</h4>
<p><strong>핵심 원리: 터치 이벤트는 <code>Activity</code>에서 시작하여 계층 구조를 따라 가장 깊은 <code>View</code>까지 전달되며, 이 과정에서 특정 뷰가 이벤트를 &lsquo;소비(consume)&lsquo;하면 전파가 중단된다.</strong></p>
<p>터치 이벤트는 <code>onTouchEvent()</code> 콜백 함수를 통해 처리되며, <code>MotionEvent</code> 객체에 모든 관련 정보가 담겨 있습니다.</p>
<h5 id="터치-이벤트의-종류와-생명주기">터치 이벤트의 종류와 생명주기</h5>
<p>터치 이벤트는 단발성이 아니라 하나의 연속된 흐름을 가집니다.</p>
<table>
  <thead>
      <tr>
          <th>이벤트 종류 (in <code>MotionEvent</code>)</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>ACTION_DOWN</code></td>
          <td>사용자가 화면을 <strong>처음 눌렀을 때</strong> 단 한 번 발생합니다. 모든 터치 상호작용의 시작점입니다.</td>
      </tr>
      <tr>
          <td><code>ACTION_MOVE</code></td>
          <td>손가락을 <strong>누른 상태로 움직일 때</strong> 좌표가 바뀔 때마다 연속적으로 발생합니다. 드래그(Drag) 동작을 구현할 때 핵심적인 역할을 합니다.</td>
      </tr>
      <tr>
          <td><code>ACTION_UP</code></td>
          <td>사용자가 화면에서 <strong>손가락을 뗄 때</strong> 단 한 번 발생합니다. 터치 상호작용의 종료점입니다.</td>
      </tr>
      <tr>
          <td><code>ACTION_CANCEL</code></td>
          <td>터치 이벤트가 비정상적으로 종료될 때 발생합니다. 예를 들어, 뷰를 누른 상태에서 스크롤 가능한 상위 뷰(e.g., <code>ScrollView</code>)가 스크롤을 시작하면, 하위 뷰는 이 이벤트를 받게 됩니다.</td>
      </tr>
  </tbody>
</table>
<h5 id="터치-이벤트-발생-좌표-심화">터치 이벤트 발생 좌표 (심화)</h5>
<table>
  <thead>
      <tr>
          <th>속성</th>
          <th>설명</th>
          <th>사용 사례</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>event.x</code> / <code>event.y</code></td>
          <td>이벤트가 발생한 <strong>뷰(View)의 좌표계</strong>에서의 상대 좌표. 즉, 해당 뷰의 좌측 상단이 (0,0)입니다.</td>
          <td><strong>뷰 자체의 로직 처리:</strong> 커스텀 버튼 내에서 특정 영역이 눌렸는지 확인하거나, 그림판 앱에서 캔버스 뷰 내부에 그림을 그릴 때 사용합니다.</td>
      </tr>
      <tr>
          <td><code>event.rawX</code> / <code>event.rawY</code></td>
          <td><strong>화면(Screen)의 좌표계</strong>에서의 절대 좌표. 즉, 스마트폰 화면의 좌측 상단이 (0,0)입니다.</td>
          <td><strong>뷰 외부와의 상호작용:</strong> 뷰를 화면 전체에서 드래그하여 위치를 옮기거나, 화면 특정 위치에 팝업을 띄울 때 기준점으로 사용합니다.</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>🔑 <strong>시각적 비유</strong>: <code>rawX/rawY</code>가 &lsquo;벽에 걸린 TV 스크린 전체&rsquo;의 좌표라면, <code>x/y</code>는 &lsquo;TV 화면 속에서 재생되는 영화&rsquo; 내부의 좌표와 같습니다.</p>
</blockquote>
<h5 id="이벤트-소비consumption와-전파propagation">이벤트 소비(Consumption)와 전파(Propagation)</h5>
<p><code>onTouchEvent()</code> 함수의 반환값은 이벤트 처리 흐름에서 매우 중요합니다.</p>
<ul>
<li><code>return true</code>: &ldquo;이 이벤트를 내가 처리했으니(소비했으니), 더 이상 다른 곳으로 전파하지 마세요.&rdquo;
<ul>
<li><code>ACTION_DOWN</code> 이벤트에 대해 <code>true</code>를 반환하면, 이후의 <code>ACTION_MOVE</code>, <code>ACTION_UP</code> 이벤트가 <strong>모두 이 뷰로 전달</strong>됩니다. 드래그와 같은 연속적인 동작을 구현하려면 필수입니다.</li>
</ul>
</li>
<li><code>return false</code> (또는 <code>super.onTouchEvent(event)</code>): &ldquo;나는 이 이벤트를 처리하지 않았으니, 상위 뷰나 기본 동작이 처리하도록 전달하세요.&rdquo;
<ul>
<li><code>ACTION_DOWN</code>에 대해 <code>false</code>를 반환하면, 이후의 <code>ACTION_MOVE</code>, <code>ACTION_UP</code> 이벤트는 <strong>이 뷰로 전달되지 않습니다.</strong></li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>// CustomView.kt
override fun onTouchEvent(event: MotionEvent?): Boolean {
    when (event?.action) {
        MotionEvent.ACTION_DOWN -&gt; {
            Log.d(&#34;TouchEvent&#34;, &#34;DOWN 이벤트 발생. 이 뷰가 처리 시작!&#34;)
            return true // 이 뷰가 모든 터치 이벤트를 받겠다고 선언
        }
        MotionEvent.ACTION_MOVE -&gt; {
            Log.d(&#34;TouchEvent&#34;, &#34;MOVE: (${event.x}, ${event.y})&#34;)
        }
        MotionEvent.ACTION_UP -&gt; {
            Log.d(&#34;TouchEvent&#34;, &#34;UP 이벤트 발생. 처리 종료.&#34;)
        }
    }
    return super.onTouchEvent(event) // ACTION_DOWN에서 true를 반환했으므로 사실상 이 코드는 거의 호출되지 않음
}
</code></pre><h4 id="키-이벤트">키 이벤트</h4>
<p><strong>핵심 원리: 시스템 레벨의 물리적/가상 버튼 입력을 감지하는 메커니즘으로, 일반적인 텍스트 입력(소프트 키보드)과는 완전히 분리되어 있다.</strong></p>
<h5 id="키-이벤트-콜백-함수">키 이벤트 콜백 함수</h5>
<table>
  <thead>
      <tr>
          <th>콜백 함수</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>onKeyDown(keyCode, event)</code></td>
          <td>키를 <strong>누르는 순간</strong>에 호출됩니다. <code>event.repeatCount</code>를 통해 길게 눌렀을 때 반복적으로 호출되는 것을 감지할 수 있습니다.</td>
      </tr>
      <tr>
          <td><code>onKeyUp(keyCode, event)</code></td>
          <td>눌렀던 키에서 <strong>손을 떼는 순간</strong>에 호출됩니다.</td>
      </tr>
      <tr>
          <td><code>onKeyLongPress(keyCode, event)</code></td>
          <td>사용자가 키를 <strong>길게 누르고 있을 때</strong>, <code>onKeyDown</code>이 처음 호출된 후 일정 시간이 지나면 호출됩니다.</td>
      </tr>
  </tbody>
</table>
<h5 id="왜-소프트-키보드는-키-이벤트를-발생시키지-않는가">왜 소프트 키보드는 키 이벤트를 발생시키지 않는가?</h5>
<p>소프트 키보드는 그 자체가 하나의 독립적인 애플리케이션(<strong>IME</strong>: Input Method Editor)입니다. 사용자가 키를 누르면 IME는 &lsquo;키 입력&rsquo; 이벤트를 시스템에 보내는 것이 아니라, &lsquo;글자&rsquo; 자체를 현재 포커스된 <code>EditText</code>와 같은 뷰에 직접 전달합니다. 따라서 텍스트 변경을 감지하려면 <code>EditText</code>의 <code>addTextChangedListener</code>와 같은 고수준의 리스너를 사용해야 합니다.</p>
<h5 id="앱에서-처리-가능한-시스템-버튼-심화">앱에서 처리 가능한 시스템 버튼 (심화)</h5>
<p>앱이 전원, 홈 버튼 등을 가로챌 수 없는 이유는 <strong>사용자 경험의 일관성</strong>과 <strong>보안</strong> 때문입니다. 이 버튼들은 어떤 앱을 사용하든 항상 동일하게 동작해야 하는 시스템의 핵심 제어 기능입니다. 만약 악의적인 앱이 홈 버튼을 막는다면 사용자는 앱을 빠져나갈 수 없게 됩니다.</p>
<table>
  <thead>
      <tr>
          <th>구분</th>
          <th>버튼 종류</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>✅ <strong>처리 가능</strong></td>
          <td><strong>뒤로 가기, 볼륨 조절</strong></td>
          <td>앱의 컨텍스트 내에서 사용자 경험을 향상시키기 위해 커스터마이징이 허용됩니다. (예: 게임 중 볼륨 키를 다른 기능으로 매핑)</td>
      </tr>
      <tr>
          <td>❌ <strong>처리 불가</strong></td>
          <td><strong>전원, 홈, 오버뷰</strong></td>
          <td>시스템의 최상위 제어권을 가지며, 앱이 개입할 수 없도록 OS 레벨에서 차단됩니다.</td>
      </tr>
  </tbody>
</table>
<h5 id="뒤로-가기-버튼-처리-onbackpressed-vs-onbackpressedcallback">뒤로 가기 버튼 처리: <code>onBackPressed</code> vs. <code>OnBackPressedCallback</code></h5>
<p><code>onBackPressed()</code>가 Deprecated된 이유는 현대 안드로이드 아키텍처, 특히 <strong>Fragment</strong>와의 통합이 어렵기 때문입니다. <code>Activity</code>에만 존재하는 이 메서드는 여러 Fragment가 화면을 구성할 때 &ldquo;현재 활성화된 Fragment가 뒤로 가기 이벤트를 먼저 처리해야 한다&quot;는 로직을 구현하기 복잡하게 만듭니다.</p>
<p><strong><code>OnBackPressedCallback</code>의 장점:</strong></p>
<ol>
<li><strong>생명주기 인식(Lifecycle-Aware)</strong>: 콜백을 <code>Activity</code>나 <code>Fragment</code>의 생명주기에 바인딩할 수 있어, 화면이 보일 때만 콜백이 활성화되도록 쉽게 관리할 수 있습니다.</li>
<li><strong>모듈성 및 유연성</strong>: 각 Fragment나 컴포넌트가 자신만의 뒤로 가기 로직을 독립적으로 등록하고 관리할 수 있습니다.</li>
<li><strong>동적 활성화/비활성화</strong>: <code>callback.isEnabled = false</code> 와 같이 콜백을 실시간으로 켜고 끌 수 있어, 특정 조건(예: 양식 작성 중)에서만 뒤로 가기 동작을 막는 것이 매우 편리합니다.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// Activity의 onCreate 등에서 콜백 등록
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// &#39;뒤로 가기&#39;를 두 번 눌러야 종료되는 기능 구현 예시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> backPressedTime: Long = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> callback = <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">OnBackPressedCallback</span>(<span style="color:#66d9ef">true</span>) { <span style="color:#75715e">// true: 콜백을 초기에 활성화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">handleOnBackPressed</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2초 이내에 다시 누르면 액티비티 종료
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">System</span>.currentTimeMillis() - backPressedTime &lt; <span style="color:#ae81ff">2000</span>) {
</span></span><span style="display:flex;"><span>            finish()
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 처음 눌렀거나, 누른 지 2초가 지났으면 토스트 메시지 표시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">Toast</span>.makeText(<span style="color:#66d9ef">this</span><span style="color:#a6e22e">@MainActivity</span>, <span style="color:#e6db74">&#34;한 번 더 누르면 종료됩니다.&#34;</span>, <span style="color:#a6e22e">Toast</span>.LENGTH_SHORT).show()
</span></span><span style="display:flex;"><span>            backPressedTime = <span style="color:#a6e22e">System</span>.currentTimeMillis()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">this</span>.onBackPressedDispatcher.addCallback(<span style="color:#66d9ef">this</span>, callback)
</span></span></code></pre></div><h6 id="-핵심-교훈-6">💡 핵심 교훈</h6>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>저수준(Low-level) vs. 고수준(High-level) 이벤트</strong></td>
          <td><code>onTouchEvent</code>, <code>onKeyDown</code>은 시스템에서 오는 날 것의 <strong>저수준 이벤트</strong>입니다. 반면 <code>setOnClickListener</code>, <code>addTextChangedListener</code> 등은 이러한 저수준 이벤트를 조합하고 추상화하여 특정 목적에 맞게 만든 <strong>고수준 이벤트 리스너</strong>입니다. <strong>대부분의 경우, 고수준 리스너를 사용하는 것이 더 간단하고 안정적입니다.</strong></td>
      </tr>
      <tr>
          <td><strong>이벤트 처리의 책임</strong></td>
          <td><code>return true</code>를 통해 이벤트를 &lsquo;소비&rsquo;하는 것은 해당 이벤트에 대한 모든 책임을 지겠다는 의미입니다. 연속적인 터치 동작(드래그, 핀치 줌 등)을 구현할 때 이 개념을 반드시 이해해야 합니다.</td>
      </tr>
      <tr>
          <td><strong>시스템 동작과의 조화</strong></td>
          <td>키 이벤트를 커스터마이징할 때는 사용자의 일반적인 기대를 해치지 않는 선에서 신중하게 구현해야 합니다. 특히 뒤로 가기 버튼의 기본 동작을 막을 때는 사용자에게 명확한 피드백을 제공해야 합니다.</td>
      </tr>
      <tr>
          <td><strong>아키텍처의 변화 수용</strong></td>
          <td><code>onBackPressed()</code>에서 <code>OnBackPressedCallback</code>으로의 전환은 안드로이드가 생명주기와 컴포넌트 기반 아키텍처를 얼마나 중요하게 생각하는지를 보여주는 좋은 예입니다. 항상 최신 권장 방식을 따르는 것이 좋습니다.</td>
      </tr>
  </tbody>
</table>
<h4 id="뷰-이벤트-처리">뷰 이벤트 처리</h4>
<p>안드로이드에서 사용자 상호작용의 가장 기본이 되는 단위는 뷰(View)에서 발생하는 이벤트입니다. 이벤트 처리는 명확하게 역할이 나뉜 세 가지 구성 요소의 협력을 통해 이루어집니다. 이 구조를 이해하면 어떤 뷰의 이벤트라도 일관된 방식으로 처리할 수 있습니다.</p>
<h5 id="뷰-이벤트-처리의-기본-구조">뷰 이벤트 처리의 기본 구조</h5>
<p>뷰 이벤트 처리는 &lsquo;이벤트가 발생한 객체&rsquo;와 &lsquo;이벤트를 처리할 로직&rsquo;을 &lsquo;연결&rsquo;하는 과정입니다.</p>
<ul>
<li><strong>이벤트 소스 (Event Source)</strong>: 이벤트가 발생한 뷰 객체 그 자체입니다. (예: 사용자가 터치한 버튼, 체크 상태를 바꾼 체크박스)</li>
<li><strong>이벤트 핸들러 (Event Handler)</strong>: 이벤트가 발생했을 때 실제로 실행될 코드를 담고 있는 객체입니다. 특정 인터페이스를 구현하여 만들어집니다.</li>
<li><strong>리스너 (Listener)</strong>: 이벤트 소스에 이벤트 핸들러를 등록(연결)하는 함수입니다. 보통 <code>set...Listener()</code> 형태의 이름을 가집니다.</li>
</ul>
<p>
        <img src="/08.media/20251016134344-1760589824616-image.png" alt=" (Image resource not found)" ></p>
<blockquote>
<p><strong>그림 8-6 뷰 이벤트 처리 구조</strong></p>
</blockquote>
<p>즉, <strong>이벤트 소스</strong>에 <strong>리스너</strong> 함수를 사용하여 <strong>이벤트 핸들러</strong>를 등록해두면, 해당 이벤트가 발생했을 때 시스템이 등록된 핸들러의 로직을 실행시켜주는 구조입니다.</p>
<p>아래 코드는 체크박스의 체크 상태가 변경될 때의 이벤트를 처리하는 예시입니다.</p>
<ul>
<li><strong>이벤트 소스</strong>: <code>binding.checkbox</code> 객체</li>
<li><strong>리스너</strong>: <code>setOnCheckedChangeListener()</code> 함수</li>
<li><strong>이벤트 핸들러</strong>: <code>CompoundButton.OnCheckedChangeListener</code> 인터페이스를 구현한 <code>object</code> 익명 객체</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// 체크박스 이벤트 처리
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 이벤트 소스      리스너(이벤트 핸들러 등록)            이벤트 핸들러
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>binding.checkbox.setOnCheckedChangeListener(<span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">CompoundButton</span>.OnCheckedChangeListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCheckedChanged</span>(buttonView: CompoundButton?, isChecked: Boolean) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;체크박스 클릭, 현재 상태: </span><span style="color:#e6db74">$isChecked</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>
        <img src="/08.media/20251016134408-1760589848687-image.png" alt=" (Image resource not found)" ></p>
<blockquote>
<p><strong>그림 8-7 CheckEvent 구조</strong></p>
</blockquote>
<p>대부분의 이벤트 핸들러는 <code>On...Listener</code> 형태의 인터페이스를 구현하여 만듭니다. 안드로이드 프레임워크는 <code>OnClickListener</code>, <code>OnLongClickListener</code>, <code>OnItemClickListener</code> 등 다양한 상황에 맞는 인터페이스를 제공합니다.</p>
<h3 id="이벤트-핸들러-구현의-3가지-방법">이벤트 핸들러 구현의 3가지 방법</h3>
<p>지정된 인터페이스를 구현한 객체를 이벤트 핸들러로 등록한다는 핵심 원칙은 동일하지만, 구현 방식은 코드 구조와 스타일에 따라 여러 가지가 가능합니다.</p>
<h4 id="1-액티비티에서-인터페이스-구현">1. 액티비티에서 인터페이스 구현</h4>
<p>Activity 클래스 자체가 리스너 인터페이스를 직접 구현하는 방식입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity3</span> : AppCompatActivity(), <span style="color:#a6e22e">CompoundButton</span>.OnCheckedChangeListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> binding = ActivityMain3Binding.inflate(layoutInflater)
</span></span><span style="display:flex;"><span>        setContentView(binding.root)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 리스너의 인자로 Activity 자신(this)을 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        binding.checkbox.setOnCheckedChangeListener(<span style="color:#66d9ef">this</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 인터페이스의 추상 메서드 구현
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCheckedChanged</span>(buttonView: CompoundButton?, isChecked: Boolean) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;체크박스 클릭&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>특징 및 장단점</strong>:
<ul>
<li><strong>장점</strong>: 관련된 코드가 Activity 클래스 내에 모여있어 간단한 경우 파악하기 쉽습니다.</li>
<li><strong>단점</strong>: Activity가 여러 종류의 리스너를 구현하면 코드가 비대해지고 역할이 불분명해집니다. (단일 책임 원칙 위배 가능성)</li>
</ul>
</li>
</ul>
<h4 id="2-별도의-클래스로-구현">2. 별도의 클래스로 구현</h4>
<p>이벤트 핸들러 로직을 완전히 분리된 클래스로 작성하는 방식입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// 이벤트 핸들러를 별도의 클래스로 분리
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyEventHandler</span> : <span style="color:#a6e22e">CompoundButton</span>.OnCheckedChangeListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCheckedChanged</span>(buttonView: CompoundButton?, isChecked: Boolean) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;체크박스 클릭&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity3</span> : AppCompatActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> binding = ActivityMain3Binding.inflate(layoutInflater)
</span></span><span style="display:flex;"><span>        setContentView(binding.root)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 분리된 핸들러 클래스의 인스턴스를 생성하여 등록
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        binding.checkbox.setOnCheckedChangeListener(MyEventHandler())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>특징 및 장단점</strong>:
<ul>
<li><strong>장점</strong>: 로직이 복잡하거나 여러 곳에서 재사용될 때 유용합니다. 코드의 역할 분리가 명확해져 가독성과 유지보수성이 향상됩니다.</li>
<li><strong>단점</strong>: 간단한 일회성 이벤트 처리를 위해 매번 클래스를 만드는 것은 번거로울 수 있습니다.</li>
</ul>
</li>
</ul>
<h4 id="3-sam-기법-람다식으로-구현">3. SAM 기법 (람다식)으로 구현</h4>
<p>코틀린에서 가장 보편적이고 권장되는 방식입니다. 자바의 함수형 인터페이스를 간결한 람다(Lambda) 표현식으로 대체할 수 있는 SAM(Single Abstract Method) 변환을 활용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity3</span> : AppCompatActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> binding = ActivityMain3Binding.inflate(layoutInflater)
</span></span><span style="display:flex;"><span>        setContentView(binding.root)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 인터페이스 구현 객체 대신 람다식을 바로 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        binding.checkbox.setOnCheckedChangeListener { compoundButton, b <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;체크박스 클릭&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>특징 및 장단점</strong>:
<ul>
<li><strong>장점</strong>: 코드가 매우 간결하고 직관적입니다. 불필요한 보일러플레이트 코드를 제거하여 생산성이 높습니다.</li>
<li><strong>단점</strong>: SAM 변환이 가능한 인터페이스(추상 메서드가 하나인 인터페이스)에만 사용할 수 있습니다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="주요-뷰-이벤트-클릭과-롱클릭">주요 뷰 이벤트: 클릭과 롱클릭</h3>
<p>뷰가 아무리 많아도 이벤트 처리 구조는 동일합니다. 여기서는 모든 뷰의 기반이 되는 <code>View</code> 클래스에 정의된 가장 대표적인 두 이벤트를 알아봅니다.</p>
<ul>
<li><strong>ClickEvent</strong>: 뷰를 짧게 클릭했을 때 발생</li>
<li><strong>LongClickEvent</strong>: 뷰를 길게 눌렀을 때 발생</li>
</ul>
<p>두 이벤트의 핸들러를 등록하는 리스너 함수는 다음과 같습니다.</p>
<ul>
<li><code>open fun setOnClickListener(l: View.OnClickListener?): Unit</code></li>
<li><code>open fun setOnLongClickListener(l: View.OnLongClickListener?): Unit</code></li>
</ul>
<p>SAM 기법을 활용하여 버튼의 클릭, 롱클릭 이벤트를 처리하는 코드는 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>binding.button.setOnClickListener {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;클릭 이벤트&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>binding.button.setOnLongClickListener {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Log</span>.d(<span style="color:#e6db74">&#34;kkang&#34;</span>, <span style="color:#e6db74">&#34;롱클릭 이벤트&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">true</span> <span style="color:#75715e">// 이벤트 처리가 완료되었음을 알림
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="sam-single-abstract-method-변환-심층-분석">SAM (Single Abstract Method) 변환 심층 분석</h3>
<p><code>binding.button.setOnClickListener { ... }</code>와 같은 람다식 코드가 어떻게 동작하는지 이해하는 것은 매우 중요합니다.</p>
<h4 id="1-java-방식의-이벤트-핸들러">1. Java 방식의 이벤트 핸들러</h4>
<p>자바에서는 보통 아래와 같이 익명 내부 클래스(anonymous inner class)를 사용하여 이벤트 핸들러를 작성합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 자바로 작성한 이벤트 핸들러</span>
</span></span><span style="display:flex;"><span>binding.<span style="color:#a6e22e">btn</span>.<span style="color:#a6e22e">setOnClickListener</span>(<span style="color:#66d9ef">new</span> View.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(View view) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 클릭 시 실행될 로직 ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h4 id="2-코틀린의-정식-변환-object-사용">2. 코틀린의 정식 변환 (object 사용)</h4>
<p>위 자바 코드를 코틀린으로 그대로 변환하면 <code>object</code> 키워드를 사용한 익명 객체 표현식이 됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#75715e">// 코틀린으로 작성한 이벤트 핸들러
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>binding.btn.setOnClickListener(<span style="color:#66d9ef">object</span>: <span style="color:#a6e22e">View</span>.OnClickListener {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onClick</span>(p0: View?) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 클릭 시 실행될 로직 ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h4 id="3-코틀린-sam-기법을-통한-간소화">3. 코틀린 SAM 기법을 통한 간소화</h4>
<p>코틀린은 <strong>추상 메서드가 단 하나뿐인 자바 인터페이스</strong>를 인자로 받는 자바 함수를 호출할 때, 위와 같은 <code>object</code> 표현식 대신 람다식으로 코드를 자동 변환해주는 <strong>SAM 변환</strong> 기능을 제공합니다.</p>
<p><code>View.OnClickListener</code> 인터페이스는 <code>onClick()</code>이라는 추상 메서드를 단 하나만 가지고 있습니다. 따라서 코틀린 컴파일러는 아래와 같은 람다식을,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>binding.btn.setOnClickListener { <span style="color:#f92672">..</span>. }
</span></span></code></pre></div><p>내부적으로는 <code>View.OnClickListener</code>를 구현한 객체로 변환하여 <code>setOnClickListener</code> 함수에 전달해 줍니다. 이 덕분에 개발자는 매우 간결하고 읽기 쉬운 코드를 작성할 수 있습니다.</p>
<blockquote>
<p><strong>💡 SAM 변환의 조건</strong>
SAM 변환은 코틀린 코드에서 <strong>자바로 작성된 메서드</strong>를 호출할 때, 그 메서드가 <strong>추상 메서드가 하나인 자바 인터페이스</strong>를 매개변수로 요구하는 경우에만 적용됩니다.</p>
</blockquote>
<h3 id="-질문-있어요-qa">❓ 질문 있어요! (Q&amp;A)</h3>
<blockquote>
<p><strong>Q.</strong> 롱클릭 이벤트 핸들러에서 마지막 줄의 <code>true</code>를 생략하면 오류가 발생합니다. 어떤 의미인가요?</p>
</blockquote>
<p><strong>A.</strong> 이는 <strong>함수의 반환값</strong>을 의미합니다. <code>setOnLongClickListener</code>가 요구하는 <code>OnLongClickListener</code> 인터페이스의 추상 메서드 <code>onLongClick</code>은 다음과 같이 정의되어 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onLongClick</span>(v: View!): Boolean
</span></span></code></pre></div><p>메서드의 반환 타입이 <code>Boolean</code>이므로, 이벤트를 처리한 후 반드시 <code>true</code> 또는 <code>false</code>를 반환해야 합니다.</p>
<p>코틀린에서 여러 줄로 구성된 람다식은 <strong>마지막 줄의 실행 결과를 자동으로 반환값으로 취급</strong>합니다. 따라서 <code>return</code> 키워드 없이 <code>true</code>만 적어도 <code>onLongClick</code> 메서드가 <code>true</code>를 반환하는 것으로 처리됩니다.</p>
<ul>
<li><code>true</code> 반환: &ldquo;이 롱클릭 이벤트를 내가 완전히 처리(소비)했음. 이후 다른 이벤트(예: 클릭 이벤트)를 발생시키지 말 것.&rdquo;</li>
<li><code>false</code> 반환: &ldquo;롱클릭 이벤트에 반응은 했지만, 완전히 처리한 것은 아님. 시스템이 이어서 다른 이벤트(예: 클릭 이벤트)를 발생시켜도 됨.&rdquo;</li>
</ul>
<h2 id="추가">추가</h2>
<h3 id="empty-activity-초기-mainkt-설명">Empty Activity 초기 main.kt 설명</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">package</span> com.example.myapplication
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> android.os.Bundle
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.activity.ComponentActivity
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.activity.compose.setContent
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.activity.enableEdgeToEdge
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.foundation.layout.fillMaxSize
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.foundation.layout.padding
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.material3.Scaffold
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.material3.Text
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.runtime.Composable
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.ui.Modifier
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> androidx.compose.ui.tooling.preview.Preview
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> com.example.myapplication.ui.theme.MyApplicationTheme
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity</span> : ComponentActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        enableEdgeToEdge()
</span></span><span style="display:flex;"><span>        setContent {
</span></span><span style="display:flex;"><span>            MyApplicationTheme {
</span></span><span style="display:flex;"><span>                Scaffold(modifier = <span style="color:#a6e22e">Modifier</span>.fillMaxSize()) { innerPadding <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>                    Greeting(
</span></span><span style="display:flex;"><span>                        name = <span style="color:#e6db74">&#34;Android&#34;</span>,
</span></span><span style="display:flex;"><span>                        modifier = <span style="color:#a6e22e">Modifier</span>.padding(innerPadding)
</span></span><span style="display:flex;"><span>                    )
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Composable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Greeting</span>(name: String, modifier: Modifier = Modifier) {
</span></span><span style="display:flex;"><span>    Text(
</span></span><span style="display:flex;"><span>        text = <span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">$name</span><span style="color:#e6db74">!&#34;</span>,
</span></span><span style="display:flex;"><span>        modifier = modifier
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Preview</span>(showBackground = <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Composable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">GreetingPreview</span>() {
</span></span><span style="display:flex;"><span>    MyApplicationTheme {
</span></span><span style="display:flex;"><span>        Greeting(<span style="color:#e6db74">&#34;Android&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>네, 좋습니다. 전문가를 대상으로 Jetpack Compose의 내부 아키텍처와 디자인 철학에 초점을 맞춰 해당 코드를 심도 있게 분석해 보겠습니다. 이 코드는 단순해 보이지만, Compose의 핵심 원리들을 압축적으로 보여주는 훌륭한 예시입니다.</p>
<hr>
<h4 id="분석-개요"><strong>분석 개요</strong></h4>
<p>이 코드는 크게 세 가지 핵심 레이어를 보여줍니다.</p>
<ol>
<li><strong>Framework Integration Layer (<code>MainActivity</code>):</strong> 전통적인 Android View 시스템과 새로운 Compose 런타임 간의 브릿지 역할.</li>
<li><strong>Composition &amp; State Layer (<code>MyApplicationTheme</code>, <code>Scaffold</code>):</strong> UI 트리를 구성하고, 암시적 데이터를 전파하며, 상태에 따라 UI를 재구성(Recomposition)하는 메커니즘.</li>
<li><strong>UI Declaration &amp; Modification Layer (<code>Greeting</code>, <code>Text</code>, <code>Modifier</code>):</strong> 실제 UI 노드를 선언하고, 이들의 속성을 데코레이터 패턴으로 확장하는 방식.</li>
</ol>
<p>이제 각 부분을 내부 구조 중심으로 상세히 살펴보겠습니다.</p>
<hr>
<h4 id="1-framework-integration-layer"><strong>1. Framework Integration Layer: <code>MainActivity</code> &amp; <code>setContent</code></strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainActivity</span> : ComponentActivity() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onCreate</span>(savedInstanceState: Bundle?) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.onCreate(savedInstanceState)
</span></span><span style="display:flex;"><span>        enableEdgeToEdge()
</span></span><span style="display:flex;"><span>        setContent {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ... Composable Content ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="componentactivity"><strong><code>ComponentActivity</code>와 <code>setContent</code>의 역할</strong></h5>
<ul>
<li><strong><code>ComponentActivity</code></strong>: 단순히 Compose를 쓰기 위한 액티비티가 아닙니다. 이는 <code>LifecycleOwner</code>, <code>ViewModelStoreOwner</code>, <code>SavedStateRegistryOwner</code> 등 현대적인 Android 아키텍처 컴포넌트들의 생명주기와 상태를 관리하는 핵심적인 역할을 합니다.</li>
<li><strong><code>setContent</code></strong>: 이 함수가 바로 <strong>Compose World로 진입하는 관문</strong>입니다. 내부적으로 다음과 같은 중요한 작업을 수행합니다.
<ol>
<li>기존 액티비티의 <code>contentView</code>를 제거합니다.</li>
<li><code>ComposeView</code>라는 특수한 <code>View</code>를 생성하여 액티비티의 루트 뷰로 설정합니다.</li>
<li>이 <code>ComposeView</code> 내에서 <strong>새로운 <code>Composition</code>을 생성</strong>합니다. <code>Composition</code>은 UI 트리의 상태를 추적하고 관리하는 객체입니다.</li>
<li><code>Recomposer</code>를 액티비티의 생명주기에 연결(attach)합니다. <code>Recomposer</code>는 State 변화를 감지하고 Recomposition을 스케줄링하는 백그라운드 코루틴 기반의 스케줄러입니다. <code>Lifecycle.State.CREATED</code>에서 시작하여 <code>Lifecycle.State.DESTROYED</code>에서 중단됩니다.</li>
</ol>
</li>
</ul>
<h5 id="enableedgetoedge"><strong><code>enableEdgeToEdge()</code>의 내부 동작</strong></h5>
<ul>
<li>이 함수는 단순히 UI를 확장하는 것 이상입니다. 내부적으로 <code>WindowCompat.setDecorFitsSystemWindows(window, false)</code>를 호출합니다.</li>
<li>이는 Window Decor View가 시스템 인셋(insets)을 더 이상 고려하지 않도록 하여, 앱의 콘텐츠 영역이 상태 표시줄과 내비게이션 바 아래까지 확장되도록 합니다.</li>
<li>이후 <code>ViewCompat.setOnApplyWindowInsetsListener</code>를 통해 시스템 인셋 정보를 수신하고, 이를 Compose 레이아웃 시스템으로 전달할 준비를 합니다. <code>Scaffold</code>와 같은 컴포저블은 이 정보를 활용하여 콘텐츠에 적절한 패딩을 적용하게 됩니다.</li>
</ul>
<hr>
<h4 id="2-composition--state-layer"><strong>2. Composition &amp; State Layer: <code>MyApplicationTheme</code> &amp; <code>Scaffold</code></strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>MyApplicationTheme {
</span></span><span style="display:flex;"><span>    Scaffold(modifier = <span style="color:#a6e22e">Modifier</span>.fillMaxSize()) { innerPadding <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        Greeting(
</span></span><span style="display:flex;"><span>            name = <span style="color:#e6db74">&#34;Android&#34;</span>,
</span></span><span style="display:flex;"><span>            modifier = <span style="color:#a6e22e">Modifier</span>.padding(innerPadding)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="myapplicationtheme"><strong><code>MyApplicationTheme</code>와 <code>CompositionLocal</code></strong></h5>
<ul>
<li><code>MyApplicationTheme</code>은 단순한 스타일링 래퍼(wrapper)가 아닙니다. 이는 **<code>CompositionLocal</code>**이라는 강력한 메커니즘의 실제 사용 사례입니다.</li>
<li>내부적으로 <code>CompositionLocalProvider</code>를 사용하여 <code>LocalColorScheme</code>, <code>LocalTextStyle</code> 등의 <code>CompositionLocal</code> 객체에 특정 값(e.g., <code>MaterialTheme.colorScheme</code>)을 제공합니다.</li>
<li><code>CompositionLocal</code>은 하위 컴포저블 트리 전체에 데이터를 <strong>암시적으로(implicitly)</strong> 전파하는 방법입니다. 모든 컴포저블에 <code>theme</code> 객체를 명시적으로 전달하는 &lsquo;Prop Drilling&rsquo;을 피할 수 있게 해줍니다.</li>
<li>하위 컴포저블(예: <code>Text</code>, <code>Button</code>)은 <code>MaterialTheme.colorScheme</code>과 같은 코드를 통해 현재 스코프의 <code>CompositionLocal</code> 값을 읽어와 자신을 렌더링합니다.</li>
</ul>
<h5 id="scaffold"><strong><code>Scaffold</code>와 Slot-based API</strong></h5>
<ul>
<li><code>Scaffold</code>는 머티리얼 디자인의 구조를 구현한 고수준 컴포저블이며, <strong>Slot-based API</strong>의 대표적인 예시입니다. <code>topBar</code>, <code>bottomBar</code>, <code>floatingActionButton</code>, <code>content</code> 등 특정 목적을 가진 람다 파라미터를 &ldquo;슬롯&quot;으로 제공합니다.</li>
<li>가장 중요한 부분은 <code>content</code> 람다에 전달되는 <code>innerPadding: PaddingValues</code>입니다. 이는 부모 컴포저블(<code>Scaffold</code>)이 자식(<code>Greeting</code>)의 레이아웃에 필요한 정보를 제공하는 Compose의 협력적인 레이아웃 모델을 보여줍니다.</li>
<li><code>Scaffold</code>는 <code>topBar</code> 등의 슬롯에 채워진 컴포저블들의 크기를 측정하고, <code>enableEdgeToEdge</code>로 인해 발생한 시스템 인셋을 고려하여, 메인 콘텐츠가 그려져야 할 안전한 영역을 계산합니다. 이 계산 결과가 바로 <code>innerPadding</code>이며, 자식은 이 값을 <code>Modifier.padding</code>에 적용하여 UI가 가려지는 것을 방지합니다.</li>
</ul>
<hr>
<h4 id="3-ui-declaration--modification-layer"><strong>3. UI Declaration &amp; Modification Layer</strong></h4>
<h5 id="composable"><strong><code>@Composable</code> 함수의 변환(Transformation)</strong></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Composable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">Greeting</span>(name: String, modifier: Modifier = Modifier) { <span style="color:#f92672">..</span>. }
</span></span></code></pre></div><ul>
<li><code>@Composable</code> 어노테이션은 단순한 마커가 아닙니다. 이는 <strong>Compose 컴파일러 플러그인</strong>을 활성화하는 트리거입니다.</li>
<li>컴파일 시점에 컴파일러는 이 함수를 변환하여 두 개의 숨겨진 파라미터를 추가합니다.
<ol>
<li><code>composer: Composer</code>: 현재 Composition의 &ldquo;지휘자&rdquo; 역할을 합니다. <code>composer.startNode()</code>, <code>composer.emit()</code> 등의 호출을 통해 UI 트리를 <strong>Slot Table</strong>이라는 내부 데이터 구조에 기록합니다.</li>
<li><code>changed: Int</code>: 파라미터들의 변경 여부를 추적하는 비트마스크(bitmask)입니다. 이를 통해 Recomposition 시, 변경되지 않은 컴포저블의 실행을 건너뛰는 <strong>Smart Recomposition</strong> 최적화가 가능해집니다. <code>name</code> 파라미터가 안정적(stable)이고 이전과 같은 값이라면, <code>Greeting</code> 함수의 재실행을 건너뛸 수 있습니다.</li>
</ol>
</li>
</ul>
<h5 id="text"><strong><code>Text</code> 컴포저블과 UI 노드</strong></h5>
<ul>
<li><code>Text</code>와 같은 기본 컴포저블은 UI 트리의 &ldquo;잎(leaf)&ldquo;에 해당합니다.</li>
<li>이 함수가 실행되면, 내부적으로 <code>composer.emitNode</code>를 호출하여 Slot Table에 <code>LayoutNode</code>를 생성합니다.</li>
<li><code>LayoutNode</code>는 Compose UI 트리의 기본 단위이며, 측정(measure), 배치(layout), 그리기(draw) 로직을 포함하고 있습니다. <code>text</code>, <code>color</code> 등의 파라미터는 이 <code>LayoutNode</code>의 속성으로 설정됩니다.</li>
</ul>
<h5 id="modifier"><strong><code>Modifier</code>의 아키텍처: Decorator Pattern</strong></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>modifier = <span style="color:#a6e22e">Modifier</span>.padding(innerPadding)
</span></span></code></pre></div><ul>
<li><code>Modifier</code>는 순서가 중요한, 불변(immutable) <code>Modifier.Element</code>들의 체인입니다. 이는 <strong>데코레이터 패턴</strong>과 매우 유사하게 동작합니다.</li>
<li><code>Modifier.padding(innerPadding)</code>은 <code>PaddingModifier</code>라는 <code>Modifier.Element</code>를 생성합니다. <code>MainActivity</code>에서 <code>Modifier.fillMaxSize()</code>는 <code>SizeModifier</code>를 생성합니다.</li>
<li>Modifier 체인은 바깥쪽부터 안쪽으로 적용됩니다. <code>Scaffold</code>의 <code>Modifier.fillMaxSize()</code>가 먼저 적용되어 크기를 결정하고, 그 후 <code>Greeting</code>의 <code>Modifier.padding(innerPadding)</code>이 적용되어 내부 콘텐츠의 위치를 조정합니다.</li>
<li>각 <code>Modifier.Element</code>는 레이아웃의 특정 단계(measurement, layout, drawing, semantics, input)에 영향을 줄 수 있습니다. 이 아키텍처 덕분에 단일 책임 원칙을 지키면서도 UI 요소의 기능을 유연하게 확장할 수 있습니다.</li>
</ul>
<h5 id="preview"><strong><code>@Preview</code>와 Tooling의 분리</strong></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Preview</span>(showBackground = <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Composable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">GreetingPreview</span>() { <span style="color:#f92672">..</span>. }
</span></span></code></pre></div><ul>
<li><code>@Preview</code>는 런타임이 아닌 <strong>Tool-time</strong> 어노테이션입니다.</li>
<li>Android Studio는 이 어노테이션을 감지하고, 별도의 프로세스에서 LayoutLib을 사용하여 해당 컴포저블을 렌더링합니다. 이는 앱의 런타임 로직과 UI 렌더링 로직의 완벽한 분리를 보여줍니다.</li>
<li>이를 통해 개발자는 전체 앱을 빌드하고 실행할 필요 없이, 각 UI 컴포넌트를 독립적으로 빠르게 개발하고 테스트할 수 있습니다. 이는 컴포넌트 기반 아키텍처(Component-Based Architecture)를 장려하는 Compose의 핵심 철학입니다.</li>
</ul>
<h4 id="결론-1"><strong>결론</strong></h4>
<ul>
<li><code>setContent</code>를 통해 View 시스템에서 Compose 런타임으로 제어권을 이전하고,</li>
<li><code>CompositionLocal</code>로 테마 같은 전역적 데이터를 효율적으로 전파하며,</li>
<li><code>Scaffold</code>와 같은 고수준 컴포저블의 Slot API를 통해 구조를 정의하고,</li>
<li>컴파일러 플러그인에 의해 변환된 <code>@Composable</code> 함수들이 Slot Table에 UI 트리를 선언적으로 기술하며,</li>
<li><code>Modifier</code> 체인을 통해 UI 노드의 속성을 계층적으로 꾸미는, 매우 정교하고 잘 설계된 아키텍처를 보여주고 있습니다.</li>
</ul>
<p>이는 기존의 명령형(imperative) UI 툴킷과 근본적으로 다른, 선언형(declarative) 패러다임이 어떻게 구현되었는지를 명확히 보여주는 교과서적인 예제입니다.</p>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
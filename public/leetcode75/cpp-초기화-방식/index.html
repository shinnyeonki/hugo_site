<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>cpp 초기화 방식 | My Test Site</title>
    

    
    
    <meta name="description" content="class Widget { public: Widget() { std::cout &lt;&lt; &#34;default&#34; &lt;&lt; std::endl; } Widget(std::initializer_list&lt;int&gt; il) { std::cout …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/leetcode75/cpp-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%A9%EC%8B%9D/">

    
    
    
    <meta property="og:title" content="cpp 초기화 방식">
    <meta property="og:description" content="class Widget { public: Widget() { std::cout &lt;&lt; &#34;default&#34; &lt;&lt; std::endl; } Widget(std::initializer_list&lt;int&gt; il) { std::cout …">
    <meta property="og:url" content="http://localhost:1313/leetcode75/cpp-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%A9%EC%8B%9D/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="cpp 초기화 방식">
    <meta name="twitter:description" content="class Widget { public: Widget() { std::cout &lt;&lt; &#34;default&#34; &lt;&lt; std::endl; } Widget(std::initializer_list&lt;int&gt; il) { std::cout …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>cpp 초기화 방식 **page.html**</h1>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  Widget() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Widget(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> il) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;init&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>Widget w1; <span style="color:#75715e">//기본 생성자 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w2(); <span style="color:#75715e">//함수! 호출 x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w3{}; <span style="color:#75715e">//기본 생성자 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w4({});<span style="color:#75715e">//std::initializer_list 이용해 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w5{ {} };<span style="color:#75715e">//std::initializer_list 이용해 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w6 <span style="color:#f92672">=</span> {}; <span style="color:#75715e">// 기본 생성자 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Widget w7 <span style="color:#f92672">=</span> { {} }; <span style="color:#75715e">//std::initializer_list 이용해 호출
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>모두의 코드 해당 자료
<a href="https://modoocode.com/286" class="external-link" target="_blank" rel="noopener noreferrer" >https://modoocode.com/286</a></p>
<h2 id="1-초기화initialization란">1. 초기화(Initialization)란?</h2>
<ul>
<li><strong>정의</strong>:<br>
변수를 선언할 때 그 변수에 최초의 값을 제공하는 과정을 <strong>초기화</strong>라고 합니다.
<ul>
<li>객체나 변수의 메모리 공간이 할당되면서 동시에 정해진 초기 값이 부여됩니다.</li>
<li>이는 선언문의 초기화 부분이나, <code>new</code> 표현식, 함수 호출 시(함수 인자 및 리턴값 초기화) 등에서 이루어집니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-초기화-구문initializers-형태">2. 초기화 구문(Initializers) 형태</h2>
<p>각 선언자(declarator)에 대해 초기화자가 있을 경우 사용할 수 있는 구문은 다음과 같습니다.</p>
<ol>
<li>
<p><strong><code>= expression</code></strong></p>
<ul>
<li>
<p><strong>설명</strong>: 등호(<code>=</code>) 다음에 임의의 표현식이 나오는 형태입니다.</p>
</li>
<li>
<p><strong>예</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>용어</strong>: &ldquo;복사 초기화(copy-initialization)&ldquo;라고 부릅니다.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>= {}</code> 또는 <code>= { initializer-list }</code> 또는 <code>= { designated-initializer-list }</code></strong></p>
<ul>
<li>
<p><strong>설명</strong>: 등호 뒤에 중괄호를 사용하여 초기값을 나열하는 형태입니다.</p>
</li>
<li>
<p><strong>역사</strong>:</p>
<ul>
<li>C++11부터 중괄호를 사용한 **목록 초기화(list-initialization)**가 도입되었습니다.</li>
<li>C++20부터 <strong>지정 초기자(designated initializer)</strong> 문법이 추가되었습니다.</li>
</ul>
</li>
<li>
<p><strong>예</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// 배열에 대한 aggregate 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyStruct s <span style="color:#f92672">=</span> { .x <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, .y <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span> }; <span style="color:#75715e">// C++20 지정 초기자
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>( expression-list )</code> 또는 <code>( initializer-list )</code></strong></p>
<ul>
<li>
<p><strong>설명</strong>: 괄호를 사용한 직접 초기화 구문입니다.</p>
</li>
<li>
<p><strong>차이점</strong>:</p>
<ul>
<li>C++11 이전에는 괄호 안에 초기값 목록을 쓰는 것이 <strong>직접 초기화(direct-initialization)</strong> 문법이었습니다.</li>
<li>C++11 이후에도 여전히 지원됩니다.</li>
</ul>
</li>
<li>
<p><strong>예</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s(<span style="color:#e6db74">&#34;hello&#34;</span>); <span style="color:#75715e">// 직접 초기화
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>{}</code> 또는 <code>{ initializer-list }</code> 또는 <code>{ designated-initializer-list }</code></strong></p>
<ul>
<li>
<p><strong>설명</strong>: 중괄호만을 사용한 초기화 구문으로, C++11부터 도입된 **목록 초기화(list-initialization)**입니다.</p>
</li>
<li>
<p><strong>예</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s{<span style="color:#e6db74">&#34;hello&#34;</span>}; <span style="color:#75715e">// 목록 초기화 (C++11 이후)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a{};                <span style="color:#75715e">// 기본값으로 초기화 (보통 0으로 초기화)
</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>요약</strong>:</p>
<ul>
<li>구문 (1)은 <strong>복사 초기화(copy initialization)</strong></li>
<li>구문 (3)은 <strong>직접 초기화(direct initialization)</strong></li>
<li>구문 (2)와 (4)는 중괄호를 사용하는 **목록 초기화(list initialization)**에 해당합니다.</li>
<li>지정 초기자(designated initializer)는 C++20부터 사용할 수 있습니다.</li>
</ul>
</blockquote>
<hr>
<h2 id="3-초기화에-사용되는-요소들의-설명">3. 초기화에 사용되는 요소들의 설명</h2>
<ul>
<li>
<p><strong>expression</strong>:</p>
<ul>
<li>임의의 표현식을 의미합니다. 단, 괄호 없이 나열한 콤마 표현식(unparenthesized comma expressions)은 제외됩니다.</li>
</ul>
</li>
<li>
<p><strong>expression-list</strong>:</p>
<ul>
<li>표현식들을 쉼표(,)로 구분하여 나열한 목록입니다. 역시, 괄호 없이 나열된 콤마 표현식은 제외합니다.</li>
</ul>
</li>
<li>
<p><strong>initializer-list</strong>:</p>
<ul>
<li>쉼표로 구분된 초기화 절(clause)들의 목록입니다.</li>
</ul>
</li>
<li>
<p><strong>designated-initializer-list</strong>:</p>
<ul>
<li>각 초기화 절에 멤버 이름을 명시하는 초기자들의 목록입니다. (C++20부터 지원)</li>
</ul>
</li>
<li>
<p><strong>brace-enclosed initializer list</strong>:</p>
<ul>
<li>중괄호 <code>{}</code> 로 감싼 초기자 구문을 총칭하는 말입니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-초기화-구문에-따른-초기화-의미-initializer-semantics">4. 초기화 구문에 따른 초기화 의미 (Initializer Semantics)</h2>
<p>초기화가 진행되는 대상에 따라 다르게 적용됩니다.</p>
<h3 id="a-참조reference-초기화">A. 참조(reference) 초기화</h3>
<ul>
<li><strong>설명</strong>:
<ul>
<li>
<p>초기화 대상이 참조일 경우, <strong>참조 초기화(reference initialization)</strong> 규칙이 적용됩니다.</p>
</li>
<li>
<p><strong>필수</strong>: 참조는 반드시 유효한 객체를 가리키도록 초기화되어야 합니다.</p>
</li>
<li>
<p><strong>예</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref <span style="color:#f92672">=</span> x; <span style="color:#75715e">// 올바른 참조 초기화
</span></span></span></code></pre></div></li>
<li>
<p><strong>문제</strong>: 초기화하지 않은 참조는 프로그램이 잘못된 동작을 하거나 컴파일 오류를 발생시킵니다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="b-객체object-초기화">B. 객체(object) 초기화</h3>
<ul>
<li><strong>대상</strong>: 일반 변수나 객체는 초기화될 때 <strong>객체 초기화</strong>가 진행됩니다.</li>
<li><strong>T 타입의 객체</strong>에 대해:
<ol>
<li>
<p><strong>(1) 복사 초기화</strong></p>
<ul>
<li>
<p>초기화 구문이 <code>= expression</code>인 경우, <strong>복사 초기화</strong>가 진행됩니다.</p>
</li>
<li>
<p>예:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>(2) 중괄호를 사용한 초기화</strong></p>
<ul>
<li>T가 aggregate (집합체)인 경우, <strong>aggregate 초기화</strong>가 적용됩니다.
<ul>
<li>예: 배열, 구조체 등.</li>
</ul>
</li>
<li>T가 스칼라 타입(예: int, double)인 경우,<br>
<code>T x = { a };</code> 는 <code>T x = a;</code>와 동일하게 동작합니다.</li>
<li>만약 T가 aggregate가 아니면서 중괄호 초기화가 사용되었는데 해당 타입에 맞는 생성자가 없다면, 프로그램은 ill-formed (잘못된 프로그램)으로 간주됩니다.</li>
</ul>
</li>
<li>
<p><strong>(3) 직접 초기화</strong></p>
<ul>
<li>초기화 구문이 <code>( expression-list )</code>인 경우, <strong>직접 초기화</strong>가 진행됩니다.</li>
</ul>
</li>
<li>
<p><strong>(4) 목록 초기화 (C++11 이후)</strong></p>
<ul>
<li>중괄호를 사용한 형태로, <strong>list-initialization</strong>이 적용됩니다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>주의</strong>:</p>
<ul>
<li>초기화 구문에 따라 복사 초기화와 직접 초기화는 약간의 차이가 있을 수 있으며, 특히 타입 변환이나 임시 객체 생성 과정에 영향을 미칠 수 있습니다.</li>
<li>C++11부터는 목록 초기화가 도입되어 중괄호 초기화가 점점 일반적으로 사용됩니다.</li>
</ul>
</blockquote>
<hr>
<h2 id="5-예제-코드와-그-의미">5. 예제 코드와 그 의미</h2>
<p>아래 코드를 하나씩 살펴봅니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s1;           <span style="color:#75715e">// (a) 기본 초기화 (default initialization)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s2();         <span style="color:#75715e">// (b) 함수 선언! 초기화가 아님
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>; <span style="color:#75715e">// (c) 복사 초기화 (copy initialization)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s4(<span style="color:#e6db74">&#34;hello&#34;</span>);  <span style="color:#75715e">// (d) 직접 초기화 (direct initialization)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s5{<span style="color:#e6db74">&#39;a&#39;</span>};      <span style="color:#75715e">// (e) 목록 초기화 (list initialization, C++11부터)
</span></span></span></code></pre></div><ul>
<li>
<p><strong>(a) <code>std::string s1;</code></strong></p>
<ul>
<li><strong>기본 초기화(default-initialization)</strong></li>
<li>객체 <code>s1</code>은 아무 초기값 없이 생성됩니다.</li>
<li>std::string의 경우, 내부적으로 기본 생성자가 호출되어 빈 문자열(&rdquo;&quot;)이 됩니다.</li>
</ul>
</li>
<li>
<p><strong>(b) <code>std::string s2();</code></strong></p>
<ul>
<li>이것은 <strong>초기화</strong>가 아니라 함수 선언입니다.</li>
<li><code>s2</code>는 매개변수가 없고 <code>std::string</code>을 반환하는 함수로 해석됩니다.</li>
<li>이를 <strong>&ldquo;most vexing parse&rdquo;</strong> 라고 부르기도 합니다.</li>
</ul>
</li>
<li>
<p><strong>(c) <code>std::string s3 = &quot;hello&quot;;</code></strong></p>
<ul>
<li><strong>복사 초기화(copy initialization)</strong></li>
<li>&ldquo;hello&quot;라는 문자열 리터럴을 사용하여 s3를 초기화합니다.</li>
</ul>
</li>
<li>
<p><strong>(d) <code>std::string s4(&quot;hello&quot;);</code></strong></p>
<ul>
<li><strong>직접 초기화(direct initialization)</strong></li>
<li>생성자에 &ldquo;hello&quot;를 직접 전달하여 s4를 초기화합니다.</li>
</ul>
</li>
<li>
<p><strong>(e) <code>std::string s5{'a'};</code></strong></p>
<ul>
<li><strong>목록 초기화(list initialization)</strong></li>
<li>중괄호를 사용하여 s5를 초기화합니다.</li>
<li>이 경우 std::string에 대해 어떤 생성자가 호출되는지(예: 단일 문자로 구성된 문자열 등)는 타입에 따라 달라집니다.</li>
</ul>
</li>
</ul>
<p>또 다른 예로 배열과 참조 초기화:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>}; <span style="color:#75715e">// aggregate 초기화: 배열의 첫 두 요소가 &#39;a&#39;와 &#39;b&#39;로, 나머지는 0으로 초기화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span><span style="color:#f92672">&amp;</span> c <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>];         <span style="color:#75715e">// 참조 초기화: c는 배열 a의 첫 번째 요소를 참조
</span></span></span></code></pre></div><ul>
<li>배열 <code>a</code>는 중괄호를 사용하여 aggregate 초기화됩니다.</li>
<li>참조 <code>c</code>는 배열의 첫 번째 요소 <code>a[0]</code>를 가리키도록 초기화됩니다.</li>
</ul>
<hr>
<h2 id="6-비지역-변수non-local-variables-초기화">6. 비지역 변수(Non-local variables) 초기화</h2>
<p>비지역 변수란 전역 변수나 네임스페이스 범위, 또는 정적/스레드 로컬(static/thread-local) 변수를 말합니다.</p>
<h3 id="a-비지역-변수의-초기화-시점">A. 비지역 변수의 초기화 시점</h3>
<ul>
<li>**정적 저장 기간(static storage duration)**을 가지는 변수들은 프로그램 시작 시, <code>main</code> 함수 실행 전에 초기화됩니다.</li>
<li><strong>스레드 로컬(thread-local storage)</strong> 변수들은 각 스레드가 시작될 때 초기화되며, 스레드 함수가 실행되기 전에 이루어집니다.</li>
</ul>
<h3 id="b-초기화-과정은-두-단계로-나뉩니다">B. 초기화 과정은 두 단계로 나뉩니다</h3>
<ol>
<li>
<p><strong>정적 초기화 (Static initialization)</strong></p>
<ul>
<li><strong>1) 상수 초기화 (Constant initialization)</strong>:
<ul>
<li>가능한 경우, 컴파일 타임에 상수 값으로 초기화됩니다.</li>
<li>컴파일러는 미리 계산된 초기 값(객체 표현)을 프로그램 이미지에 저장할 수 있습니다.</li>
</ul>
</li>
<li><strong>2) 0으로 초기화 (Zero initialization)</strong>:
<ul>
<li>상수 초기화가 불가능한 경우, 정적 및 스레드 로컬 변수들은 먼저 0으로 초기화됩니다.</li>
<li>0으로 초기화된 변수들은 보통 프로그램의 <code>.bss</code> 섹션에 위치하며, 프로그램 로딩 시 운영체제가 이 영역을 0으로 채웁니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>동적 초기화 (Dynamic initialization)</strong></p>
<ul>
<li>정적 초기화가 완료된 후, 나머지 동적 초기화가 진행됩니다.</li>
<li>동적 초기화에는 다음 세 가지 유형이 있습니다.</li>
</ul>
<p><strong>(1) 순서가 정해지지 않은(unordered) 동적 초기화</strong></p>
<ul>
<li>적용 대상: 주로 클래스 템플릿의 정적 데이터 멤버나 변수 템플릿(특수화되지 않은 경우, C++14부터 적용)</li>
<li>이들 변수의 초기화 순서는 다른 동적 초기화들과는 indeterminately(불특정하게) 순서가 정해집니다.</li>
<li>단, 프로그램이 변수 초기화 전에 스레드를 시작하는 경우 C++17부터는 &ldquo;unsequenced&quot;로 초기화됩니다.</li>
</ul>
<p><strong>(2) 부분 순서(partially-ordered) 동적 초기화</strong></p>
<ul>
<li>적용 대상: inline 변수 중 암시적 또는 명시적 인스턴스화되지 않은 특수화가 아닌 변수들</li>
<li>한 번에 한 번, 정의된 순서에 따라 초기화 순서가 결정됩니다.</li>
<li>한 번의 번역 단위(translation unit) 내에서, 어떤 변수 V가 항상 W보다 먼저 정의되면 V의 초기화가 W보다 먼저 이루어집니다.</li>
<li>(C++17부터 적용)</li>
</ul>
<p><strong>(3) 순서가 정해진(ordered) 동적 초기화</strong></p>
<ul>
<li>적용 대상: 위의 두 경우에 해당하지 않는 모든 비지역 변수들</li>
<li>한 번의 번역 단위 내에서, 소스 코드에 나타난 순서대로 초기화가 진행됩니다.</li>
<li>서로 다른 번역 단위 간에는 초기화 순서가 <strong>불특정(indeterminately sequenced)</strong> 입니다.</li>
<li>스레드 로컬 변수의 경우, 다른 번역 단위 간에는 초기화 순서가 <strong>unsequenced</strong> 됩니다.</li>
</ul>
</li>
</ol>
<ul>
<li><strong>예외 처리</strong>:
<ul>
<li>만약 비지역 변수(정적 또는 스레드 로컬)의 초기화 도중 예외가 발생하면, <code>std::terminate</code>가 호출됩니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-조기dynamic-초기화early-dynamic-initialization">7. 조기(dynamic) 초기화(Early dynamic initialization)</h2>
<ul>
<li>
<p><strong>개념</strong>:<br>
컴파일러는 아래 조건을 만족할 경우, 동적 초기화를 정적 초기화 단계에서 미리(컴파일 타임에) 수행할 수 있습니다.</p>
</li>
<li>
<p><strong>조건</strong>:</p>
<ol>
<li>동적 초기화가 다른 네임스페이스 범위 객체의 값을 변경하지 않아야 합니다.</li>
<li>정적 초기화 버전이 동적 초기화를 수행했을 때와 동일한 값을 산출해야 합니다.</li>
</ol>
</li>
<li>
<p><strong>결과</strong>:</p>
<ul>
<li>예를 들어, 어떤 객체 <code>o1</code>의 초기화 과정에서 같은 번역 단위 내의 <code>o2</code>에 접근한다면,<br>
컴파일러가 <code>o2</code>를 정적으로 초기화할 수 있으면, <code>o2</code>는 완전히 초기화된 상태의 값이거나 단순히 0으로 초기화된 상태일 수 있으며, 이는 명확하지 않습니다(불특정).</li>
</ul>
</li>
<li>
<p><strong>예제</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">fd</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1.0</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">double</span> d1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> d2 <span style="color:#f92672">=</span> d1; <span style="color:#75715e">// d1이 동적 초기화되었으면 0.0, 아니면 1.0 등으로 초기화될 수 있음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> d1 <span style="color:#f92672">=</span> fd(); <span style="color:#75715e">// d1은 1.0으로 초기화; 정적 초기화될 수도, 동적 초기화될 수도 있음.
</span></span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="8-지연된-동적-초기화deferred-dynamic-initialization">8. 지연된 동적 초기화(Deferred dynamic initialization)</h2>
<ul>
<li>
<p><strong>개념</strong>:</p>
<ul>
<li>일부 구현에서는 동적 초기화를 <code>main</code> 함수의 첫 문장 이전에 수행할 수도 있고,</li>
<li>또는 <code>main</code> 함수(혹은 스레드 초기 함수)의 첫 문장 이후로 지연시킬 수도 있습니다.</li>
</ul>
</li>
<li>
<p><strong>규칙 (C++17부터)</strong>:</p>
<ul>
<li><strong>비 inline 변수</strong>:
<ul>
<li>만약 동적 초기화가 <code>main</code> 함수 시작 후로 지연된다면, 같은 번역 단위 내에서 해당 변수를 **ODR-사용(One Definition Rule 사용)**하기 전에 초기화가 이루어집니다.</li>
<li>만약 번역 단위 내의 변수나 함수가 전혀 사용되지 않으면, 그 번역 단위에 정의된 비지역 변수들은 아예 초기화되지 않을 수도 있습니다(동적 라이브러리의 on-demand 초기화와 유사).</li>
</ul>
</li>
<li><strong>inline 변수</strong>:
<ul>
<li>inline 변수의 경우, 해당 변수가 ODR-사용되기 전에 초기화가 이루어집니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>여러 파일에 걸친 예제</strong>:<br>
예제 코드에서는 서로 다른 번역 단위(File 1, File 2, File 3)에서 변수 <code>a</code>와 <code>b</code>의 초기화 순서에 따라,</p>
<ul>
<li>만약 <code>a</code>가 <code>main</code> 전에 초기화된다면, <code>A::A()</code> 안에서 <code>b</code>가 아직 초기화되지 않았을 수 있습니다.</li>
<li>반면, <code>a</code>가 <code>main</code> 이후에 초기화(ODR-사용에 의해)된다면, <code>b</code>도 초기화된 후에 사용됩니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="9-블록-스코프static-local-변수">9. 블록 스코프(static local) 변수</h2>
<ul>
<li><strong>설명</strong>:
<ul>
<li>함수 내부(또는 블록 내)에서 <code>static</code> 또는 <code>thread_local</code>로 선언된 변수들은 <strong>지역 정적 변수</strong>라고 합니다.</li>
<li>이들 변수의 초기화에 관한 규칙은 별도로 다루어지며, 보통 해당 블록에 처음 도달했을 때 초기화가 수행됩니다.</li>
</ul>
</li>
<li><strong>참고</strong>:
<ul>
<li>블록 스코프 변수는 전역 변수와 달리, 외부 또는 내부 링케이지(external or internal linkage)를 갖는 선언에서는 초기화자가 허용되지 않습니다.</li>
<li>이런 경우 <code>extern</code> 선언을 통해 정의와 분리하여 초기화해야 합니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="10-클래스-멤버-초기화">10. 클래스 멤버 초기화</h2>
<ul>
<li><strong>비정적 데이터 멤버(non-static data members)</strong>
<ul>
<li>클래스 내부에서, 비정적 데이터 멤버들은 두 가지 방식으로 초기화할 수 있습니다.
<ol>
<li><strong>생성자 멤버 초기화 리스트</strong>:
<ul>
<li>생성자의 콜론(:) 뒤에 멤버들을 초기화하는 방식입니다.</li>
</ul>
</li>
<li><strong>기본 멤버 초기값(default member initializer)</strong>:
<ul>
<li>클래스 정의 내에서 멤버 변수를 선언할 때, 등호(<code>=</code>)나 중괄호를 사용하여 초기값을 부여하는 방식입니다.</li>
</ul>
</li>
</ol>
</li>
<li><strong>우선순위</strong>:
<ul>
<li>만약 둘 다 존재한다면, 생성자 멤버 초기화 리스트에 명시된 초기값이 우선합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-소멸-순서">11. 소멸 순서</h2>
<ul>
<li><strong>참고</strong>:
<ul>
<li>비지역 변수의 소멸 순서는 C++ 표준 라이브러리의 <code>std::exit</code> 문서에 설명되어 있습니다.</li>
<li>정적 객체들은 프로그램 종료 시, 생성 순서의 역순으로 소멸됩니다.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="최종-정리">최종 정리</h2>
<p>C++ 초기화는 매우 다양한 구문과 규칙이 있으며, 초기화 방법에 따라 다음과 같이 분류할 수 있습니다.</p>
<ol>
<li><strong>변수 선언 시 초기화</strong>
<ul>
<li>복사 초기화, 직접 초기화, 목록 초기화, 지정 초기자 등을 사용할 수 있습니다.</li>
</ul>
</li>
<li><strong>참조 초기화</strong>
<ul>
<li>반드시 유효한 객체를 가리키도록 초기화되어야 하며, 임시 객체에 바인딩할 수 없음.</li>
</ul>
</li>
<li><strong>비지역(전역, 네임스페이스, static, thread_local) 변수 초기화</strong>
<ul>
<li>두 단계(정적 초기화와 동적 초기화)로 진행됩니다.</li>
<li>정적 초기화에서는 상수 초기화와 0 초기화가 수행됩니다.</li>
<li>동적 초기화는 unordered, partially-ordered, ordered 세 가지 방식으로 진행되며, 번역 단위 간 순서는 보장되지 않습니다.</li>
</ul>
</li>
<li><strong>조기(dynamic) 초기화와 지연 초기화</strong>
<ul>
<li>컴파일러가 조건을 만족하면 동적 초기화를 정적으로 미리 수행할 수 있으며,</li>
<li>또는 프로그램 실행 도중(ODR-사용 시점)에 지연시킬 수도 있습니다.</li>
</ul>
</li>
<li><strong>클래스 멤버 초기화</strong>
<ul>
<li>생성자 초기화 리스트 또는 기본 멤버 초기값을 통해 초기화합니다.</li>
</ul>
</li>
</ol>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on My Test Site</title>
    <link>http://localhost:1313/tags/design/</link>
    <description>Recent content in Design on My Test Site</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 20 Aug 2025 16:00:56 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>계층 기반 폴더 구조 vs 서비스 단위 기반 폴더 구조</title>
      <link>http://localhost:1313/02.inbox/%EA%B3%84%EC%B8%B5-%EA%B8%B0%EB%B0%98-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0-vs-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%8B%A8%EC%9C%84-%EA%B8%B0%EB%B0%98-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0/</link>
      <pubDate>Wed, 20 Aug 2025 16:00:56 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EA%B3%84%EC%B8%B5-%EA%B8%B0%EB%B0%98-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0-vs-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%8B%A8%EC%9C%84-%EA%B8%B0%EB%B0%98-%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0/</guid>
      <description>&lt;p&gt;좋은 질문입니다. &lt;strong&gt;DTO, Repository, Domain, Service&lt;/strong&gt; 와 같은 &lt;strong&gt;계층 기반 폴더 구조&lt;/strong&gt;(Layered Architecture)와 &lt;strong&gt;서비스 단위 기반 폴더 구조&lt;/strong&gt;(Vertical Slice / Feature-based Architecture) 중 어느 것이 더 나은지는 &lt;strong&gt;프로젝트의 규모, 팀 구조, 유지보수성, 확장성&lt;/strong&gt; 등에 따라 달라집니다.&lt;/p&gt;&#xA;&lt;p&gt;아래에서 두 방식의 특징과 장단점을 비교하고, 어떤 상황에서 어떤 방식이 적합한지 정리해 드릴게요.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-1-계층-기반-구조-layered--horizontal-architecture&#34;&gt;✅ 1. &lt;strong&gt;계층 기반 구조 (Layered / Horizontal Architecture)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;src/&#xA;├── dto/&#xA;│   ├── UserRequestDto.java&#xA;│   └── UserResponseDto.java&#xA;├── domain/&#xA;│   ├── User.java&#xA;│   └── UserStatus.java&#xA;├── repository/&#xA;│   └── UserRepository.java&#xA;├── service/&#xA;│   └── UserService.java&#xA;├── controller/&#xA;│   └── UserController.java&#xA;└── config/&#xA;    └── DatabaseConfig.java&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-장점&#34;&gt;✅ 장점&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;일관성 있는 구조&lt;/strong&gt;: 모든 개발자가 동일한 위치에서 동일한 타입의 클래스를 찾을 수 있음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;초기 개발이 쉬움&lt;/strong&gt;: 특히 작은 프로젝트나 학습용 프로젝트에 적합.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Spring Boot 등의 프레임워크와 자연스럽게 맞음&lt;/strong&gt;: MVC 패턴과 잘 어울림.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;-단점&#34;&gt;❌ 단점&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;변경이 어렵다&lt;/strong&gt;: 하나의 기능을 수정할 때 여러 패키지를 왔다갔다 해야 함 (예: 유저 생성 기능 수정 시 controller → service → repository → dto 모두 확인).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;결합도 증가&lt;/strong&gt;: 모든 기능이 동일한 계층에 몰려 있어, 관련 없는 기능들끼리 묶임.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;대규모 프로젝트에서 관리 어려움&lt;/strong&gt;: 기능이 많아질수록 파일 수가 많아지고, 관련 코드를 찾기 어려워짐.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-2-서비스기능-단위-구조-vertical-slice--feature-based-architecture&#34;&gt;✅ 2. &lt;strong&gt;서비스(기능) 단위 구조 (Vertical Slice / Feature-based Architecture)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;src/&#xA;├── user/&#xA;│   ├── User.java&#xA;│   ├── UserRepository.java&#xA;│   ├── UserService.java&#xA;│   ├── UserController.java&#xA;│   ├── UserRequestDto.java&#xA;│   └── UserResponseDto.java&#xA;├── order/&#xA;│   ├── Order.java&#xA;│   ├── OrderService.java&#xA;│   └── OrderController.java&#xA;└── common/&#xA;    ├── config/&#xA;    └── exception/&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-장점-1&#34;&gt;✅ 장점&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;기능 단위로 코드가 묶여 있어 유지보수 용이&lt;/strong&gt;: 유저 관련 기능은 &lt;code&gt;user/&lt;/code&gt; 폴더 안에 모두 있음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;변경이 쉬움&lt;/strong&gt;: 기능 하나를 수정할 때 관련된 모든 코드를 한 폴더에서 찾을 수 있음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;팀 기반 개발에 유리&lt;/strong&gt;: 팀이 기능 단위로 분업하기 쉬움 (예: A팀은 user, B팀은 order 담당).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;확장성 좋음&lt;/strong&gt;: 새 기능 추가 시 폴더 하나 생성하면 됨.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;-단점-1&#34;&gt;❌ 단점&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;중복 가능성&lt;/strong&gt;: 공통 로직(예: DTO, 유틸)이 각 폴더에 중복될 수 있음 → &lt;code&gt;common&lt;/code&gt; 또는 &lt;code&gt;shared&lt;/code&gt; 패키지로 해결 필요.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;초기 설계가 중요&lt;/strong&gt;: 공통 모듈과 기능 모듈의 경계를 잘 설정해야 함.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;익숙하지 않은 구조&lt;/strong&gt;: 전통적인 계층 구조에 익숙한 개발자에게는 어색할 수 있음.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-결론-어떤-걸-선택해야-할까&#34;&gt;✅ 결론: 어떤 걸 선택해야 할까?&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;프로젝트 유형&lt;/th&gt;&#xA;          &lt;th&gt;추천 구조&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;작은 프로젝트, 학습용, MVP&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;✅ 계층 기반 구조 (간단하고 직관적)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;중대형 프로젝트, 장기 운영, 팀 개발&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;✅ &lt;strong&gt;서비스/기능 단위 구조&lt;/strong&gt; (유지보수성 ↑)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;도메인 중심 설계(DDD) 적용&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;✅ 기능 단위 + bounded context 기반 구성&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;마이크로서비스 아키텍처&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;✅ 각 서비스 내부는 기능 단위 구조 권장&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-보완-전략-하이브리드-접근&#34;&gt;🔁 보완 전략 (하이브리드 접근)&lt;/h3&gt;&#xA;&lt;p&gt;실제로는 &lt;strong&gt;하이브리드&lt;/strong&gt;로 구성하는 경우도 많습니다:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

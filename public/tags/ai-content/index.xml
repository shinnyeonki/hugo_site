<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ai-Content on My Test Site</title>
    <link>http://localhost:1313/tags/ai-content/</link>
    <description>Recent content in Ai-Content on My Test Site</description>
    <generator>Hugo</generator>
    <language>ko-KR</language>
    <lastBuildDate>Thu, 23 Oct 2025 04:34:07 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/ai-content/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>university algorizm</title>
      <link>http://localhost:1313/university-algorizm/</link>
      <pubDate>Sun, 19 Oct 2025 18:41:43 +0900</pubDate>
      <guid>http://localhost:1313/university-algorizm/</guid>
      <description>&lt;h3 id=&#34;제3장-정렬&#34;&gt;제3장: 정렬&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;배열을 크기에 기초해 분할 후 합쳐서 정렬&#xA;&lt;ol&gt;&#xA;&lt;li&gt;크기가 1인 배열과 (n - 1)인 배열로 분할 : 삽입 정렬&lt;/li&gt;&#xA;&lt;li&gt;크기가 𝑛/2인 두 개의 배열로 분할 : 합병 정렬&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;배열을 특정 값에 기초하여 분할 후 합쳐서 정렬&#xA;&lt;ol&gt;&#xA;&lt;li&gt;최솟값에 기초하여 분할 : 선택 정렬, 힙 정렬&lt;/li&gt;&#xA;&lt;li&gt;기준 값(예: 첫 번째 값)에 기초하여 분할 : 빠른 정렬&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20251019184156-1760866916046-image.png&#34; alt=&#34; (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;네, 제공해주신 알고리즘 슬라이드(19~24장) 내용을 바탕으로 삽입 정렬(Insertion Sort)에 대해 30,000자 이상으로 매우 상세하고 단계적으로 설명해 드리겠습니다. C++ 예시 코드와 함께 각 개념을 깊이 있게 다루겠습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP</title>
      <link>http://localhost:1313/aop/</link>
      <pubDate>Sun, 19 Oct 2025 16:27:14 +0900</pubDate>
      <guid>http://localhost:1313/aop/</guid>
      <description>&lt;p&gt;&lt;strong&gt;AOP&lt;/strong&gt;(Aspect-Oriented Programming, &lt;strong&gt;관점 지향 프로그래밍&lt;/strong&gt;)는 소프트웨어 설계에서 &lt;strong&gt;횡단 관심사&lt;/strong&gt;(Cross-cutting Concerns)를 효과적으로 분리하고 모듈화하기 위한 프로그래밍 패러다임입니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-핵심-아이디어&#34;&gt;🔍 핵심 아이디어&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;문제&lt;/strong&gt;: 로깅, 보안, 트랜잭션, 예외 처리 같은 기능은 &lt;strong&gt;여러 모듈에 걸쳐 중복&lt;/strong&gt;되며,&lt;br&gt;&#xA;이로 인해 &lt;strong&gt;핵심 비즈니스 로직이 흐려지고&lt;/strong&gt;, &lt;strong&gt;유지보수가 어려워집니다&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;해결&lt;/strong&gt;: AOP는 이런 &lt;strong&gt;공통 관심사를 별도의 &amp;ldquo;관점&lt;/strong&gt;(Aspect)으로 추출하여,&lt;br&gt;&#xA;원래 코드(핵심 로직)와 &lt;strong&gt;분리해서 관리&lt;/strong&gt;할 수 있게 해줍니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;💡 AOP는 &lt;strong&gt;OOP&lt;/strong&gt;(객체 지향 프로그래밍)를 &lt;strong&gt;보완&lt;/strong&gt;하는 개념입니다.&lt;br&gt;&#xA;OOP는 &amp;ldquo;무엇을 하는가?&amp;quot;(객체와 책임)에 집중한다면,&lt;br&gt;&#xA;AOP는 &amp;ldquo;언제, 어디서 공통 동작을 수행할 것인가?&amp;ldquo;에 집중합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spec Driven Development</title>
      <link>http://localhost:1313/spec-driven-development/</link>
      <pubDate>Mon, 13 Oct 2025 13:36:25 +0900</pubDate>
      <guid>http://localhost:1313/spec-driven-development/</guid>
      <description>&lt;h2 id=&#34;권력의-역전&#34;&gt;권력의 역전&lt;/h2&gt;&#xA;&lt;p&gt;수십 년간 코드가 왕이었습니다. 명세는 코드를 보조하는 역할을 했습니다. 코딩이라는 &amp;ldquo;진짜 작업&amp;quot;이 시작되면 지었다가 허물어버리는 비계와 같았습니다. 우리는 개발을 안내하기 위해 제품 요구사항 문서(PRD)를 작성했고, 구현에 정보를 제공하기 위해 설계 문서를 만들었으며, 아키텍처를 시각화하기 위해 다이어그램을 그렸습니다. 하지만 이것들은 항상 코드 자체에 종속적이었습니다. 코드가 진실이었습니다. 다른 모든 것은 기껏해야 좋은 의도에 불과했습니다. 코드는 진실의 원천이었고, 코드가 발전함에 따라 명세는 그 속도를 거의 따라가지 못했습니다. 자산(코드)과 구현이 하나로 묶여 있기 때문에, 코드로부터 빌드하지 않고서는 병렬적인 구현을 갖기란 쉽지 않습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>디버거 cli 명령어 모음</title>
      <link>http://localhost:1313/02.inbox/%EB%94%94%EB%B2%84%EA%B1%B0-cli-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C/</link>
      <pubDate>Sat, 11 Oct 2025 13:27:45 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EB%94%94%EB%B2%84%EA%B1%B0-cli-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C/</guid>
      <description>&lt;h2 id=&#34;gdb&#34;&gt;GDB&lt;/h2&gt;&#xA;&lt;h3 id=&#34;-기본-실행-및-종료&#34;&gt;🔹 &lt;strong&gt;기본 실행 및 종료&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;gdb &amp;lt;executable&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;실행 파일로 GDB 시작&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;run&lt;/code&gt; 또는 &lt;code&gt;r&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;프로그램 실행 (인자: &lt;code&gt;run arg1 arg2&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;quit&lt;/code&gt; 또는 &lt;code&gt;q&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;GDB 종료&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-중단점-breakpoint&#34;&gt;🔹 &lt;strong&gt;중단점 (Breakpoint)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;break main.cpp:10&lt;/code&gt; 또는 &lt;code&gt;b main.cpp:10&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;파일의 특정 라인에 중단점 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;break main&lt;/code&gt; 또는 &lt;code&gt;b main&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;함수 이름에 중단점 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;info breakpoints&lt;/code&gt; 또는 &lt;code&gt;i b&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 중단점 목록 보기&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;delete 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;ID가 1인 중단점 삭제&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;disable 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;중단점 비활성화&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;enable 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;중단점 활성화&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;clear main.cpp:10&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 위치의 중단점 제거&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-스텝-실행-stepping&#34;&gt;🔹 &lt;strong&gt;스텝 실행 (Stepping)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;step&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;한 줄 실행 (함수 내부로 들어감)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;n&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;한 줄 실행 (함수 내부로 안 들어감)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 함수 끝까지 실행 후 반환&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;continue&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;다음 중단점까지 실행&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-변수-및-메모리-보기&#34;&gt;🔹 &lt;strong&gt;변수 및 메모리 보기&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;print &amp;lt;var&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;p &amp;lt;var&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;변수 값 출력 (식 평가 가능)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;display &amp;lt;var&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;매 스텝마다 자동으로 변수 출력&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;undisplay 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;display 목록에서 제거&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;x/16xb 0x12345678&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;메모리 덤프 (&lt;code&gt;x/[count][format][size] address&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;set variable x = 10&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;변수 값 변경&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-스택-및-프레임&#34;&gt;🔹 &lt;strong&gt;스택 및 프레임&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;backtrace&lt;/code&gt; 또는 &lt;code&gt;bt&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;콜 스택 출력&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;frame 2&lt;/code&gt; 또는 &lt;code&gt;f 2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 프레임으로 이동&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;up&lt;/code&gt; / &lt;code&gt;down&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;스택 프레임 위/아래로 이동&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-프로세스-및-스레드&#34;&gt;🔹 &lt;strong&gt;프로세스 및 스레드&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;info threads&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 스레드 목록&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thread 2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 스레드로 전환&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;디버그 중인 프로세스 강제 종료&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-도움말-및-설정&#34;&gt;🔹 &lt;strong&gt;도움말 및 설정&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;help&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;전체 도움말&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;help &amp;lt;command&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 명령어에 대한 도움말&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;set args arg1 arg2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;실행 인자 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;run &amp;lt; input.txt&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;표준 입력 리다이렉션 (쉘 수준에서 처리)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;set environment VAR=value&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;환경 변수 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-lldb--gdb-명령어-비교-참고&#34;&gt;🔹 &lt;strong&gt;LLDB ↔ GDB 명령어 비교 (참고)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;LLDB&lt;/th&gt;&#xA;          &lt;th&gt;GDB&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;b main&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;b main&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;br list&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;info breakpoints&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;v&lt;/code&gt; 또는 &lt;code&gt;frame variable&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;info locals&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;expr x = 5&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;set variable x = 5&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;process launch&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;run&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;memory read&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;x/...&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;settings set target.run-args ...&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;set args ...&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-팁&#34;&gt;💡 팁&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GDB는 &lt;code&gt;.gdbinit&lt;/code&gt; 파일을 통해 시작 시 자동으로 명령어를 실행할 수 있습니다.&lt;/li&gt;&#xA;&lt;li&gt;최신 GDB(8.0+)는 Python 스크립팅을 지원하여 고급 디버깅이 가능합니다.&lt;/li&gt;&#xA;&lt;li&gt;ARM64 환경에서도 잘 작동하지만, 크로스 디버깅 시 &lt;code&gt;gdb-multiarch&lt;/code&gt;나 대상 아키텍처 전용 GDB를 사용해야 할 수 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;lldb&#34;&gt;LLDB&lt;/h2&gt;&#xA;&lt;h3 id=&#34;-기본-실행-및-종료-1&#34;&gt;🔹 &lt;strong&gt;기본 실행 및 종료&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;lldb &amp;lt;executable&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;실행 파일로 LLDB 시작&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;run&lt;/code&gt; 또는 &lt;code&gt;r&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;프로그램 실행&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;process launch&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;프로그램 실행 (옵션 사용 가능)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;quit&lt;/code&gt; 또는 &lt;code&gt;q&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;LLDB 종료&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-중단점-breakpoint-1&#34;&gt;🔹 &lt;strong&gt;중단점 (Breakpoint)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint set --file main.cpp --line 10&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;파일의 특정 라인에 중단점 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;b main.cpp:10&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;위와 동일 (간단한 형태)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint set --name main&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;함수 이름에 중단점 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;b main&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;위와 동일&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint list&lt;/code&gt; 또는 &lt;code&gt;br list&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 중단점 목록 보기&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint delete 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;ID가 1인 중단점 삭제&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint disable 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;중단점 비활성화&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;breakpoint enable 1&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;중단점 활성화&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-스텝-실행-stepping-1&#34;&gt;🔹 &lt;strong&gt;스텝 실행 (Stepping)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;step&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;한 줄 실행 (함수 내부로 들어감)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;n&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;한 줄 실행 (함수 내부로 안 들어감)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 함수 끝까지 실행 후 반환&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;continue&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;다음 중단점까지 실행&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-변수-및-메모리-보기-1&#34;&gt;🔹 &lt;strong&gt;변수 및 메모리 보기&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;frame variable&lt;/code&gt; 또는 &lt;code&gt;v&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 프레임의 지역 변수 출력&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;print &amp;lt;var&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;p &amp;lt;var&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;변수 값 출력 (식 평가 가능)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;expr &amp;lt;expression&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;표현식 평가 및 실행 (변수 수정도 가능)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;memory read --size 1 --count 16 0x12345678&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;메모리 덤프&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-스택-및-프레임-1&#34;&gt;🔹 &lt;strong&gt;스택 및 프레임&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;bt&lt;/code&gt; 또는 &lt;code&gt;thread backtrace&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;콜 스택 출력&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;frame select 2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 프레임으로 이동&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;up&lt;/code&gt; / &lt;code&gt;down&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;스택 프레임 위/아래로 이동&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-프로세스-및-스레드-1&#34;&gt;🔹 &lt;strong&gt;프로세스 및 스레드&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thread list&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 스레드 목록&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;process status&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 프로세스 상태 확인&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;process kill&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;디버그 중인 프로세스 강제 종료&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-도움말-및-설정-1&#34;&gt;🔹 &lt;strong&gt;도움말 및 설정&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;명령어&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;help&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;전체 도움말&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;help &amp;lt;command&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;특정 명령어에 대한 도움말&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;settings set target.run-args arg1 arg2&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;실행 인자 설정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;settings set target.input-path input.txt&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;표준 입력 리다이렉션&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-gdb--lldb-명령어-비교-참고&#34;&gt;🔹 &lt;strong&gt;GDB ↔ LLDB 명령어 비교 (참고)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;GDB&lt;/th&gt;&#xA;          &lt;th&gt;LLDB&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;run&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;run&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;break main&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;b main&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;step&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;step&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;next&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;next&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;print x&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;p x&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;info breakpoints&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;br list&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;bt&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;bt&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>css hidden 대신 transition</title>
      <link>http://localhost:1313/temp/css-hidden-%EB%8C%80%EC%8B%A0-transition/</link>
      <pubDate>Sat, 27 Sep 2025 06:18:15 +0900</pubDate>
      <guid>http://localhost:1313/temp/css-hidden-%EB%8C%80%EC%8B%A0-transition/</guid>
      <description>&lt;p&gt;Tailwind CSS를 사용한다고 가정하고, 좌우 사이드바(왼쪽 사이드바와 오른쪽 사이드바)가 각각 화면 왼쪽/오른쪽 밖에 숨어 있다가, 필요할 때 애니메이션과 함께 나타나도록 설정하는 과정입니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-요구사항-요약&#34;&gt;🔧 요구사항 요약&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;좌우 사이드바에&lt;/strong&gt; 다음 클래스를 추가:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;transition-transform&lt;/code&gt;: &lt;code&gt;transform&lt;/code&gt; 속성에 대한 트랜지션(애니메이션)을 활성화&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;duration-300&lt;/code&gt;: 트랜지션 지속 시간을 300ms로 설정&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;초기 상태에서&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;왼쪽 사이드바는 화면 &lt;strong&gt;왼쪽 밖&lt;/strong&gt;에 위치 → &lt;code&gt; -translate-x-full&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;오른쪽 사이드바는 화면 &lt;strong&gt;오른쪽 밖&lt;/strong&gt;에 위치 → &lt;code&gt; translate-x-full&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;기존의 &lt;code&gt;hidden&lt;/code&gt; 클래스는 제거&lt;/strong&gt;&lt;br&gt;&#xA;→ &lt;code&gt;hidden&lt;/code&gt;은 &lt;code&gt;display: none&lt;/code&gt;을 적용하므로, 애니메이션이 작동하지 않음&lt;/p&gt;</description>
    </item>
    <item>
      <title>nextInt vs nextLine</title>
      <link>http://localhost:1313/temp/nextint-vs-nextline/</link>
      <pubDate>Fri, 19 Sep 2025 16:08:18 +0900</pubDate>
      <guid>http://localhost:1313/temp/nextint-vs-nextline/</guid>
      <description>&lt;p&gt;완벽히 이해했습니다.&lt;br&gt;&#xA;아래는 &lt;strong&gt;기존의 틀과 구조를 100% 유지하면서&lt;/strong&gt;,&lt;br&gt;&#xA;&lt;strong&gt;각 단계에서 &lt;code&gt;nextInt()&lt;/code&gt;와 &lt;code&gt;nextLine()&lt;/code&gt;의 동작 차이를 병렬로 설명&lt;/strong&gt;한 버전입니다.&lt;br&gt;&#xA;→ &lt;strong&gt;동일한 입력(&lt;code&gt;25\n&lt;/code&gt;)이 주어졌을 때, 두 메서드가 어떻게 다른 방식으로 버퍼를 소비하고 커서를 이동시키는지&lt;/strong&gt;를 &lt;strong&gt;계층별로 명확히 대조&lt;/strong&gt;합니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-완전한-데이터-흐름-사용자-입력--scanner-내부-버퍼&#34;&gt;🧩 완전한 데이터 흐름: 사용자 입력 → Scanner 내부 버퍼&lt;/h2&gt;&#xA;&lt;h3 id=&#34;시스템-프로그래밍--터미널-관점--nextint-vs-nextline-비교-포함&#34;&gt;(시스템 프로그래밍 + 터미널 관점 — &lt;code&gt;nextInt()&lt;/code&gt; vs &lt;code&gt;nextLine()&lt;/code&gt; 비교 포함)&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;✍️ &lt;strong&gt;목표&lt;/strong&gt;: 사용자가 키보드로 &lt;code&gt;25&lt;/code&gt;를 치고 &lt;code&gt;Enter&lt;/code&gt;를 누른 순간부터,&lt;br&gt;&#xA;Java의 &lt;code&gt;Scanner.nextInt()&lt;/code&gt; 또는 &lt;code&gt;Scanner.nextLine()&lt;/code&gt;이 어떻게 다른 방식으로 &lt;code&gt;25\n&lt;/code&gt;을 처리하는지&lt;br&gt;&#xA;&lt;strong&gt;모든 계층을 투명하게 추적 + 비교&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>코어 덤프(Core Dump)</title>
      <link>http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/</link>
      <pubDate>Tue, 09 Sep 2025 23:13:33 +0900</pubDate>
      <guid>http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/</guid>
      <description>&lt;h2 id=&#34;코어-덤프core-dump란-무엇인가---프로세스의-마지막-순간을-담은-사진&#34;&gt;코어 덤프(Core Dump)란 무엇인가? - &amp;ldquo;프로세스의 마지막 순간을 담은 사진&amp;rdquo;&lt;/h2&gt;&#xA;&lt;p&gt;코어 덤프(Core Dump)는 프로그래밍과 시스템 관리에서 매우 중요한 개념입니다. 가장 쉽게 비유하자면, **코어 덤프는 특정 프로그램(프로세스)이 비정상적으로 종료되는 바로 그 순간의 메모리 상태를 그대로 찍어 저장한 &amp;ldquo;스냅샷 파일&amp;rdquo;**입니다. 마치 비행기 사고 시 원인 분석을 위해 블랙박스를 회수하는 것과 같습니다.&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-코어core-라는-이름의-유래&#34;&gt;1. &amp;ldquo;코어(Core)&amp;rdquo; 라는 이름의 유래&lt;/h3&gt;&#xA;&lt;p&gt;이름이 조금 생소할 수 있습니다. &amp;ldquo;코어&amp;quot;라는 단어는 현대의 CPU 코어를 의미하는 것이 아닙니다. 이는 아주 오래전, 컴퓨터의 주기억장치로 **자기 코어 메모리(Magnetic Core Memory)**를 사용하던 시절에서 유래했습니다. 당시 메모리의 내용을 파일로 &amp;lsquo;쏟아낸다(dump)&amp;lsquo;는 의미에서 &amp;lsquo;코어 덤프&amp;rsquo;라는 용어가 탄생했고, 메모리 기술이 반도체로 바뀐 지금까지도 그 이름이 그대로 사용되고 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>signal 차이 unix(macos) vs linux</title>
      <link>http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/</link>
      <pubDate>Tue, 09 Sep 2025 23:07:14 +0900</pubDate>
      <guid>http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/</guid>
      <description>&lt;h2 id=&#34;macos와-linux의-신호signal-상세-분석&#34;&gt;macOS와 Linux의 신호(Signal) 상세 분석&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;시그널 이름&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;macOS 기본 동작&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;macOS 설명&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Linux 기본 동작&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Linux 설명 (Comment)&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;차이점 / 비고&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGHUP&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;터미널 라인 끊김&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;제어 터미널에서 끊김 감지 또는 제어 프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;설명은 유사하며, 둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGINT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로그램 인터럽트&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;키보드로부터의 인터럽트&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;유사하며, 둘 다 프로세스를 종료하며, 주로 Ctrl+C로 발생합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGQUIT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로그램 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;키보드로부터의 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성하고 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGILL&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;불법 명령어&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;불법 명령어 (Illegal Instruction)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGTRAP&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;트레이스 트랩&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;트레이스/브레이크포인트 트랩&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGABRT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로그램 중단 (이전 SIGIOT)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;abort(3)로부터의 중단 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다. Linux는 &lt;code&gt;abort(3)&lt;/code&gt;로부터 발생한다고 명시합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGEMT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;명령어 에뮬레이트 실행&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;에뮬레이터 트랩&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;차이점:&lt;/strong&gt; macOS는 코어 이미지를 생성하지만, Linux는 프로세스를 종료합니다. 이는 &amp;ldquo;에뮬레이터 트랩&amp;rdquo; 조건에 대한 다른 처리를 나타낼 수 있습니다. Linux는 이 시그널에 대한 명시적인 코어 덤프 동작이 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGFPE&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;부동 소수점 예외&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;부동 소수점 예외&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGKILL&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로그램 강제 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;강제 종료 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료하며, 포착하거나 무시할 수 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGBUS&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;버스 에러&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;버스 에러 (잘못된 메모리 접근)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGSEGV&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;세그멘테이션 위반&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;유효하지 않은 메모리 참조&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGSYS&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;코어 이미지 생성&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;존재하지 않는 시스템 콜 호출&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;잘못된 시스템 콜 (SVr4); seccomp(2) 참조&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 코어 덤프를 생성합니다. Linux는 &lt;code&gt;seccomp(2)&lt;/code&gt;에 대한 추가 컨텍스트를 제공합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGPIPE&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;리더 없는 파이프에 쓰기&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;파이프 깨짐: 리더 없는 파이프에 쓰기; pipe(7) 참조&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGALRM&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;실시간 타이머 만료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;alarm(2)로부터의 타이머 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;소프트웨어 종료 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;종료 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다. 이것은 기본 종료 시그널입니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGURG&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;소켓에 긴급 조건 발생&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Ign&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;소켓의 긴급 조건 (4.2BSD)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 시그널을 무시합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGSTOP&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;중지 (포착하거나 무시할 수 없음)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Stop&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 중지하며 포착하거나 무시할 수 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGTSTP&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;키보드로부터 발생한 중지 시그널&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Stop&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;터미널에서 입력된 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 중지하며, 주로 Ctrl+Z로 발생합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGCONT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;중지 후 계속 진행&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Cont&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;중지 후 계속 진행&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 중지된 프로세스를 계속 진행합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;자식 상태 변경됨&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Ign&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;자식 프로세스 중지 또는 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 기본적으로 시그널을 무시합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGTTIN&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;제어 터미널에서 백그라운드 읽기 시도&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Stop&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;백그라운드 프로세스를 위한 터미널 입력&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 중지합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGTTOU&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 중지&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;제어 터미널에 백그라운드 쓰기 시도&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Stop&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;백그라운드 프로세스를 위한 터미널 출력&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 중지합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGIO&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;디스크립터에서 I/O 가능 (fcntl(2) 참조)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;I/O 이제 가능 (4.2BSD)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;차이점:&lt;/strong&gt; macOS는 기본적으로 이 시그널을 무시하는 반면, Linux는 프로세스를 종료합니다. Linux는 또한 &lt;code&gt;SIGPOLL&lt;/code&gt;의 동의어라고 명시합니다. 이는 중요한 행동 차이입니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGXCPU&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;CPU 시간 제한 초과 (setrlimit(2) 참조)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;CPU 시간 제한 초과 (4.2BSD); setrlimit(2) 참조&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;차이점:&lt;/strong&gt; macOS는 프로세스를 종료하는 반면, Linux는 코어 덤프를 생성합니다. 둘 다 &lt;code&gt;setrlimit(2)&lt;/code&gt;를 인정합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGXFSZ&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;파일 크기 제한 초과 (setrlimit(2) 참조)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;파일 크기 제한 초과 (4.2BSD); setrlimit(2) 참조&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;차이점:&lt;/strong&gt; macOS는 프로세스를 종료하는 반면, Linux는 코어 덤프를 생성합니다. 둘 다 &lt;code&gt;setrlimit(2)&lt;/code&gt;를 인정합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGVTALRM&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;가상 시간 알람 (setitimer(2) 참조)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;가상 알람 시계 (4.2BSD)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGPROF&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로파일링 타이머 알람 (setitimer(2) 참조)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로파일링 타이머 만료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGWINCH&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;윈도우 크기 변경&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Ign&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;윈도우 크기 변경 시그널 (4.3BSD, Sun)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 시그널을 무시합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGINFO&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;시그널 무시&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;키보드로부터의 상태 요청&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;- (&lt;code&gt;SIGPWR&lt;/code&gt;의 동의어)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;SIGPWR&lt;/code&gt;의 동의어 (기본적으로 Term)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;차이점:&lt;/strong&gt; macOS는 &lt;code&gt;SIGINFO&lt;/code&gt;를 상태 요청(예: Ctrl+T)을 위한 별개의 무시 가능한 시그널로 처리합니다. Linux는 &lt;code&gt;SIGINFO&lt;/code&gt;를 &lt;code&gt;SIGPWR&lt;/code&gt;의 동의어로 나열하며, 이는 기본적으로 종료됩니다. 이름과 기본 동작 모두에서 중요한 차이가 있습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGUSR1&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;사용자 정의 시그널 1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;사용자 정의 시그널 1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGUSR2&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;프로세스 종료&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;사용자 정의 시그널 2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;사용자 정의 시그널 2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;둘 다 프로세스를 종료합니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGCLD&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Ign&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;SIGCHLD&lt;/code&gt;의 동의어&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; &lt;code&gt;SIGCHLD&lt;/code&gt;의 동의어입니다. macOS에는 &lt;code&gt;SIGCLD&lt;/code&gt;가 별개의 시그널로 나열되지 않습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGIOT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;IOT 트랩. &lt;code&gt;SIGABRT&lt;/code&gt;의 동의어&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; &lt;code&gt;SIGABRT&lt;/code&gt;의 동의어로 나열됩니다. macOS는 &lt;code&gt;SIGABRT&lt;/code&gt;가 &amp;ldquo;이전 SIGIOT&amp;quot;였다고 언급하지만, &lt;code&gt;SIGIOT&lt;/code&gt;를 별개의 시그널로 나열하지는 않습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGLOST&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;파일 잠금 손실 (사용되지 않음)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; 파일 잠금과 관련된 시그널이며 &amp;ldquo;사용되지 않음&amp;quot;으로 나열됩니다. macOS에는 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGPOLL&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;폴링 가능한 이벤트 (Sys V); &lt;code&gt;SIGIO&lt;/code&gt;의 동의어&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; &lt;code&gt;SIGIO&lt;/code&gt;의 동의어입니다. macOS에는 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGPWR&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;전원 장애 (System V)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; 전원 장애 이벤트에 대한 시그널입니다. Linux의 &lt;code&gt;SIGINFO&lt;/code&gt;는 이것의 동의어이며, 이는 macOS의 &lt;code&gt;SIGINFO&lt;/code&gt;와는 큰 차이입니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGSTKFLT&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Term&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;보조 프로세서의 스택 오류 (사용되지 않음)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; 보조 프로세서의 스택 오류에 대한 시그널이며 &amp;ldquo;사용되지 않음&amp;quot;으로 나열됩니다. macOS에는 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;SIGUNUSED&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;(macOS에 없음)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Core&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;code&gt;SIGSYS&lt;/code&gt;와 동의어&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Linux 전용:&lt;/strong&gt; &lt;code&gt;SIGSYS&lt;/code&gt;의 동의어입니다. macOS에는 없습니다.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;주요-차이점-요약&#34;&gt;주요 차이점 요약:&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;특정 시그널의 기본 동작:&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>android studio build sequence</title>
      <link>http://localhost:1313/android-studio-build-sequence/</link>
      <pubDate>Mon, 08 Sep 2025 15:10:44 +0900</pubDate>
      <guid>http://localhost:1313/android-studio-build-sequence/</guid>
      <description>&lt;p&gt;네, 제공해주신 Android Gradle 빌드 로그의 각 단계를 매우 자세하게 설명해 드리겠습니다. 이 로그는 Android Studio에서 &amp;lsquo;Run&amp;rsquo; 버튼을 누르거나 터미널에서 &lt;code&gt;./gradlew assembleDebug&lt;/code&gt; 명령을 실행했을 때 나타나는 과정입니다.&lt;/p&gt;&#xA;&lt;h3 id=&#34;핵심-개념-증분-빌드-incremental-build-와&#34;&gt;&lt;strong&gt;핵심 개념: 증분 빌드 (Incremental Build) 와 &lt;code&gt;UP-TO-DATE&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;로그를 이해하기 전에 가장 중요한 개념은 Gradle의 &lt;strong&gt;증분 빌드&lt;/strong&gt; 기능입니다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: Gradle은 각 작업(Task)의 입력(input)과 출력(output)을 기억합니다. 다음 빌드를 실행할 때, Gradle은 각 작업의 입력 파일(예: 소스 코드, 리소스 파일)이 마지막 빌드 이후 변경되었는지 확인합니다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;UP-TO-DATE&lt;/code&gt;의 의미&lt;/strong&gt;: 만약 입력 파일에 아무런 변경이 없다면, Gradle은 해당 작업을 다시 실행하는 대신 이전에 생성했던 출력물을 그대로 재사용합니다. 이때 로그에 &lt;code&gt;UP-TO-DATE&lt;/code&gt;라고 표시됩니다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;결과&lt;/strong&gt;: 이 기능 덕분에 코드를 전혀 수정하지 않고 다시 빌드하면, 모든 작업이 &lt;code&gt;UP-TO-DATE&lt;/code&gt;가 되어 빌드가 매우 빠르게(로그에서는 1초) 완료됩니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;빌드-단계별-상세-설명&#34;&gt;&lt;strong&gt;빌드 단계별 상세 설명&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;빌드 과정은 크게 &lt;strong&gt;리소스 처리 → 매니페스트 처리 → 코드 컴파일 → DEX 변환 → APK 패키징&lt;/strong&gt;의 순서로 진행됩니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/</link>
      <pubDate>Fri, 04 Jul 2025 06:32:40 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/</guid>
      <description>&lt;h2 id=&#34;모델-1에서-모델-2로의-진화-웹-개발-아키텍처-심층-분석&#34;&gt;모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석&lt;/h2&gt;&#xA;&lt;p&gt;현대 백엔드 개발의 핵심 철학&lt;/p&gt;&#xA;&lt;h3 id=&#34;서론-왜-아키텍처는-중요한가&#34;&gt;서론: 왜 아키텍처는 중요한가?&lt;/h3&gt;&#xA;&lt;p&gt;소프트웨어 개발은 단순히 &amp;lsquo;동작하는 코드&amp;rsquo;를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, 새로운 기술이 등장하며, 비즈니스는 확장됩니다. 이러한 변화의 파도 속에서 흔들리지 않는 견고하고 유연한 시스템을 구축하는 것, 이것이 바로 &amp;lsquo;아키텍처&amp;rsquo;의 역할입니다. 제공된 텍스트는 웹 애플리케이션 개발 아키텍처의 중요한 변곡점인 &lt;strong&gt;모델 1&lt;/strong&gt;과 &lt;strong&gt;모델 2&lt;/strong&gt;의 차이를 통해, 좋은 아키텍처가 무엇이며 어떻게 발전해 왔는지를 심도 있게 이야기하고 있습니다. 이는 단순히 기술의 변화가 아닌, &amp;lsquo;문제 해결 방식&amp;rsquo;에 대한 패러다임의 전환을 의미합니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

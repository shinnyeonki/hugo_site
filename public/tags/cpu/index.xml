<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpu on My Test Site</title>
    <link>http://localhost:1313/tags/cpu/</link>
    <description>Recent content in Cpu on My Test Site</description>
    <generator>Hugo</generator>
    <language>ko-KR</language>
    <lastBuildDate>Sun, 12 Oct 2025 15:43:22 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/cpu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RISC V 명령어 구조</title>
      <link>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/risc-v-%EB%AA%85%EB%A0%B9%EC%96%B4-%EA%B5%AC%EC%A1%B0/</link>
      <pubDate>Sat, 31 Aug 2024 09:44:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/risc-v-%EB%AA%85%EB%A0%B9%EC%96%B4-%EA%B5%AC%EC%A1%B0/</guid>
      <description>&lt;p&gt;RISC-V emulator RV32I 를 코드로 구현하기 위해 먼저 RISC-V 공식 문서를 확인하여&#xA;구현할 명령의 구조를 공부한다&lt;/p&gt;&#xA;&lt;p&gt;RISC V 의 경우 32비트인지 64 비트인지 128비트인지에 따라 RV32, RV64, RV128 로 나누어지며 기본적인 명령인 integer instruction set 을 구현하면 RV32I, RV64I, RV128I 라고 불리운다 또한 아래의 4가지 확장을 추가하여 자유롭게 가능한 명령을 추가 할 수 있다&#xA;또한 문서는 2가지로 privilige 명령과 non privilige 명령 문서가 있으며 아래는 non privilige 명령만을 설명한다&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1권, 권한 없는 사양 버전 20240411 &lt;a href=&#34;https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view?usp=drive_link&#34; class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://github.com/riscv/riscv-isa-manual/releases/tag/20240411&#34; class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;GitHub&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;2권, 권한 사양 버전 20240411 &lt;a href=&#34;https://drive.google.com/file/d/17GeetSnT5wW3xNuAHI95-SI1gPGd5sJ_/view?usp=drive_link&#34; class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://github.com/riscv/riscv-isa-manual/releases/tag/20240411&#34; class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;GitHub&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;non privilige 의 확장 명령 종류&lt;/p&gt;</description>
    </item>
    <item>
      <title>어셈블러</title>
      <link>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EC%96%B4%EC%85%88%EB%B8%94%EB%9F%AC/</link>
      <pubDate>Mon, 26 Aug 2024 06:42:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EC%96%B4%EC%85%88%EB%B8%94%EB%9F%AC/</guid>
      <description></description>
    </item>
    <item>
      <title>메모리 최대 크기</title>
      <link>http://localhost:1313/02.inbox/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EB%8C%80-%ED%81%AC%EA%B8%B0/</link>
      <pubDate>Sat, 10 Aug 2024 17:45:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EB%8C%80-%ED%81%AC%EA%B8%B0/</guid>
      <description>&lt;h2 id=&#34;문제-발생-이전&#34;&gt;문제 발생 이전&lt;/h2&gt;&#xA;&lt;p&gt;메모리의 최대 크기는 RAM 에 저장할 수 있는 bit 최대 개수를 의미한다&#xA;word 는 bus 의 크기를 이야기 한다&#xA;하지만 직접 CPU 를 만들다 보니(logisim) (&lt;a href=&#34;http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94-1/&#34; class=&#34;internal-link&#34;&gt;그래서 컴퓨터는 어떻게 동작하나요 1&lt;/a&gt;) 지금까지 나는 byte 단위로 메모리에 접근한 것이 아닌 word 단위로 접근 했었고 이것이 8비트 cpu 에서는 word 와 byte 가 운 좋게 8bit 로 일치되어 메모리 최대 크기를 계산 할 때 주소폭 크기 (data bit width = word) * 2^(address bit width) 즉 8 * 2^8 즉 2048b ~= 256B 라고 계산 했었다 답은 맞지만 16비트 32 비트로 cpu 를 개선해나가는 과정에서 문제가 발생했다&lt;/p&gt;</description>
    </item>
    <item>
      <title>그래서 컴퓨터는 어떻게 동작하나요 2</title>
      <link>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94-2/</link>
      <pubDate>Sat, 10 Aug 2024 16:37:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94-2/</guid>
      <description>&lt;p&gt;여기서 부터는 32 비트로 설계하게 된다&#xA;즉 word 가 32 비트 이다&lt;/p&gt;&#xA;&lt;h2 id=&#34;변경점&#34;&gt;변경점&lt;/h2&gt;&#xA;&lt;h3 id=&#34;ram&#34;&gt;RAM&lt;/h3&gt;&#xA;&lt;p&gt;RAM 의 경우 data bit size 는 32가 가능하지만 address bit width 의 경우 32 비트가 가능하지 않다(logisim 의 한계 4기가의 메모리는 감당하지 못한다) 그러므로 address bit width 의 경우 24 비트로 한다&lt;/p&gt;&#xA;&lt;p&gt;현대 컴퓨터에 사용하는 RAM 과 ㄱ&lt;/p&gt;&#xA;&lt;h3 id=&#34;register&#34;&gt;Register&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;IAR INSTRUCTION ADDRESS REGISTER 을 PC PROGRAM COUTER 로 표기한다&lt;/li&gt;&#xA;&lt;li&gt;레지스터의 경우 7비트에서는 2개가 존재했다&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;instruction-set&#34;&gt;Instruction set&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;8비트&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>그래서 컴퓨터는 어떻게 동작하나요 1</title>
      <link>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94-1/</link>
      <pubDate>Wed, 10 Jul 2024 00:41:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94/%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%93%A8%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94-1/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;WORD : CPU 에 의해 한번에 처리될 수 있는 비트 수&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;sr-latch&#34;&gt;SR latch&lt;/h2&gt;&#xA;&lt;p&gt;NOR 게이트를 사용한 SR 래치는 기본적인 SR 래치로, 아래와 같이 작동합니다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;두 개의 NOR 게이트를 교차 연결합니다.&lt;/li&gt;&#xA;&lt;li&gt;입력은 S(Set)와 R(Reset)입니다&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;S&lt;/th&gt;&#xA;          &lt;th&gt;R&lt;/th&gt;&#xA;          &lt;th&gt;Q (다음 상태)&lt;/th&gt;&#xA;          &lt;th&gt;¬Q (다음 상태)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;Q (이전 상태)&lt;/td&gt;&#xA;          &lt;td&gt;¬Q (이전 상태)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;불안정&lt;/td&gt;&#xA;          &lt;td&gt;불안정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;NAND 게이트를 사용한 SR 래치는 약간 다르게 동작합니다. 이 경우에는 입력을 보통 S&amp;rsquo;와 R&amp;rsquo;으로 표기합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>x86 64 CPU 레지스터(Register)의 개념 및 종류</title>
      <link>http://localhost:1313/temp/x86-64-cpu-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0register%EC%9D%98-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%A2%85%EB%A5%98/</link>
      <pubDate>Wed, 20 Mar 2024 14:24:00 +0900</pubDate>
      <guid>http://localhost:1313/temp/x86-64-cpu-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0register%EC%9D%98-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%A2%85%EB%A5%98/</guid>
      <description>&lt;p&gt;32bit, 64bit 운영체제에서 32bit, 64bit 는 레지스터 및 데이터 경로의 크기 를 의미한다.&lt;br&gt;&#xA;위 예시에서 AH 는 8bit 운영체제와 호환되는 레지스터라고 이해하면 된다. &lt;/p&gt;&#xA;&lt;p&gt; 운영체제의 발전에 따라, 수행해야할 기능이 많아지면서&lt;br&gt;&#xA;많은 정보를 다룰 수 있도록 새로운 레지스터가 추가되고, 크기도 점점 커졌다.&lt;/p&gt;&#xA;&lt;p&gt; *  E 는 Extended 의 약자. R은 왜 R인지 모르겠다..&lt;br&gt;&#xA;* CPU의 아키텍쳐에 따라 레지스터의 종류가 다를 수 있다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;범용-레지스터&#34;&gt;&lt;strong&gt;범용 레지스터&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;====&#xA;범용 레지스터는 연산 결과의 임시 저장, 산술 및 논리 연산, 주소 색인 등 다양한 용도로 사용되는 다목적 레지스터이다.&lt;br&gt;&#xA;종류는 EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, EIP 가 있다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

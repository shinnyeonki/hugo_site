<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>University on My Test Site</title>
    <link>http://localhost:1313/tags/university/</link>
    <description>Recent content in University on My Test Site</description>
    <generator>Hugo</generator>
    <language>ko-KR</language>
    <lastBuildDate>Thu, 16 Oct 2025 16:04:40 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/university/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>university mobile programming</title>
      <link>http://localhost:1313/university-mobile-programming/</link>
      <pubDate>Wed, 24 Sep 2025 07:16:39 +0900</pubDate>
      <guid>http://localhost:1313/university-mobile-programming/</guid>
      <description>&lt;h2 id=&#34;kotlin-기본-문법&#34;&gt;kotlin 기본 문법&lt;/h2&gt;&#xA;&lt;h3 id=&#34;kotlin-keyword&#34;&gt;​kotlin keyword&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1-hard-keywords&#34;&gt;1. Hard Keywords&lt;/h4&gt;&#xA;&lt;p&gt;&lt;em&gt;(문법 구조에 필수적이며, 식별자로 절대 사용할 수 없음)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;키워드&lt;/th&gt;&#xA;          &lt;th&gt;설명&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;as&lt;/code&gt; (cast)&lt;/td&gt;&#xA;          &lt;td&gt;타입 캐스팅 (&lt;code&gt;val x = obj as String&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;as&lt;/code&gt; (import)&lt;/td&gt;&#xA;          &lt;td&gt;임포트 시 별칭 지정 (&lt;code&gt;import foo.Bar as Baz&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;as?&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;안전한 타입 캐스팅 (실패 시 &lt;code&gt;null&lt;/code&gt; 반환)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;break&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;루프 또는 라벨 블록 탈출&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;class&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;클래스 정의&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 루프 반복 건너뛰기&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;do&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;do-while&lt;/code&gt; 루프 시작&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;else&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;if&lt;/code&gt; 조건의 대안 블록&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;불리언 상수: 거짓&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;for&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;컬렉션/범위 반복 (&lt;code&gt;for (i in list)&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;fun&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;함수 정의&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;if&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;조건 분기&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;in&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;범위/컬렉션 멤버 확인 또는 &lt;code&gt;for&lt;/code&gt; 루프에서 사용&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;!in&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;in&lt;/code&gt;의 부정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;interface&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;인터페이스 정의&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;is&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;타입 확인 (&lt;code&gt;if (obj is String)&lt;/code&gt;)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;!is&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;is&lt;/code&gt;의 부정&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;널 참조 값&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;object&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;싱글톤 객체 또는 익명 객체 정의&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;package&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;패키지 선언&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;return&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;함수 또는 라벨에서 반환&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;super&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;상위 클래스 참조&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;this&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;현재 객체 참조&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;예외 발생&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;불리언 상수: 참&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;try&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;예외 처리 블록 시작&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;typealias&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;타입 별칭 정의&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Kotlin/JS 전용; 일반 Kotlin에서는 사용되지 않음&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;val&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;읽기 전용 변수 선언&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;var&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;변경 가능한 변수 선언&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;when&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;다중 조건 분기 (&lt;code&gt;switch&lt;/code&gt; 대체)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;while&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;조건이 참일 동안 반복&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;2-soft-keywords&#34;&gt;2. Soft Keywords&lt;/h4&gt;&#xA;&lt;p&gt;&lt;em&gt;(특정 문맥에서만 키워드로 동작하며, 일반 식별자로 사용 가능)&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>네트워크 족보 문제 풀이</title>
      <link>http://localhost:1313/06.university/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A1%B1%EB%B3%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/</link>
      <pubDate>Fri, 13 Jun 2025 13:46:10 +0900</pubDate>
      <guid>http://localhost:1313/06.university/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A1%B1%EB%B3%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/</guid>
      <description>&lt;h1 id=&#34;네트워크-라우터의-패킷-서비스-순서-문제&#34;&gt;네트워크 라우터의 패킷 서비스 순서 문제&lt;/h1&gt;&#xA;&lt;p&gt;패킷 크기는 모두 동일하며, 다음 순서로 도착하여 큐에 이미 들어가 있다고 가정합니다:&lt;br&gt;&#xA;&lt;strong&gt;P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;각 패킷은 아래와 같이 &lt;strong&gt;클래스(Class)&lt;/strong&gt; 별로 분류되어 있습니다:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Class 1&lt;/strong&gt;: P2, P4, P7, P12&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Class 2&lt;/strong&gt;: P3, P5, P10&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Class 3&lt;/strong&gt;: P1, P6, P8, P9, P11&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;5-round-robin-scheduling-5점&#34;&gt;5. Round Robin Scheduling (5점)&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;서비스는 &lt;strong&gt;Class 3 큐부터 시작&lt;/strong&gt;됩니다.&lt;/li&gt;&#xA;&lt;li&gt;각 클래스 내부에서는 &lt;strong&gt;패킷 번호 순서대로&lt;/strong&gt; 서비스가 진행됩니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;요구사항&#34;&gt;요구사항:&lt;/h3&gt;&#xA;&lt;p&gt;Round Robin 스케줄링 방식에 따라 패킷이 &lt;strong&gt;실제로 서비스되는 순서를 기술하시오&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>벨만 포드 알고리즘 상세과정</title>
      <link>http://localhost:1313/02.inbox/%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%83%81%EC%84%B8%EA%B3%BC%EC%A0%95/</link>
      <pubDate>Thu, 12 Jun 2025 15:19:04 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%83%81%EC%84%B8%EA%B3%BC%EC%A0%95/</guid>
      <description>&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250612154056-1749710456596-image.png&#34; alt=&#34; (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;이 표는 시작 노드 &lt;strong&gt;u&lt;/strong&gt;에서 다른 모든 노드(v, w, x, y, z)까지의 최단 거리를 벨만-포드 알고리즘을 사용하여 찾는 과정을 보여줍니다. 벨만-포드 알고리즘은 &lt;strong&gt;거쳐가는 간선(hop)의 개수를 1개부터 점차 늘려가며&lt;/strong&gt; 최단 거리를 갱신하는 방식입니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-기본-개념-벨만-포드-알고리즘&#34;&gt;## 기본 개념: 벨만-포드 알고리즘&lt;/h3&gt;&#xA;&lt;p&gt;벨만-포드 알고리즘의 핵심 아이디어는 다음과 같습니다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;k개의 간선까지만 사용했을 때의 최단 거리&lt;/strong&gt;를 계산합니다.&lt;/li&gt;&#xA;&lt;li&gt;이전 단계(k-1개 간선 사용)의 최단 거리 정보를 이용해 현재 단계(k개 간선 사용)의 최단 거리를 갱신합니다.&lt;/li&gt;&#xA;&lt;li&gt;공식: &lt;code&gt;D[u] &amp;gt; D[v] + cost(v, u)&lt;/code&gt; 이면 &lt;code&gt;D[u] = D[v] + cost(v, u)&lt;/code&gt;로 갱신합니다. (v를 거쳐 u로 가는 거리가 더 짧다면 갱신)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;주어진 표에서 &amp;ldquo;up to k hops&amp;quot;는 최대 k개의 간선을 사용했을 때 &lt;strong&gt;u&lt;/strong&gt;로부터 각 노드까지의 최단 거리를 의미합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>캐시 매핑 방식의 이해</title>
      <link>http://localhost:1313/06.university/%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9D%B4%ED%95%B4/</link>
      <pubDate>Tue, 10 Jun 2025 17:50:28 +0900</pubDate>
      <guid>http://localhost:1313/06.university/%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9D%B4%ED%95%B4/</guid>
      <description>&lt;h3 id=&#34;공통-시스템-환경-설정&#34;&gt;&lt;strong&gt;공통 시스템 환경 설정&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;주기억장치 용량&lt;/strong&gt;: 4KB (4096 바이트). 따라서 주소는 &lt;strong&gt;12비트&lt;/strong&gt;가 필요합니다 (212=4096).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;워드(Word)의 크기&lt;/strong&gt;: &lt;strong&gt;4 바이트&lt;/strong&gt;. (32비트 시스템에서 흔히 볼 수 있는 구조)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;블록(Block) 및 캐시 라인(Line) 크기&lt;/strong&gt;: 4 워드. 즉, 4워드×4바이트/워드=16바이트 입니다.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;캐시 메모리 크기&lt;/strong&gt;: 256 바이트.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;캐시 라인의 수&lt;/strong&gt;: 256바이트/16바이트/라인=16개의 라인을 가집니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;메모리 주소는 &lt;strong&gt;12비트&lt;/strong&gt;이며, 이 주소를 어떻게 &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Line(or Set)&lt;/code&gt;, &lt;code&gt;Word(or Offset)&lt;/code&gt; 필드로 나누는지가 각 사상 방식의 핵심입니다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Word(Offset) 필드&lt;/strong&gt;: 블록 크기가 16바이트이므로, 블록 내 특정 바이트를 가리키기 위해 log2​(16)=4비트가 필요합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;-1-직접-사상-방식-direct-mapping&#34;&gt;## 1. 직접 사상 방식 (Direct Mapping)&lt;/h3&gt;&#xA;&lt;p&gt;직접 사상 방식에서는 주기억장치의 각 블록이 캐시의 정해진 &lt;strong&gt;단 하나의 라인&lt;/strong&gt;에만 저장될 수 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>university network quiz</title>
      <link>http://localhost:1313/06.university/network/university-network-quiz/</link>
      <pubDate>Tue, 03 Jun 2025 06:05:16 +0900</pubDate>
      <guid>http://localhost:1313/06.university/network/university-network-quiz/</guid>
      <description>&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250313150667.png&#34; alt=&#34; (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250320150681.jpg&#34; alt=&#34;Pasted image 20250320150681 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250327150571.png&#34; alt=&#34;Pasted image 20250327150571 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;5번은 iterated query, recursive query 를 사용&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250403150631.png&#34; alt=&#34;Pasted image 20250403150631 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250410150653.jpg&#34; alt=&#34;Pasted image 20250410150653 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250424150824.jpg&#34; alt=&#34;Pasted image 20250424150824 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;중간고사&#34;&gt;중간고사&lt;/h3&gt;&#xA;&lt;p&gt;ack, nak : 비트 에러 대비용&#xA;seq : 순서 확인용&#xA;timeout : 패킷 손실 대비용&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;tcp 에서 timeout 이 발생하면 timeout 이 발생한 패킷만 재전송한다( 잘 도착한 패킷은 버퍼링하기 때문에 필요없음 )&lt;/li&gt;&#xA;&lt;li&gt;GBN, SR 의 원형은 받은 패킷번호를 ack vs TCP 는 받고난후 다음에 받을 패킷번호를 ack&lt;/li&gt;&#xA;&lt;li&gt;TCP RENO&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250508150413.png&#34; alt=&#34;Pasted image 20250508150413 (Image resource not found)&#34; &gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>university operating system quiz</title>
      <link>http://localhost:1313/06.university/os/university-operating-system-quiz/</link>
      <pubDate>Tue, 22 Apr 2025 11:00:00 +0900</pubDate>
      <guid>http://localhost:1313/06.university/os/university-operating-system-quiz/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;pcb(process control block) 에 포함된 정보&#xA;&lt;ul&gt;&#xA;&lt;li&gt;process state&lt;/li&gt;&#xA;&lt;li&gt;process number&lt;/li&gt;&#xA;&lt;li&gt;program counter and registers&lt;/li&gt;&#xA;&lt;li&gt;memory limits&lt;/li&gt;&#xA;&lt;li&gt;list of open files&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;6주차&#34;&gt;6주차&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU를 연속적으로 사용하는 시간을 CPU burst 라고 한다&lt;/li&gt;&#xA;&lt;li&gt;스케줄링 알고리즘의 목적으로 바람직한것&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cpu 사용율을 최대화&lt;/li&gt;&#xA;&lt;li&gt;throughput 을 최대화&lt;/li&gt;&#xA;&lt;li&gt;average wating time 최대화&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;스케줄링에 대해 맞는것&#xA;&lt;ul&gt;&#xA;&lt;li&gt;preemtive 는 강제 중단 가능 non-preemtive 는 강제 중단 불가능&lt;/li&gt;&#xA;&lt;li&gt;최근 운영체제는 preemtive 를 주로 사용&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;non-preemtive 알고리즘&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SJF&lt;/li&gt;&#xA;&lt;li&gt;FCFS&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;non-preemtive 에서 가장 average wating time 이 가장 작은 것은 shortest job first&lt;/li&gt;&#xA;&lt;li&gt;exponential moving average&#xA;&lt;ul&gt;&#xA;&lt;li&gt;과거의 데이터가 현재의 값에 영향을 미치고 최근 데이터가 더 영향이 더 큰 경우에 사용한다&lt;/li&gt;&#xA;&lt;li&gt;값의 변화의 추이를 예측하는 데 사용된다&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;preemtive 스케줄링&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SRTF&lt;/li&gt;&#xA;&lt;li&gt;Priorty&lt;/li&gt;&#xA;&lt;li&gt;Round Robin&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;priorty 스케줄링의 단점 =&amp;gt; starvation, 기아&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;7주차&#34;&gt;7주차&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;멀티레벨 queue 스케줄링에서는 각 큐가 일정비율로 CPU 를 할당받는다 =&amp;gt; True&lt;/li&gt;&#xA;&lt;li&gt;process aging 을 구현할 수 있는 스케줄링 방법 =&amp;gt; multilevel feedback queue 스케줄링&lt;/li&gt;&#xA;&lt;li&gt;윈도우는 preemptive scheduling 을 사용&lt;/li&gt;&#xA;&lt;li&gt;동시성 문제에 대해 맞는것&#xA;&lt;ul&gt;&#xA;&lt;li&gt;두개이상의 프로세스가 같은 리소스를 동시에 접근하려 할 때 발생&lt;/li&gt;&#xA;&lt;li&gt;CPU 코어가 하나인 경우에도 발생한다&lt;/li&gt;&#xA;&lt;li&gt;race condition 때문에 발생하기도 한다&lt;/li&gt;&#xA;&lt;li&gt;critical section problem 으로 이해 할 수 있다&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;동시성 문제는 프로세스가 같은 변수를 동시에 읽으려고 할 때도 발생한다 =&amp;gt; False&lt;/li&gt;&#xA;&lt;li&gt;critical section 은 하나의 프로세스만 들어갈 수 있다는 조건은 mutual exclution&lt;/li&gt;&#xA;&lt;li&gt;critical section에 아무도 없는데 계속 대기하는 상황은 Progress&lt;/li&gt;&#xA;&lt;li&gt;critical section 문제를 해결하고자 할때 Mutual exclution 을 만족하지 못하는 이유&#xA;&lt;ul&gt;&#xA;&lt;li&gt;locked = 0 or 1 lock 방식 알고리즘의 경우 여러 프로세스가 동시에 critical section에 들어 갈 수 있기 때문&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;9주차&#34;&gt;9주차&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lock 방식은 mutual exclusion, bounded Waiting 만족하지 못한다&lt;/li&gt;&#xA;&lt;li&gt;peterson solution의 한계는 critical section problem 이 이미 해결되었다고 가정한 후에 풀었다&lt;/li&gt;&#xA;&lt;li&gt;critical section problem 를 해결하기 위해 interrupt 를 비활성화 하는 방법의 한계는 cpu 가 여러개인 경우 적용할 수 없고 결국 시스템의 성능이 저하된다&lt;/li&gt;&#xA;&lt;li&gt;semaphore 접근을 위해 들어갈때 wait, 나갈 때 signal 을 부른다&lt;/li&gt;&#xA;&lt;li&gt;semaphore 가 critical section 에 들어가기 위해 지속적으로 semaphore 의 현재값을 체크 할 수 있다 이것을 busy-wating(spin lock) 이라고 한다&lt;/li&gt;&#xA;&lt;li&gt;semaphore 의 값이 -2 일 때 대기자 리스트에 2개의 프로세스가 대기중이다&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;중간고사&#34;&gt;중간고사&lt;/h3&gt;&#xA;&lt;p&gt;폰 노이만 구조가 이전과 다른점 : 코드영역(program)이 하드웨어가 아닌 메모리로 올라간다(소프트웨어 개념의 탄생)&lt;br&gt;&#xA;캐쉬를 통해 성능 향상이 가능한 이유 : priciple of locality : 비슷한 시간에 지역적으로 접근한다&lt;/p&gt;</description>
    </item>
    <item>
      <title>university architecture</title>
      <link>http://localhost:1313/06.university/university-architecture/</link>
      <pubDate>Thu, 17 Apr 2025 03:26:00 +0900</pubDate>
      <guid>http://localhost:1313/06.university/university-architecture/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;PC : 다음에 인출될 명령어의 주소&lt;/li&gt;&#xA;&lt;li&gt;AC : 임시저장&lt;/li&gt;&#xA;&lt;li&gt;IR : 최근에 인출된 명령어&lt;/li&gt;&#xA;&lt;li&gt;MAR : 기억장치 접근 주소&lt;/li&gt;&#xA;&lt;li&gt;MBR : 기억장치 접근 데이터&lt;/li&gt;&#xA;&lt;li&gt;SP : 스텍 최상위 주소&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2장&#34;&gt;2장&lt;/h3&gt;&#xA;&lt;h3 id=&#34;사이클&#34;&gt;사이클&lt;/h3&gt;&#xA;&lt;h4 id=&#34;인출-사이클&#34;&gt;인출 사이클&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;MAR &amp;lt;- PC&#xA;MBR &amp;lt;- M[MAR], PC &amp;lt;- PC + 1&#xA;IR &amp;lt;- MBR&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;실행-사이클&#34;&gt;실행 사이클&lt;/h4&gt;&#xA;&lt;p&gt;load&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;인터럽트-사이클&#34;&gt;인터럽트 사이클&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;MBR &amp;lt;- PC&#xA;MAR &amp;lt;- SP, PC &amp;lt;- ISR 의 시작 주소&#xA;M[MAR] &amp;lt;- MBR , SP &amp;lt;- SP-1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;간접-사이클&#34;&gt;간접 사이클&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;MAR &amp;lt;- IR(addr)&#xA;MBR &amp;lt;- M[MAR]&#xA;IR(addr) &amp;lt;- MBR&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;sub-call&#34;&gt;Sub call&lt;/h4&gt;&#xA;&lt;p&gt;인터럽트 사이클과 비슷&lt;br&gt;&#xA;&lt;code&gt;CALL X&lt;/code&gt; 명령시&lt;/p&gt;</description>
    </item>
    <item>
      <title>UDP와 TCP Demultiplexing 의 이해</title>
      <link>http://localhost:1313/02.inbox/udp%EC%99%80-tcp-demultiplexing-%EC%9D%98-%EC%9D%B4%ED%95%B4/</link>
      <pubDate>Fri, 28 Mar 2025 09:53:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/udp%EC%99%80-tcp-demultiplexing-%EC%9D%98-%EC%9D%B4%ED%95%B4/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;디멀티플렉싱은 수신된 네트워크 패킷을 분석하여 해당 패킷이 어떤 소켓으로 전달되어야 하는지를 결정하는 과정&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;멀티플렉싱은 여러 응용 프로그램에서 생성된 데이터를 하나의 네트워크 인터페이스로 전송하는 과정&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;UDP와 TCP 디멀티플렉싱의 비교 분석&#xA;UDP는 디멀티플렉싱을 위해 목적지 IP 주소와 목적지 포트 번호라는 2-튜플을 사용하는 반면 8, TCP는 송신지 IP 주소, 송신지 포트 번호, 목적지 IP 주소, 목적지 포트 번호로 구성된 4-튜플을 사용합니다&#xA;&#xA;이러한 차이는 각 프로토콜의 연결 지향성 여부에서 비롯됩니다. TCP는 연결 지향적인 특성상 각 연결의 상태를 추적해야 하며, 이는 고유한 4-튜플을 통해 이루어집니다&#xA;TCP 연결은 두 특정 호스트의 두 특정 프로세스 간의 전용 통신 채널을 의미하므로, 더 자세한 식별 정보가 필요합니다. TCP의 신뢰성 있는 데이터 전송과 순서 보장 기능은 이러한 연결 상태 유지에 의존합니다.&#xA;반면, UDP는 각 데이터그램을 독립적인 단위로 취급하는 비연결형 프로토콜이므로 데이터그램을 올바른 포트에서 수신 대기 중인 애플리케이션에 전달하는 데 목적지 정보만으로 충분합니다. UDP의 이러한 단순성은 디멀티플렉싱 과정을 더 빠르고 효율적으로 만들어줍니다&#xA;이는 속도가 중요하고 일부 데이터 손실이 허용되는 애플리케이션(예: 스트리밍, 온라인 게임)에 UDP가 적합한 이유입니다.&#xA;반대로, TCP의 복잡한 디멀티플렉싱 방식은 여러 동시 연결을 통해 데이터를 안정적이고 순서대로 전달하는 데 필수적이며 3, 웹 브라우징, 파일 전송, 이메일과 같이 데이터 무결성이 중요한 애플리케이션에 적합합니다.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;udp와-tcp의-demultiplexing-이해하기&#34;&gt;UDP와 TCP의 Demultiplexing 이해하기&lt;/h3&gt;&#xA;&lt;p&gt;UDP와 TCP의 demultiplexing 차이는 각 프로토콜의 연결 방식에서 비롯됩니다. UDP는 비연결형으로, 각 데이터그램을 독립적으로 처리하며 목적지 포트만으로 충분히 데이터를 전달할 수 있습니다. 반면, TCP는 연결 지향형으로, 두 호스트 간의 특정 프로세스 쌍을 식별하기 위해 더 많은 정보(4-튜플)가 필요합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>university network</title>
      <link>http://localhost:1313/06.university/network/university-network/</link>
      <pubDate>Tue, 18 Mar 2025 16:00:00 +0900</pubDate>
      <guid>http://localhost:1313/06.university/network/university-network/</guid>
      <description>&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250318161430.png&#34; alt=&#34; (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;전송-4계층&#34;&gt;전송 4계층&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;&#xA;&lt;h3 id=&#34;3계층&#34;&gt;3계층&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FCFS&lt;/li&gt;&#xA;&lt;li&gt;Priority&lt;/li&gt;&#xA;&lt;li&gt;RR(round robin)&lt;/li&gt;&#xA;&lt;li&gt;weighted fair&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;network neutality ( 망 중립성 )&lt;br&gt;&#xA;각 ISP 각 자원을 어떻게 분배할 것인가?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;protecting free speech&lt;/li&gt;&#xA;&lt;li&gt;encouraging innovation, compatition&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;link s&lt;/p&gt;&#xA;&lt;h3 id=&#34;chapter4&#34;&gt;chapter4&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;보장된 전달&lt;/li&gt;&#xA;&lt;li&gt;지연 제한 이내의 보장된 전달&lt;/li&gt;&#xA;&lt;li&gt;순서화 패킷 전달&lt;/li&gt;&#xA;&lt;li&gt;최소 대역폭 보장&lt;/li&gt;&#xA;&lt;li&gt;보안 서비스&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>university operating system</title>
      <link>http://localhost:1313/06.university/os/university-operating-system/</link>
      <pubDate>Tue, 18 Mar 2025 09:29:00 +0900</pubDate>
      <guid>http://localhost:1313/06.university/os/university-operating-system/</guid>
      <description>&lt;h2 id=&#34;computer-organization&#34;&gt;Computer Organization&lt;/h2&gt;&#xA;&lt;h3 id=&#34;폰-노이만-구조&#34;&gt;폰 노이만 구조&lt;/h3&gt;&#xA;&lt;p&gt;폰 노이만 구조가 이전과 다른점 : 코드영역(program)이 하드웨어가 아닌 메모리로 올라간다(소프트웨어 개념의 탄생)&lt;/p&gt;&#xA;&lt;h2 id=&#34;메모리-계층-구조&#34;&gt;메모리 계층 구조&lt;/h2&gt;&#xA;&lt;p&gt;위 내용은 컴퓨터 시스템에서 **메모리 계층 구조(Memory Hierarchy)**와 관련된 개념을 설명하고 있습니다. 특히, 프로세서가 메모리를 참조할 때 나타나는 **시간적/공간적 지역성(Temporal and Spatial Locality)**과 이를 기반으로 한 메모리 접근 패턴의 효율성을 다룹니다. 아래에서 각 항목을 상세히 설명하겠습니다.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1-memory-references-cluster-in-time-and-space&#34;&gt;1. &lt;strong&gt;Memory References Cluster in Time and Space&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이 문장은 메모리 참조가 **시간적 지역성(Temporal Locality)**과 **공간적 지역성(Spatial Locality)**이라는 두 가지 특성을 보인다는 것을 의미합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;1-시간적-지역성-temporal-locality&#34;&gt;(1) 시간적 지역성 (Temporal Locality)&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 최근에 참조된 데이터가 다시 참조될 가능성이 높음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: 프로그램이 특정 변수를 반복적으로 사용하는 경우, 해당 변수는 캐시 또는 레지스터에 남아 있는 것이 유리함.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;응용&lt;/strong&gt;: 캐시 메모리를 통해 자주 사용되는 데이터를 유지하여 성능을 향상시킴.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2-공간적-지역성-spatial-locality&#34;&gt;(2) 공간적 지역성 (Spatial Locality)&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 어떤 메모리 주소가 참조되면 그 근처의 주소들도 곧 참조될 가능성이 높음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: 배열이나 연속된 데이터 구조를 처리할 때, 프로세서는 연속된 메모리 위치를 순차적으로 접근함.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;응용&lt;/strong&gt;: 캐시 라인(Cache Line)을 통해 한 번에 여러 데이터를 미리 가져오는 방식으로 활용됨.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-data-is-organized-so-that-the-percentage-of-accesses-to-each-successively-lower-level-is-substantially-less-than-that-of-the-level-above&#34;&gt;2. &lt;strong&gt;Data is Organized So That the Percentage of Accesses to Each Successively Lower Level is Substantially Less Than That of the Level Above&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;이 문장은 &lt;strong&gt;메모리 계층 구조&lt;/strong&gt;의 기본 원칙을 설명합니다. 메모리 계층 구조는 다음과 같은 특징을 가집니다:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;1-메모리-계층-구조&#34;&gt;(1) 메모리 계층 구조&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;컴퓨터 시스템은 다양한 종류의 메모리를 사용하며, 각 메모리는 &lt;strong&gt;속도&lt;/strong&gt;, &lt;strong&gt;크기&lt;/strong&gt;, &lt;strong&gt;비용&lt;/strong&gt;의 관점에서 차이가 있음.&lt;/li&gt;&#xA;&lt;li&gt;일반적으로 메모리 계층은 다음과 같이 구성됩니다:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;레지스터(Register)&lt;/strong&gt;: 가장 빠르지만 크기가 작음.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;캐시(Cache)&lt;/strong&gt;: L1, L2, L3 캐시로 나뉘며, 속도와 크기가 점진적으로 증가.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RAM(Main Memory)&lt;/strong&gt;: 큰 용량을 제공하지만 상대적으로 느림.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;디스크(Storage)&lt;/strong&gt;: 가장 느리지만 매우 큰 용량을 제공.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2-접근-비율access-rate&#34;&gt;(2) 접근 비율(Access Rate)&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;메모리 계층 구조에서는 더 낮은 수준의 메모리로 갈수록 접근 비율이 급격히 감소합니다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;예를 들어, 프로세서가 필요로 하는 데이터의 대부분은 &lt;strong&gt;L1 캐시&lt;/strong&gt;에서 해결되며, L2 캐시로 넘어가는 비율은 그보다 적고, RAM으로 넘어가는 비율은 더욱 줄어듦.&lt;/li&gt;&#xA;&lt;li&gt;이러한 접근 비율의 차이는 &lt;strong&gt;지역성 원칙&lt;/strong&gt; 덕분에 가능해짐.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;3-효율성&#34;&gt;(3) 효율성&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;메모리 계층 구조는 &lt;strong&gt;빠른 메모리&lt;/strong&gt;를 적절히 활용하여 전체 시스템의 성능을 극대화합니다.&lt;/li&gt;&#xA;&lt;li&gt;예를 들어, L1 캐시가 필요한 데이터를 제공할 확률이 90%이고, L2 캐시가 추가로 8%를 처리한다면, RAM에서 직접 데이터를 읽어야 하는 경우는 2%에 불과하게 됩니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-can-be-applied-across-more-than-two-levels-of-memory&#34;&gt;3. &lt;strong&gt;Can Be Applied Across More Than Two Levels of Memory&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;메모리 계층 구조는 단순히 두 개의 메모리 레벨(예: 캐시와 RAM)에만 적용되는 것이 아니라, &lt;strong&gt;여러 레벨&lt;/strong&gt;에 걸쳐 적용될 수 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;1-다중-메모리-레벨&#34;&gt;(1) 다중 메모리 레벨&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;현대 컴퓨터 시스템에서는 여러 레벨의 메모리가 존재하며, 각 레벨은 서로 다른 특성을 가짐:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;L1 캐시&lt;/strong&gt;: 가장 빠르지만 작은 용량.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;L2 캐시&lt;/strong&gt;: L1보다 느리지만 더 큰 용량.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;L3 캐시&lt;/strong&gt;: L2보다 더 느리지만 더 큰 용량.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RAM&lt;/strong&gt;: 캐시보다 느리지만 매우 큰 용량.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SSD/HDD&lt;/strong&gt;: 가장 느리지만 영구 저장이 가능.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2-데이터-이동&#34;&gt;(2) 데이터 이동&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;데이터는 필요한 경우에 따라 위계적으로 이동합니다. 예를 들어:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;프로세서가 데이터를 요청하면 먼저 L1 캐시를 확인.&lt;/li&gt;&#xA;&lt;li&gt;L1 캐시에 없으면 L2 캐시를 확인.&lt;/li&gt;&#xA;&lt;li&gt;L2 캐시에도 없으면 L3 캐시, RAM, 디스크 순으로 검색.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;3-성능-최적화&#34;&gt;(3) 성능 최적화&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;각 메모리 레벨의 용량과 속도를 적절히 조합하여 전체 시스템의 성능을 최적화합니다.&lt;/li&gt;&#xA;&lt;li&gt;예를 들어, 캐시 미스(Cache Miss)가 발생할 때마다 더 느린 메모리로 접근해야 하므로, 캐시 히트율(Cache Hit Rate)을 높이는 것이 중요합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;요약-및-결론&#34;&gt;요약 및 결론&lt;/h3&gt;&#xA;&lt;p&gt;위 내용은 메모리 계층 구조와 지역성 원칙을 중심으로, 프로세서가 메모리를 참조할 때 나타나는 패턴과 이를 활용한 시스템 설계 원리를 설명합니다. 핵심 포인트는 다음과 같습니다:&lt;/p&gt;</description>
    </item>
    <item>
      <title>university machine leaning</title>
      <link>http://localhost:1313/06.university/university-machine-leaning/</link>
      <pubDate>Mon, 10 Mar 2025 15:00:00 +0900</pubDate>
      <guid>http://localhost:1313/06.university/university-machine-leaning/</guid>
      <description>&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250314104746.png&#34; alt=&#34;Pasted image 20250314104746 (Image resource not found)&#34; &gt;&#xA;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20250314104833.png&#34; alt=&#34;Pasted image 20250314104833 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;T task : 해야할 작업&lt;/li&gt;&#xA;&lt;li&gt;E experience : 학습&lt;/li&gt;&#xA;&lt;li&gt;P performance : 작업 성능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;머신러닝-분류&#34;&gt;머신러닝 분류&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;기준1: 사람의 지도/감독 여부 (학습하는 동안 감독의 형태나 주어지는 정보량에 따른 분류)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;지도(Supervised) : 레이블(타겟) 이 포함&#xA;분류(classification), 회귀(regression) 정답이 포함되어 있는가&lt;/li&gt;&#xA;&lt;li&gt;비지도(unsupervised) :  : 레이블이 없는 훈련 데이터 :&#xA;군집(Clustering), 시각화(Visualization), 차원 축소(Dimensionality Reduction), 이상 탐지(Anomaly Detection), 이상 탐지(Anomaly Detection), 연관 규칙 학습(Association Rule Learning)&lt;/li&gt;&#xA;&lt;li&gt;준지도(semi-supervised) : 지도 + 비지도&lt;/li&gt;&#xA;&lt;li&gt;강화(reinforcement)학습 : 학습에 대한 피드백 제공&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;기준2 : 실시간으로 주어지는 데이터에 대한 점진적인 학습 가능 여부&#xA;&lt;ul&gt;&#xA;&lt;li&gt;온라인 학습 vs 배치 학습&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;기준3 : 훈련을 통해 알고 있는 데이터 포인트와 새로운 데이터 포인트를 비교하는 방식인지, 아니면 훈련 데이터셋에서 패턴을 발견하고 그에 기반한 예측 모델을 만드는 것인지&#xA;&lt;ul&gt;&#xA;&lt;li&gt;사례 기반 학습 vs 모델 기반 학습&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;세부&#34;&gt;세부&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;분류&lt;/li&gt;&#xA;&lt;li&gt;회귀 : 중고자 가격 예측&lt;/li&gt;&#xA;&lt;li&gt;군집 : 비슷한 특징을 가진 그룹으로 나누는 것 (분류과 다른점은 레이블이 없다) :  k-means, DBSCAN, 계층 군집 분석&lt;/li&gt;&#xA;&lt;li&gt;시각화 : 레이블이 없는 고차원(여러 특성(feature)들로 이루어진) 데이터를 분석하여 도식화가 가능한 2D 또는 3D 표현을 만들어줌&lt;/li&gt;&#xA;&lt;li&gt;차원 축소 : original information의 손실을 최소화 하면서 데이터의 차원(특성)을 줄이기&#xA;ex) 상관관계가 높은 자동차의 주행거리과 연식을 “마모 정도”라는 하나의 특성으로 합침&lt;/li&gt;&#xA;&lt;li&gt;이상 탐지 : 정상 샘플들을 이용하여 머신러닝 모델 훈련 후 주어진 새로운 샘플의 정상 여부를 판단&lt;/li&gt;&#xA;&lt;li&gt;특이치 탐지(Novelty Detection) : 전혀 오염되지 않은 clean 훈련 데이터 학습 후 학습된 훈련 데이터와 달라 보이는 데이터 탐지&lt;/li&gt;&#xA;&lt;li&gt;연관 규칙 학습(Association Rule Learning) :  특성 간 흥미로운 관계 찾기&#xA;마트 판매 기록 데이터에 대해 연관 규칙 학습 적용 예) 바비큐 소스와 감자를 구매한 고객이 스테이크도 구매하는 경향을 찾아냄&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;군집과 vs 시각화의 다른점&#xA;이상탐지 vs 특이치 탐지&#xA;&lt;strong&gt;특이치 탐지&lt;/strong&gt; 는 &amp;ldquo;강아지 vs. 고양이&amp;quot;처럼 명확한 범주 분류&#xA;&lt;strong&gt;이상 탐지&lt;/strong&gt; 는 &amp;ldquo;대부분의 강아지와 다른 특이한 사례&amp;rdquo;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cloud Computing 과제2 보고서</title>
      <link>http://localhost:1313/02.inbox/cloud-computing-%EA%B3%BC%EC%A0%9C2-%EB%B3%B4%EA%B3%A0%EC%84%9C/</link>
      <pubDate>Sun, 24 Nov 2024 05:40:00 +0900</pubDate>
      <guid>http://localhost:1313/02.inbox/cloud-computing-%EA%B3%BC%EC%A0%9C2-%EB%B3%B4%EA%B3%A0%EC%84%9C/</guid>
      <description>&lt;p&gt;&#xA;        &lt;img src=&#34;http://localhost:1313/08.media/20241124053028.png&#34; alt=&#34;Pasted image 20241124053028 (Image resource not found)&#34; &gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-기존-wordcount-프로그램에-추가하거나-개선하고자-하는-각-기능-설명&#34;&gt;1. 기존 WordCount 프로그램에 추가하거나 개선하고자 하는 각 기능 설명&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;문장 부호(!?,.&amp;rsquo;&amp;quot;{}()) 및 소 중괄호 제거&lt;/li&gt;&#xA;&lt;li&gt;대소문자 구분 여부를 확인하기 위해 &amp;ndash;case-sensitive true|false 인수를 받음&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;2-입력-데이터-설명---데이터-전체를-보고서에-포함하거나-별도-파일로-제출&#34;&gt;2. 입력 데이터 설명 - 데이터 전체를 보고서에 포함하거나 별도 파일로 제출&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.txt&#34; class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;bash_menual_file&lt;/a&gt; 를 사용하여 입력데이터로 사용하였음&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-각-기능에-대한-구현-결과물---소스-코드-전체를-보고서에-포함하거나-별도-파일로-제출-jar-파일-x&#34;&gt;3. 각 기능에 대한 구현 결과물 - 소스 코드 전체를 보고서에 포함하거나 별도 파일로 제출 (jar 파일 X)&lt;/h2&gt;&#xA;&lt;p&gt;WordCount.java 파일&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

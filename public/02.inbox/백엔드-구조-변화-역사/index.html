<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title> | My Test Site</title>
    

    
    
    <meta name="description" content="모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석 현대 백엔드 개발의 핵심 철학
서론: 왜 아키텍처는 중요한가? 소프트웨어 개발은 단순히 &lsquo;동작하는 코드&rsquo;를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">

    
    
    
    <meta property="og:title" content="">
    <meta property="og:description" content="모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석 현대 백엔드 개발의 핵심 철학
서론: 왜 아키텍처는 중요한가? 소프트웨어 개발은 단순히 &lsquo;동작하는 코드&rsquo;를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="">
    <meta name="twitter:description" content="모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석 현대 백엔드 개발의 핵심 철학
서론: 왜 아키텍처는 중요한가? 소프트웨어 개발은 단순히 &lsquo;동작하는 코드&rsquo;를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1> **page.html**</h1>
    <h2 id="모델-1에서-모델-2로의-진화-웹-개발-아키텍처-심층-분석">모델 1에서 모델 2로의 진화: 웹 개발 아키텍처 심층 분석</h2>
<p>현대 백엔드 개발의 핵심 철학</p>
<h3 id="서론-왜-아키텍처는-중요한가">서론: 왜 아키텍처는 중요한가?</h3>
<p>소프트웨어 개발은 단순히 &lsquo;동작하는 코드&rsquo;를 만드는 행위에서 그치지 않습니다. 시간이 지나면서 요구사항은 끊임없이 변화하고, 새로운 기술이 등장하며, 비즈니스는 확장됩니다. 이러한 변화의 파도 속에서 흔들리지 않는 견고하고 유연한 시스템을 구축하는 것, 이것이 바로 &lsquo;아키텍처&rsquo;의 역할입니다. 제공된 텍스트는 웹 애플리케이션 개발 아키텍처의 중요한 변곡점인 <strong>모델 1</strong>과 <strong>모델 2</strong>의 차이를 통해, 좋은 아키텍처가 무엇이며 어떻게 발전해 왔는지를 심도 있게 이야기하고 있습니다. 이는 단순히 기술의 변화가 아닌, &lsquo;문제 해결 방식&rsquo;에 대한 패러다임의 전환을 의미합니다.</p>
<hr>
<h3 id="제1장-혼돈의-시대-모델-1-아키텍처">제1장: 혼돈의 시대, 모델 1 아키텍처</h3>
<p>모델 1 아키텍처는 초창기 웹 개발의 직관적인 접근 방식이었습니다. 웹 페이지(JSP, ASP, PHP 등) 하나가 하나의 요청을 처음부터 끝까지 모두 책임지는 구조입니다.</p>
<p><strong>1. 핵심 구조: All-in-One 페이지</strong></p>
<p>사용자가 <code>list.jsp</code>라는 페이지를 요청했다고 가정해 봅시다. 모델 1 구조에서 이 <code>list.jsp</code> 파일 안에는 다음과 같은 코드들이 뒤섞여 있습니다.</p>
<ul>
<li><strong>① 요청 분석 코드 (Controller의 역할):</strong> 사용자가 검색어를 입력했는지, 특정 페이지 번호를 요청했는지 등의 파라미터를 분석하는 자바 코드.</li>
<li><strong>② 비즈니스 로직 및 데이터 처리 코드 (Service &amp; Repository의 역할):</strong> 데이터베이스에 연결하여 게시글 목록을 조회하는 SQL 쿼리와 JDBC 코드.</li>
<li><strong>③ 화면 출력 코드 (View의 역할):</strong> 조회된 데이터를 <code>&lt;table&gt;</code>, <code>&lt;li&gt;</code> 등의 HTML 태그를 사용하여 웹 페이지 형태로 그려내는 코드.</li>
</ul>
<pre tabindex="0"><code class="language-jsp" data-lang="jsp">&lt;%-- list.jsp (모델 1 예시) --%&gt;
&lt;%@ page import=&#34;java.sql.*, java.util.*&#34; %&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;게시판 목록&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;게시판 목록&lt;/h1&gt;
    &lt;%
        // ① 요청 분석 + ② 데이터 처리 (Controller + Service + Repository)
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List&lt;Map&lt;String, Object&gt;&gt; boardList = new ArrayList&lt;&gt;();

        try {
            // DB 연결
            String dbUrl = &#34;jdbc:mysql://localhost:3306/mydb&#34;;
            conn = DriverManager.getConnection(dbUrl, &#34;user&#34;, &#34;password&#34;);

            // SQL 실행
            String sql = &#34;SELECT id, title, writer, created_at FROM board ORDER BY id DESC&#34;;
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();

            // 결과(ResultSet)를 Array(List&lt;Map&gt;)로 변환
            while (rs.next()) {
                Map&lt;String, Object&gt; board = new HashMap&lt;&gt;();
                board.put(&#34;id&#34;, rs.getInt(&#34;id&#34;));
                board.put(&#34;title&#34;, rs.getString(&#34;title&#34;));
                board.put(&#34;writer&#34;, rs.getString(&#34;writer&#34;));
                boardList.add(board);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 자원 해제
            if (rs != null) rs.close();
            if (pstmt != null) pstmt.close();
            if (conn != null) conn.close();
        }
    %&gt;

    &lt;!-- ③ 화면 출력 (View) --&gt;
    &lt;table border=&#34;1&#34;&gt;
        &lt;tr&gt;
            &lt;th&gt;번호&lt;/th&gt;
            &lt;th&gt;제목&lt;/th&gt;
            &lt;th&gt;작성자&lt;/th&gt;
        &lt;/tr&gt;
        &lt;% for (Map&lt;String, Object&gt; board : boardList) { %&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;%= board.get(&#34;id&#34;) %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= board.get(&#34;title&#34;) %&gt;&lt;/td&gt;
            &lt;td&gt;&lt;%= board.get(&#34;writer&#34;) %&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;% } %&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>2. 모델 1의 치명적인 문제점</strong></p>
<p>텍스트에서 지적한 &ldquo;소스에 대한 응집이 높아 특정 단계에 대한 기능을 수정해도&hellip; 결국 전체의 결과물을 확인하고 수정해야 하는 비효율적인 문제&quot;가 바로 여기서 발생합니다.</p>
<ul>
<li><strong>높은 결합도(High Coupling):</strong> 디자인을 수정하기 위해 HTML 태그 하나를 바꾸려 해도, 복잡한 자바 코드 한가운데를 헤쳐나가야 합니다. 반대로, DB 테이블의 컬럼 이름이 <code>writer</code>에서 <code>author</code>로 바뀌면, SQL 쿼리뿐만 아니라 HTML을 출력하는 부분의 <code>board.get(&quot;writer&quot;)</code> 코드까지 모두 수정해야 합니다. 디자이너와 개발자의 작업 영역이 완전히 겹쳐 협업이 불가능에 가깝습니다.</li>
<li><strong>낮은 재사용성:</strong> &lsquo;게시글 목록을 조회하는 로직&rsquo;은 매우 유용한 기능입니다. 하지만 모델 1에서는 이 로직이 <code>list.jsp</code>라는 특정 &lsquo;화면&rsquo;에 종속되어 있습니다. 만약 모바일 앱을 위해 게시글 목록 데이터만 JSON 형태로 제공해야 한다면? <code>list.jsp</code>의 코드를 복사-붙여넣기하여 <code>api_list.jsp</code> 같은 파일을 새로 만들어야 합니다. 이는 중복 코드의 양산이며, 유지보수의 재앙을 불러옵니다.</li>
<li><strong>테스트의 어려움:</strong> &lsquo;데이터베이스 조회 기능&rsquo;만 따로 떼어내어 잘 동작하는지 테스트할 방법이 없습니다. 반드시 웹 서버를 실행하고, 브라우저로 <code>list.jsp</code>를 요청해서 눈으로 확인해야 합니다. 이는 단위 테스트(Unit Test)의 부재로 이어져 코드의 안정성을 심각하게 저해합니다.</li>
<li><strong>&ldquo;어레이(Array) 문제&rdquo;:</strong> 텍스트가 명확히 짚은 이 문제는 매우 중요합니다. 위 예제에서 데이터는 <code>List&lt;Map&lt;String, Object&gt;&gt;</code> 형태로 전달됩니다. 다음 단계의 코드는 <code>map.get(&quot;title&quot;)</code>과 같이 문자열 키에 의존해야 합니다. 만약 키 이름을 <code>titel</code>로 오타를 내도 컴파일 시점에는 오류를 잡을 수 없고, 실행 후 페이지가 깨지거나 오류가 발생한 뒤에야 문제를 인지할 수 있습니다. 데이터의 구조가 명확하지 않아 개발자의 실수를 유발하기 매우 쉬운 구조입니다.</li>
</ul>
<hr>
<h3 id="제2장-역할의-분리-모델-2-아키텍처의-등장-mvc-패턴">제2장: 역할의 분리, 모델 2 아키텍처의 등장 (MVC 패턴)</h3>
<p>이러한 모델 1의 혼돈을 해결하기 위해 등장한 것이 바로 <strong>모델 2 아키텍처</strong>, 즉 우리에게 친숙한 <strong>MVC(Model-View-Controller) 패턴</strong>입니다. 모델 2의 핵심 철학은 &lsquo;관심사의 분리(Separation of Concerns)&lsquo;입니다. 각자 잘하는 일에만 집중하자는 것입니다.</p>
<ul>
<li><strong>Controller:</strong> 사용자의 요청을 가장 먼저 받는 &lsquo;교통 경찰&rsquo;입니다. 요청(URL, 파라미터 등)을 분석하여 어떤 작업이 필요한지 판단하고, 그 작업을 실제 일꾼인 &lsquo;Service&rsquo;에게 위임합니다. 작업이 끝나면 결과를 받아 어떤 &lsquo;View&rsquo;에게 전달하여 화면을 그리게 할지 결정합니다.</li>
<li><strong>Model:</strong> 실질적인 데이터와 비즈니스 로직을 담당하는 영역입니다. &ldquo;게시글을 저장한다&rdquo;, &ldquo;사용자 레벨을 업그레이드한다&quot;와 같은 핵심 로직이 여기에 포함됩니다. 현대 개발에서는 이를 다시 <strong>Service</strong>와 <strong>Repository</strong>로 세분화합니다.</li>
<li><strong>View:</strong> Controller로부터 전달받은 데이터를 화면에 &lsquo;그리는&rsquo; 일만 합니다. JSP, Thymeleaf 등이 여기에 해당하며, 내부에는 비즈니스 로직이 전혀 없고 오직 표현 로직만 존재합니다.</li>
</ul>
<p><strong>1. 모델 2의 정제: Controller-Service-Repository 구조</strong></p>
<p>텍스트에서 설명하듯, 현대적인 모델 2 구현은 Model 영역을 더욱 구체적으로 분화하여 책임과 역할을 명확히 합니다.</p>
<ul>
<li><strong>Controller:</strong> 오직 웹 요청과 응답에만 집중합니다. HTTP 헤더를 분석하고, 요청 본문을 객체로 변환하며, 인증/인가를 확인하고, 적절한 Service 메소드를 호출한 뒤, 그 결과를 JSON, HTML 등 요청된 형식으로 변환하여 응답합니다.
<ul>
<li><em>예시: <code>/posts</code> (GET 요청) -&gt; <code>PostController.getPostList()</code> 호출</em></li>
</ul>
</li>
<li><strong>Service:</strong> &lsquo;비즈니스 로직&rsquo;의 중심입니다. 트랜잭션 관리, 여러 데이터 소스 조합 등 애플리케이션의 핵심 정책과 규칙을 구현합니다. 이 계층은 웹(HTTP)이나 데이터베이스(SQL) 기술에 의존하지 않는 순수한 자바 코드로 작성되는 것을 지향합니다.
<ul>
<li><em>예시: <code>PostService.getPostList()</code> -&gt; 게시글 목록 조회 로직 수행. 필요하다면 <code>UserService</code>를 호출하여 작성자 정보를 함께 가져올 수도 있음.</em></li>
<li><strong>재사용성의 핵심:</strong> 텍스트의 &ldquo;웹에서 작동했던 게시판의 기능을 단말 어플로 확장해야 할 때 서비스의 고유 기능을 유지한 상태에서 컨트롤러의 기능만 수정&quot;할 수 있다는 설명이 바로 이 지점입니다. 모바일 앱을 위한 JSON 응답이 필요하면, 기존 <code>PostService</code>는 그대로 두고 <code>ApiPostController</code>를 새로 만들어 동일한 서비스를 호출하기만 하면 됩니다. 핵심 로직의 재사용성이 극대화됩니다.</li>
</ul>
</li>
<li><strong>Repository(DAO):</strong> 데이터 영속성(Persistence)만을 전담합니다. 즉, 데이터베이스에 데이터를 저장(Save), 조회(Find), 수정(Update), 삭제(Delete)하는 역할만 수행합니다.
<ul>
<li><em>예시: <code>PostRepository.findAll()</code> -&gt; <code>SELECT * FROM post</code> 쿼리 실행</em></li>
<li><strong>유지보수의 효율성:</strong> 텍스트의 &ldquo;테이블 구조 변경 시 리파지토리 수정만으로 적용이 가능&quot;하다는 설명이 여기에 해당합니다. 데이터베이스가 MySQL에서 PostgreSQL로 바뀌거나, ORM 기술(JPA 등)을 도입할 때, 오직 Repository 계층의 코드만 수정하면 Service나 Controller는 아무런 영향을 받지 않습니다.</li>
</ul>
</li>
</ul>
<p><strong>2. 소통의 규약: DTO (Data Transfer Object)</strong></p>
<p>모델 1의 &lsquo;어레이 문제&rsquo;를 해결하는 모델 2의 해법이 바로 <strong>DTO</strong>입니다. 텍스트에서는 &lsquo;데이터 전달 객체&rsquo;라고 표현했습니다.</p>
<ul>
<li><strong>DTO란?</strong> 계층 간 데이터 교환을 위해 사용하는, 데이터 필드(멤버 변수)와 그에 대한 Getter/Setter 메소드만으로 이루어진 순수한 데이터 운반용 객체입니다.</li>
<li><strong>장점:</strong>
<ul>
<li><strong>명확한 계약:</strong> DTO는 그 자체로 계층 간에 &ldquo;우리는 이런 구조의 데이터를 주고받을 것이다&quot;라는 명확한 약속(Contract)이 됩니다.</li>
<li><strong>타입 안정성(Type Safety):</strong> <code>map.get(&quot;title&quot;)</code> 대신 <code>postDto.getTitle()</code>을 사용합니다. <code>getTitle()</code> 메소드는 항상 문자열(String)을 반환함이 보장되며, 만약 <code>getTitel()</code>과 같이 오타를 내면 컴파일 시점에 즉시 오류를 발견할 수 있습니다.</li>
<li><strong>개발 편의성:</strong> IDE의 자동완성 기능 등을 통해 어떤 데이터가 있는지 쉽게 파악할 수 있어 생산성이 향상됩니다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="제3장-궁극의-유연성-의존성-주입-dependency-injection">제3장: 궁극의 유연성, 의존성 주입 (Dependency Injection)</h3>
<p>모델 2 구조로 역할을 분리하고 DTO로 소통 규약을 정했지만, 마지막 문제가 남아있습니다. &ldquo;실제 구현에서 각각의 기능을 연동하기 위한 코드가 생성되어 기능의 독립성이 사라지는 문제&quot;입니다.</p>
<p><code>PostController</code>가 <code>PostService</code>를 사용하려면 어떻게 해야 할까요? 가장 단순한 방법은 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PostController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> PostService postService <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PostServiceImpl(); <span style="color:#75715e">// ★ 문제 지점!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>PostController</code>가 <code>PostServiceImpl</code>이라는 &lsquo;구체적인 구현 클래스&rsquo;를 직접 생성하고 있습니다. 이를 **&lsquo;강한 결합(Tight Coupling)&rsquo;**이라고 합니다. 이 코드의 문제는, 만약 <code>PostService</code>의 구현체를 테스트용 <code>TestPostServiceImpl</code>로 바꾸고 싶을 때 <code>PostController</code>의 코드를 직접 수정해야 한다는 것입니다. 각 기능의 독립적인 개발과 테스트가 다시 어려워집니다.</p>
<p><strong>1. 의존성 주입(DI)과 제어의 역전(IoC)</strong></p>
<p>이 문제를 해결하는 기술이 바로 **의존성 주입(DI)**입니다. DI의 근간에는 **제어의 역전(Inversion of Control, IoC)**이라는 원리가 있습니다.</p>
<ul>
<li><strong>기존 방식:</strong> <code>PostController</code>가 자신이 사용할 <code>PostService</code> 객체를 **직접 생성(제어)**한다.</li>
<li><strong>IoC/DI 방식:</strong> <code>PostController</code>는 <code>PostService</code> 객체를 생성하지 않는다. 단지 &ldquo;나는 <code>PostService</code> 타입의 객체가 필요해!&ldquo;라고 선언만 해둔다. 그러면 **외부의 누군가(DI 컨테이너, 예: 스프링 프레임워크)**가 <code>PostController</code>에게 필요한 <code>PostService</code> 객체를 만들어서 **주입(연결)**해준다. 객체를 생성하고 연결하는 &lsquo;제어&rsquo;의 흐름이 개발자 코드에서 프레임워크로 역전된 것입니다.</li>
</ul>
<p><strong>2. &ldquo;동물이 오리로 변하고 강아지로 변한다&quot;는 비유의 해석</strong></p>
<p>텍스트의 이 비유는 DI의 핵심을 완벽하게 설명합니다.</p>
<ul>
<li><strong><code>동물</code> (Animal):</strong> 이것이 바로 **인터페이스(Interface)**입니다. <code>소리를 내다(makeSound())</code>라는 &lsquo;기능(메소드)&lsquo;을 약속(정의)합니다.</li>
<li><strong><code>오리</code>(Duck), <code>강아지</code>(Dog):</strong> 이것이 **구현체(Implementation)**입니다. <code>동물</code> 인터페이스를 구현하여, <code>소리를 내다()</code> 메소드를 <code>꽤액꽤액</code> 또는 <code>멍멍</code>으로 구체화합니다.</li>
<li><strong><code>사육사</code>(Zookeeper):</strong> <code>동물</code>을 필요로 하는 클라이언트 코드(예: <code>Controller</code>, <code>Service</code>)입니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 인터페이스 (약속)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Animal</span> {
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">makeSound</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 구현체 1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Duck</span> <span style="color:#66d9ef">implements</span> Animal {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">makeSound</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;꽤액꽤액&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 구현체 2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">implements</span> Animal {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">makeSound</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;멍멍&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 클라이언트 (스프링에서의 예시)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@RestController</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ZookeeperController</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Animal animal; <span style="color:#75715e">// &#39;구현체&#39;가 아닌 &#39;인터페이스&#39;에 의존!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 생성자를 통해 외부에서 Animal 객체를 주입받음 (DI)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ZookeeperController</span>(Animal animal) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">animal</span> <span style="color:#f92672">=</span> animal;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@GetMapping</span>(<span style="color:#e6db74">&#34;/sound&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">hearSound</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 주입된 객체가 Dog라면 &#34;멍멍&#34;, Duck이라면 &#34;꽤액꽤액&#34;이 반환됨</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> animal.<span style="color:#a6e22e">makeSound</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ZookeeperController</code>는 <code>Dog</code>인지 <code>Duck</code>인지 전혀 모릅니다. 단지 <code>Animal</code> 인터페이스에 정의된 <code>makeSound()</code>를 호출할 뿐입니다. 어떤 동물이 주입될지는 스프링 프레임워크가 설정(Configuration)에 따라 **런타임(실행 시점)**에 결정하여 &lsquo;동적으로&rsquo; 연결해줍니다. 이것이 바로 텍스트에서 말한 &ldquo;인터페이스로 연동하여 기능이 실행되는 런타임에서 인터페이스의 구현체를 주입하는 방식&quot;이며, &ldquo;동적 생성&quot;의 진정한 의미입니다.</p>
<p>이러한 DI를 통해, 우리는 테스트 시에는 실제 DB에 접근하는 <code>RealPostRepository</code> 대신, 메모리에서 가짜 데이터를 반환하는 <code>MockPostRepository</code>를 <code>PostService</code>에 주입하여 DB 없이도 Service 로직을 완벽하게 테스트할 수 있게 됩니다. 각 계층이 완벽하게 분리되어 독립적인 개발과 테스트가 가능해지는 것입니다.</p>
<hr>
<h3 id="결론-정적인-코드에서-동적인-아키텍처로">결론: 정적인 코드에서 동적인 아키텍처로</h3>
<p>모델 1에서 모델 2로의 발전, 그리고 DI의 도입은 단순히 코드를 정리하는 수준을 넘어 개발의 패러다임을 바꾼 혁신입니다.</p>
<ul>
<li><strong>모델 1:</strong> 모든 것이 얽힌 <strong>정적인 구조</strong>. 변경에 취약하고 재사용이 불가능하며 테스트가 어렵다.</li>
<li><strong>모델 2 (MVC):</strong> 역할과 책임을 분리하여 <strong>느슨한 결합</strong>을 추구. 유지보수성과 재사용성의 기틀을 마련.</li>
<li><strong>모델 2 + DI:</strong> 인터페이스를 통한 의존성 주입으로 결합을 끊어내고 <strong>동적인 구조</strong>를 완성. 각 기능의 완벽한 독립성과 테스트 용이성을 확보하여 유연하고 확장 가능한 시스템을 구축.</li>
</ul>
<p>&ldquo;백엔드 개발자는 기본적인 문법의 영적이고 확장적인 기능을 파악하여 정적인 기능을 동쪽으로 유도할 줄 아는 능력이 필요합니다&quot;는 이 모든 과정을 함축합니다. 훌륭한 백엔드 개발자는 단순히 문법에 맞춰 코드를 작성하는 사람이 아닙니다. 변화를 예측하고, 각 기능이 독립적으로 존재하며 서로 유연하게 협력할 수 있는 &lsquo;구조&rsquo;를 설계할 줄 아는 사람입니다. 딱딱하게 굳어있는 정적인 코드를, 언제든 다른 부품으로 교체할 수 있는 유연하고 살아있는 동적인 시스템으로 만드는 능력, 이것이 바로 모델 2와 DI가 우리에게 가르쳐주는 핵심 교훈이자 현대 백엔드 개발자가 갖춰야 할 가장 중요한 역량입니다.</p>
<hr>
<p>문제</p>
<p>순수 Java 코드(Plain Old Java Object, POJO)로 시작하여 프레임워크 없이 각 개념을 구현해보는 실습입니다.</p>
<hr>
<h3 id="stage-1-모델-1---모든-것이-섞여있는-코드">Stage 1: 모델 1 - 모든 것이 섞여있는 코드</h3>
<p><strong>🎯 목표:</strong> 왜 모델 1 아키텍처가 유지보수에 재앙인지 코드로 직접 경험합니다. 하나의 클래스 안에서 요청 분석, 데이터 처리, 화면 생성이 모두 일어나는 상황의 문제점을 느껴봅니다.</p>
<p>📝 문제:</p>
<p>PostManager라는 클래스를 만드세요. 이 클래스는 main 메소드를 가지고 있으며, 실행하면 게시판 목록을 HTML 문자열 형태로 콘솔에 출력해야 합니다.</p>
<p><strong>요구사항:</strong></p>
<ol>
<li>
<p><code>PostManager</code> 클래스 안에 게시물 데이터를 <code>List&lt;Map&lt;String, Object&gt;&gt;</code> 형태로 하드코딩하여 가지고 있으세요. (DB 연결 흉내)</p>
</li>
<li>
<p>이 데이터를 <code>&lt;table&gt;</code> 태그를 사용한 HTML 형식으로 변환하는 로직을 구현하세요.</p>
</li>
<li>
<p>모든 로직(데이터 정의, HTML 생성)은 <code>main</code> 메소드 또는 <code>PostManager</code> 클래스 내의 private 메소드에 전부 포함되어야 합니다.</p>
</li>
</ol>
<p><strong>🔑 핵심 질문:</strong></p>
<ul>
<li>
<p>만약 테이블의 <code>&lt;th&gt;</code> 순서를 바꾸거나 <code>&lt;td&gt;</code>에 CSS 클래스를 추가하는 등 <strong>디자인을 변경</strong>하고 싶다면 코드를 얼마나, 어디를 수정해야 하나요?</p>
</li>
<li>
<p>게시물 목록 데이터를 HTML이 아닌 <strong>JSON 형식으로도 제공</strong>해야 한다는 새로운 요구사항이 생겼다면 어떻게 해야 할까요? 코드 재사용이 가능한가요?</p>
</li>
</ul>
<hr>
<h3 id="stage-2-모델-2-mvc---역할의-분리">Stage 2: 모델 2 (MVC) - 역할의 분리</h3>
<p><strong>🎯 목표:</strong> 모델 1의 문제를 해결하기 위해 &lsquo;관심사의 분리&rsquo;를 적용합니다. Controller, Service, View의 역할을 하는 클래스들을 만들어 코드를 분리합니다.</p>
<p>📝 문제:</p>
<p>Stage 1의 PostManager를 Controller, Service, View 역할로 나누어 리팩토링하세요.</p>
<p><strong>요구사항:</strong></p>
<ol>
<li>
<p><strong><code>PostController</code></strong>: 요청을 받는 진입점. <code>PostService</code>를 호출하여 데이터를 받고, 받은 데이터를 <code>PostView</code>에 넘겨 최종 결과를 받아옵니다.</p>
<ul>
<li><code>PostController</code> 내부에 <code>private PostService postService = new PostServiceImpl();</code> 와 같이 <strong>서비스 객체를 직접 생성</strong>해야 합니다.</li>
</ul>
</li>
<li>
<p><strong><code>PostService</code></strong>: 비즈니스 로직과 데이터 처리를 담당. 게시물 목록 데이터를 <code>List&lt;Map&lt;String, Object&gt;&gt;</code> 형태로 반환하는 메소드를 제공합니다. (Stage 1의 데이터 처리 로직을 그대로 가져옵니다)</p>
</li>
<li>
<p><strong><code>PostView</code></strong>: 데이터를 받아 최종 HTML을 생성하는 역할만 합니다. 로직 없이 데이터를 화면에 그리는 데 집중합니다.</p>
</li>
</ol>
<p><strong>🔑 핵심 질문:</strong></p>
<ul>
<li>
<p>이제 디자인 변경(View 수정)이나 데이터 소스 변경(Service 수정)이 이전보다 쉬워졌나요?</p>
</li>
<li>
<p><code>PostController</code>가 <code>PostServiceImpl</code>을 직접 생성(<code>new</code>)하고 있습니다. 만약 테스트를 위해 다른 가짜 <code>Service</code> 객체를 사용하고 싶다면, <code>PostController</code>의 코드를 수정해야만 하는가요? 이것이 어떤 문제를 일으킬까요? (이것이 바로 <strong>강한 결합(Tight Coupling)</strong> 입니다.)</p>
</li>
</ul>
<hr>
<h3 id="stage-3-dto-도입---명확한-데이터-계약">Stage 3: DTO 도입 - 명확한 데이터 계약</h3>
<p><strong>🎯 목표:</strong> 모델 2 구조에서 계층 간 데이터를 <code>Map</code>이 아닌 DTO(Data Transfer Object)로 주고받도록 개선합니다. &lsquo;어레이 문제&rsquo;를 해결하고 타입 안정성을 확보하는 과정을 이해합니다.</p>
<p>📝 문제:</p>
<p>Stage 2의 코드에서 List&lt;Map&lt;String, Object&raquo;를 사용하는 모든 부분을 PostDto를 사용하도록 변경하세요.</p>
<p><strong>요구사항:</strong></p>
<ol>
<li>
<p><strong><code>PostDto</code> 클래스</strong>를 생성하세요. <code>id</code>, <code>title</code>, <code>writer</code> 필드와 각 필드에 대한 Getter 메소드를 가져야 합니다.</p>
</li>
<li>
<p>**<code>PostService</code>**는 이제 <code>List&lt;PostDto&gt;</code>를 반환하도록 수정합니다. 내부적으로 <code>Map</code>을 <code>PostDto</code> 객체로 변환하는 과정이 필요합니다.</p>
</li>
<li>
<p>**<code>PostController</code>**와 **<code>PostView</code>**는 <code>Map</code> 대신 <code>PostDto</code>를 사용하여 데이터를 처리하고 화면을 생성하도록 수정합니다. <code>map.get(&quot;title&quot;)</code> 대신 <code>dto.getTitle()</code>을 사용하게 됩니다.</p>
</li>
</ol>
<p><strong>🔑 핵심 질문:</strong></p>
<ul>
<li>
<p><code>dto.getTitel()</code> 처럼 오타를 냈을 때, 컴파일 시점에 오류를 발견할 수 있나요? <code>Map</code>을 사용할 때와 비교하여 어떤 점이 좋아졌나요?</p>
</li>
<li>
<p>DTO를 사용함으로써 <code>Service</code>와 <code>Controller</code> 사이에 &ldquo;어떤 형태의 데이터를 주고받을지&quot;에 대한 약속이 명확해졌나요?</p>
</li>
</ul>
<hr>
<h3 id="stage-4-의존성-주입-di---궁극의-유연성-확보">Stage 4: 의존성 주입 (DI) - 궁극의 유연성 확보</h3>
<p><strong>🎯 목표:</strong> 인터페이스를 도입하고 외부에서 의존성을 주입하여 각 컴포넌트 간의 결합을 끊어냅니다. 이를 통해 기능의 교체가 유연해지고 테스트가 쉬워지는 것을 확인합니다.</p>
<p>📝 문제:</p>
<p>Stage 3의 강한 결합 문제를 해결하기 위해 의존성 주입(DI) 원리를 적용하세요.</p>
<p><strong>요구사항:</strong></p>
<ol>
<li>
<p><strong><code>PostService</code> 인터페이스</strong>를 만드세요. (<code>List&lt;PostDto&gt; getPosts()</code> 메소드 선언)</p>
</li>
<li>
<p>기존 <code>PostService</code> 클래스의 이름을 **<code>PostServiceImpl</code>**로 바꾸고 <code>PostService</code> 인터페이스를 구현(<code>implements</code>)하도록 하세요.</p>
</li>
<li>
<p>**<code>PostController</code>**가 더 이상 <code>PostServiceImpl</code>을 직접 생성하지 않도록 수정합니다. 대신 <code>PostService</code> 인터페이스 타입의 멤버 변수를 선언하고, <strong>생성자를 통해 외부에서 <code>PostService</code> 구현체를 주입</strong>받도록 변경하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PostController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> PostService postService;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 생성자를 통해 의존성 주입</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">PostController</span>(PostService postService) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">postService</span> <span style="color:#f92672">=</span> postService;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong><code>Main</code> (또는 <code>Application</code>) 클래스</strong>를 만들어 <strong>DI 컨테이너</strong>의 역할을 하도록 합니다. 이 클래스가 <code>PostServiceImpl</code> 객체를 생성하고, 이 객체를 <code>PostController</code>의 생성자에 인자로 넘겨주어 전체 시스템을 조립하고 실행합니다.</p>
</li>
<li>
<p><strong>(심화)</strong> <code>TestPostServiceImpl</code>이라는 <code>PostService</code>의 또 다른 구현체를 만드세요. 이 클래스는 테스트용 고정 데이터(&ldquo;테스트 제목 1&rdquo;, &ldquo;테스트 제목 2&rdquo; 등)를 반환하도록 합니다. <code>Main</code> 클래스에서 <code>PostServiceImpl</code> 대신 <code>TestPostServiceImpl</code>을 주입했을 때, <code>Controller</code> 코드를 전혀 바꾸지 않고도 프로그램의 동작이 바뀌는 것을 확인하세요.</p>
</li>
</ol>
<p><strong>🔑 핵심 질문:</strong></p>
<ul>
<li>
<p>&lsquo;사육사(<code>Controller</code>)&lsquo;는 &lsquo;동물(<code>Service</code> 인터페이스)&lsquo;에게 일을 시킬 뿐, 실제 일하는 동물이 &lsquo;오리(<code>ServiceImpl</code>)&lsquo;인지 &lsquo;강아지(<code>TestServiceImpl</code>)&lsquo;인지 더 이상 신경 쓰지 않게 되었습니다. 이로 인해 얻는 가장 큰 이점은 무엇일까요?</p>
</li>
<li>
<p>이제 <code>PostService</code> 로직만 따로 테스트하는 것이 얼마나 쉬워졌나요? 이것이 바로 **단위 테스트(Unit Test)**의 시작입니다.</p>
</li>
</ul>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
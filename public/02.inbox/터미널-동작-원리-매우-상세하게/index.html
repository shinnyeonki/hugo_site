<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>터미널 동작 원리 매우 상세하게 | My Test Site</title>
    

    
    
    <meta name="description" content="터미널의 동작원리를 정확하게 이해하기 위해 터미널의 구성요소를 먼저 알아보고 case 별로 어떤 방식으로 이벤트가 전달되는가를 확인해보자
터미널의 구성 요소와 역할 터미널 환경은 크게 **3개의 행위자(Actor)**와 이들을 연결하는 **1개의 통신 채널 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/%ED%84%B0%EB%AF%B8%EB%84%90-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EB%A7%A4%EC%9A%B0-%EC%83%81%EC%84%B8%ED%95%98%EA%B2%8C/">

    
    
    
    <meta property="og:title" content="터미널 동작 원리 매우 상세하게">
    <meta property="og:description" content="터미널의 동작원리를 정확하게 이해하기 위해 터미널의 구성요소를 먼저 알아보고 case 별로 어떤 방식으로 이벤트가 전달되는가를 확인해보자
터미널의 구성 요소와 역할 터미널 환경은 크게 **3개의 행위자(Actor)**와 이들을 연결하는 **1개의 통신 채널 …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/%ED%84%B0%EB%AF%B8%EB%84%90-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EB%A7%A4%EC%9A%B0-%EC%83%81%EC%84%B8%ED%95%98%EA%B2%8C/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="터미널 동작 원리 매우 상세하게">
    <meta name="twitter:description" content="터미널의 동작원리를 정확하게 이해하기 위해 터미널의 구성요소를 먼저 알아보고 case 별로 어떤 방식으로 이벤트가 전달되는가를 확인해보자
터미널의 구성 요소와 역할 터미널 환경은 크게 **3개의 행위자(Actor)**와 이들을 연결하는 **1개의 통신 채널 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>터미널 동작 원리 매우 상세하게 **page.html**</h1>
    <p>터미널의 동작원리를 정확하게 이해하기 위해 터미널의 구성요소를 먼저 알아보고 case 별로 어떤 방식으로 이벤트가 전달되는가를 확인해보자</p>
<hr>
<h3 id="터미널의-구성-요소와-역할"><strong>터미널의 구성 요소와 역할</strong></h3>
<p>터미널 환경은 크게 **3개의 행위자(Actor)**와 이들을 연결하는 **1개의 통신 채널(Channel)**로 구성됩니다. 각 요소가 어떤 일을 하는지 명확히 구분하는 것이 중요합니다.</p>
<h4 id="터미널-에뮬레이터-terminal-emulator-예"><strong>터미널 에뮬레이터 (Terminal Emulator, 예: <code>gnome-terminal</code>, <code>iTerm2</code>)</strong></h4>
<ul>
<li>
<p><strong>역할:</strong> 사용자를 위한 그래픽 인터페이스(GUI 창)를 제공하고, 그래픽 시스템과 바이트 스트림 간의 번역을 담당합니다.</p>
</li>
<li>
<p><strong>입력 처리:</strong></p>
<ul>
<li><strong>누구에게 받아서:</strong> <strong>사용자</strong>로부터 키보드 입력, 마우스 클릭 등 <strong>그래픽 시스템 이벤트</strong>를 받습니다.</li>
<li><strong>무엇을 하는가:</strong> 이벤트를 해석하여 약속된 <strong>바이트(byte) 데이터</strong>로 변환합니다.
<ul>
<li><code>A</code> 키 → <code>0x41</code> 바이트</li>
<li><code>위쪽 화살표</code> 키 → <code>\033[A</code> (이스케이프 시퀀스)</li>
</ul>
</li>
<li><strong>어디에 전달:</strong> 변환된 바이트 데이터를 <strong>PTY 통신 채널의 마스터(Master) 측 파일 디스크립터에 씁니다(write).</strong></li>
</ul>
</li>
<li>
<p><strong>출력 처리:</strong></p>
<ul>
<li><strong>어디에서 받아서:</strong> <strong>PTY 통신 채널의 마스터(Master) 측 파일 디스크립터에서</strong> 바이트 데이터를 읽습니다(read).</li>
<li><strong>무엇을 하는가:</strong> 읽어들인 바이트 스트림을 해석하여 화면에 <strong>글자나 그래픽 요소로 렌더링</strong>합니다. 이것이 에뮬레이터의 핵심 기능입니다.
<ul>
<li><code>hello</code> 같은 일반 텍스트는 그대로 화면에 그립니다.</li>
<li><code>\033[1m</code> (굵게), <code>\033[31m</code> (빨간색) 같은 <strong>이스케이프 시퀀스</strong>는 명령으로 해석하여 글자의 스타일을 바꿔서 그립니다.</li>
</ul>
</li>
<li><strong>누구에게 전달:</strong> 렌더링 결과를 <strong>사용자</strong> 눈에 보이는 화면(GUI 창)에 표시합니다.</li>
</ul>
</li>
</ul>
<h4 id="통신-채널-pty-pseudo-terminal"><strong>통신 채널: PTY (Pseudo-Terminal)</strong></h4>
<ul>
<li><strong>역할:</strong> 터미널 에뮬레이터와 셸(애플리케이션) 사이의 양방향 통신 파이프 역할을 합니다. <strong>커널</strong>에 의해 생성되고 관리되는 **가상 장치(Virtual Device)**입니다.</li>
<li><strong>구조:</strong> 두 개의 끝점으로 구성됩니다.
<ul>
<li><strong>PTY 마스터(Master) 파일 디스크립터</strong>: 터미널 에뮬레이터가 사용하는 통신 끝점입니다.</li>
<li><strong>PTY 슬레이브(Slave) 파일 디스크립터</strong>: 셸(애플리케이션)이 사용하는 통신 끝점입니다. <code>/dev/pts/N</code> 형태의 장치 파일에 해당합니다.</li>
</ul>
</li>
<li><strong>특징:</strong> PTY 자체는 단순한 데이터 통로이지만, 이 통로를 지나는 데이터는 <strong>커널의 TTY 드라이버</strong>에 의해 감시되고 처리됩니다.</li>
</ul>
<h4 id="행위자-2-커널-kernel의-ttypty-드라이버"><strong>행위자 2: 커널 (Kernel)의 TTY/PTY 드라이버</strong></h4>
<ul>
<li><strong>역할:</strong> PTY 통신 채널의 중간에서 데이터를 중계하며, 전통적인 터미널의 동작 규칙(Line Discipline)을 적용하는 <strong>실제 두뇌</strong>입니다.</li>
<li><strong>기능 (주로 <code>cooked</code> 모드일 때):</strong>
<ul>
<li><strong>어디에서 받아서:</strong> <strong>PTY 마스터 FD</strong>에 쓰인 데이터를 읽고, <strong>PTY 슬레이브 FD</strong>에 쓰인 데이터를 읽습니다.</li>
<li><strong>무엇을 하는가 (마스터 → 슬레이브 방향):</strong>
<ul>
<li><strong>문자 에코 (Echo):</strong> PTY 마스터로부터 받은 입력 바이트를 다시 PTY 마스터 쪽으로 되돌려 써서, 터미널 에뮬레이터가 사용자가 입력한 내용을 화면에 표시하게 합니다.</li>
<li><strong>입력 편집 (Line Buffering):</strong> <code>Enter</code>가 입력될 때까지 데이터를 내부 버퍼에 모으고, <code>Backspace</code> 같은 편집 문자를 해석하여 버퍼를 수정합니다.</li>
<li><strong>신호(Signal) 생성:</strong> <code>Ctrl+C</code>에 해당하는 바이트(<code>0x03</code>)를 감지하면, 이를 데이터로 전달하는 대신 커널의 프로세스 관리자에게 <strong><code>SIGINT</code> 신호를 생성하도록 요청</strong>합니다. 이 신호는 PTY 슬레이브에 연결된 전면 프로세스 그룹에 전달됩니다.</li>
</ul>
</li>
<li><strong>무엇을 하는가 (슬레이브 → 마스터 방향):</strong>
<ul>
<li><strong>단순 중계:</strong> 일반적으로 셸(애플리케이션)이 PTY 슬레이브에 쓴 출력 데이터는 특별한 처리 없이 그대로 PTY 마스터 쪽으로 전달합니다.</li>
</ul>
</li>
<li><strong>어디에 전달:</strong> 처리된 데이터를 반대편 파일 디스크립터에서 읽을 수 있도록 준비시킵니다.</li>
</ul>
</li>
<li><strong>제어:</strong> 셸이나 애플리케이션은 <code>ioctl()</code> 시스템 콜을 통해 이 드라이버의 동작 방식(<code>raw</code> 모드, <code>ECHO</code> 끄기 등)을 변경할 수 있습니다.</li>
</ul>
<h4 id="행위자-3-셸--터미널-애플리케이션-shell--eg"><strong>행위자 3: 셸 / 터미널 애플리케이션 (Shell / e.g., <code>bash</code>, <code>vim</code>)</strong></h4>
<ul>
<li><strong>역할:</strong> 사용자의 명령을 실행하고 그 결과를 제공하는 프로그램입니다.</li>
<li><strong>기능:</strong>
<ul>
<li><strong>어디에서 받아서:</strong> 자신의 표준 입력(stdin), 즉 <strong>PTY 슬레이브 파일 디스크립터</strong>로부터 데이터를 읽습니다.</li>
<li><strong>무엇을 하는가:</strong> <strong>커널 드라이버</strong>에 의해 가공된(또는 <code>raw</code> 모드에서는 가공되지 않은) 데이터를 읽어 명령어로 해석하고 실행합니다.
<ul>
<li><code>ls\n</code>: <code>ls</code> 명령을 실행.</li>
<li><code>\033[A</code> (화살표 키): 히스토리 검색 기능 실행.</li>
</ul>
</li>
<li><strong>어디에 전달:</strong> 실행 결과(텍스트)나 화면 제어를 위한 이스케이프 시퀀스를 자신의 표준 출력(stdout) 또는 표준 에러(stderr), 즉 <strong>PTY 슬레이브 파일 디스크립터에 씁니다.</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="역할-분담-터미널-에뮬레이터-vs-커널-pty-드라이버드라이버는-커널인가">역할 분담: 터미널 에뮬레이터 vs. 커널 (PTY 드라이버)<a href="http://localhost:1313/02.inbox/%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84%EB%8A%94-%EC%BB%A4%EB%84%90%EC%9D%B8%EA%B0%80/" class="internal-link">드라이버는 커널인가</a></h3>
<table>
  <thead>
      <tr>
          <th style="text-align: left">기능</th>
          <th style="text-align: left">담당자</th>
          <th style="text-align: left">설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong><code>Ctrl+C</code> 입력 시 <code>SIGINT</code> 신호 전달</strong></td>
          <td style="text-align: left"><strong>커널 (PTY 드라이버)</strong></td>
          <td style="text-align: left">에뮬레이터는 제어문자(<code>0x03</code>)만 보내면, 커널이 이를 해석해 전면 프로세스 그룹(foreground process group)에 신호를 보냅니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong><code>read -s</code> (입력 숨기기)</strong></td>
          <td style="text-align: left"><strong>커널 (PTY 드라이버)</strong></td>
          <td style="text-align: left">셸이 <code>ioctl(TCSETSW)</code>로 echo 모드를 끄면, 커널(PTY 드라이버)이 입력 문자를 되돌려 보내지 않습니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong><code>stty raw</code> (Raw 모드 설정)</strong></td>
          <td style="text-align: left"><strong>커널 (PTY 드라이버)</strong></td>
          <td style="text-align: left">Raw 모드 설정 시, 커널은 줄 단위 편집, 신호 처리 등을 비활성화하고 바이트를 그대로 통과시킵니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>이스케이프 시퀀스 해석</strong></td>
          <td style="text-align: left"><strong>터미널 에뮬레이터</strong></td>
          <td style="text-align: left"><code>\033[1m</code>(굵게), <code>\033[31m</code>(빨강) 같은 시퀀스는 커널이 이해하지 못하며, 에뮬레이터가 직접 해석하여 화면에 렌더링해야 합니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>커서 이동, 화면 지우기</strong></td>
          <td style="text-align: left"><strong>터미널 에뮬레이터</strong></td>
          <td style="text-align: left"><code>clear</code>, <code>tput cup</code>, <code>vim</code> 등이 사용하는 화면 제어 이스케이프 시퀀스를 에뮬레이터가 이해하고 커서 위치를 바꾸거나 화면을 다시 그려야 합니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>UTF-8 등 다중 바이트 문자 처리</strong></td>
          <td style="text-align: left"><strong>터미널 에뮬레이터</strong></td>
          <td style="text-align: left"><code>ä</code>, <code>한</code>, <code>😊</code> 같은 문자가 깨지지 않고 올바른 폭으로 렌더링되도록 처리하는 것은 에뮬레이터의 몫입니다.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>줄 바꿈, 줄 감김 (Line Wrap)</strong></td>
          <td style="text-align: left"><strong>터미널 에뮬레이터</strong></td>
          <td style="text-align: left">한 줄의 끝(예: 80자)을 넘어서는 문자가 입력될 때 다음 줄로 넘길지, 개행 문자를 어떻게 처리할지 등을 에뮬레이터가 결정하고 구현해야 합니다.</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p><strong>🔺 핵심 요약:</strong> <strong>커널(PTY 드라이버)은 입출력 중계와 신호/모드 처리를 담당</strong>하고, <strong>터미널 에뮬레이터는 화면에 보이는 모든 시각적 표현(렌더링)을 책임</strong>집니다.</p>
</blockquote>
<hr>
<h3 id="case-별-구성요소들의-처리-과정">Case 별 구성요소들의 처리 과정</h3>
<h4 id="핵심-데이터-흐름-두-개의-파이프라인"><strong>핵심 데이터 흐름: 두 개의 파이프라인</strong></h4>
<ol>
<li>
<p><strong>사용자 입력 파이프라인 (Input Flow: 키보드 입력이 셸에 도달하기까지)</strong></p>
<blockquote>
<p><strong>에뮬레이터</strong> <code>(키 입력→바이트 변환)</code> → <strong>PTY Master</strong> → <strong>커널 (PTY 드라이버 → TTY 서브시스템)</strong> <code>(Echo, 버퍼링, 신호 처리)</code> → <strong>PTY Slave</strong> → <strong>셸/앱</strong> <code>(데이터 읽기)</code></p>
</blockquote>
</li>
<li>
<p><strong>프로그램 출력 파이프라인 (Output Flow: 프로그램 결과가 화면에 보이기까지)</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<blockquote>
<p><strong>셸/앱</strong> <code>(결과 출력)</code> → <strong>PTY Slave</strong> → <strong>커널 (PTY 드라이버)</strong> <code>(단순 중계)</code> → <strong>PTY Master</strong> → <strong>에뮬레이터</strong> <code>(바이트→화면 렌더링)</code></p>
</blockquote>
</li>
</ol>
<h4 id="case-1-사용자가"><strong>Case 1: 사용자가 <code>ls</code>를 입력하고 Enter를 누를 때 (가장 기본적인 흐름)</strong></h4>
<ol>
<li>
<p><strong>사용자</strong>: 키보드를 사용하여 <code>l</code>, <code>s</code>, 그리고 <code>Enter</code> 키를 순서대로 누릅니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터 (예: gnome-terminal)</strong>: 운영체제로부터 키보드 입력 이벤트를 전달받습니다. 이 프로그램은 각 키 입력이 어떤 바이트 데이터에 해당하는지 알고 있습니다.</p>
<ul>
<li><code>l</code> 키 → 바이트 <code>0x6C</code></li>
<li><code>s</code> 키 → 바이트 <code>0x73</code></li>
<li><code>Enter</code> 키 → 개행(Line Feed) 문자를 의미하는 바이트 <code>0x0A</code></li>
<li>이 바이트들을 순서대로, 자신이 프로세스를 시작할 때 열었던 <strong>PTY 마스터 파일 디스크립터(FD)에 씁니다(write 시스템 콜 사용).</strong></li>
</ul>
</li>
<li>
<p><strong>커널 (PTY/TTY 드라이버) - 입력 수신 및 처리</strong>: 커널은 누군가 PTY 마스터 FD에 데이터를 썼다는 것을 인지하고, 해당 데이터를 자신의 버퍼로 읽어들입니다. 현재 터미널은 기본 모드인 <strong><code>cooked</code> (또는 <code>canonical</code>) 모드</strong>로 동작하고 있으므로, 커널 드라이버는 다음과 같은 규칙을 적용합니다.</p>
<ul>
<li><strong>Echo 기능</strong>: 첫 번째 바이트 <code>0x6C</code>(<code>l</code>)를 읽자마자, 사용자가 자신이 무엇을 입력하고 있는지 볼 수 있도록 이 바이트를 즉시 <strong>PTY 마스터 FD 쪽으로 다시 써줍니다.</strong></li>
<li><strong>터미널 에뮬레이터 (Echo 표시)</strong>: 자신의 마스터 FD에서 읽을 데이터(<code>0x6C</code>)가 생긴 것을 감지하고, 이를 읽어 화면의 커서 위치에 <code>l</code>이라는 문자를 렌더링합니다.</li>
<li><strong>커널 드라이버 (Echo 반복)</strong>: 두 번째 바이트 <code>0x73</code>(<code>s</code>)에 대해서도 동일한 Echo 과정을 수행합니다. 터미널 에뮬레이터는 화면에 <code>s</code>를 이어서 표시합니다. 이제 화면에는 <code>ls</code>가 보입니다.</li>
<li><strong>Line Buffering 기능</strong>: 커널 드라이버는 <code>l</code>과 <code>s</code>를 Echo 처리함과 동시에, 자신의 **내부 라인 버퍼(line buffer)**에 이 문자들을 차곡차곡 쌓아둡니다. 이 버퍼는 셸과 같은 최종 애플리케이션에 아직 전달되지 않은, 편집 중인 한 줄의 데이터를 임시로 보관하는 장소입니다.</li>
<li><strong>Line Completion 기능</strong>: 마지막으로 <code>0x0A</code>(<code>Enter</code>) 바이트를 읽습니다. 커널 드라이버는 이 문자를 &ldquo;한 줄 입력의 끝&quot;으로 해석합니다. 이제 라인 버퍼에 저장되어 있던 <code>ls</code>와 방금 들어온 <code>\n</code>을 합쳐, <code>ls\n</code>이라는 완전한 한 줄의 데이터를 확정합니다.</li>
</ul>
</li>
<li>
<p><strong>커널 (PTY 드라이버) - 데이터 전달</strong>: 완성된 <code>ls\n</code> 데이터를 이제 <strong>PTY 슬레이브 파일 디스크립터(FD)에서 읽을 수 있도록 준비</strong>시킵니다. (정확히는, 슬레이브 FD를 <code>read()</code> 하고 있던 프로세스를 깨워서 데이터를 전달할 준비를 합니다.)</p>
</li>
<li>
<p><strong>셸 (bash)</strong>: 셸 프로세스는 시작된 이후로 계속해서 자신의 표준 입력(stdin), 즉 <strong>PTY 슬레이브 FD</strong>에 새로운 입력이 들어오기를 기다리며 대기(block)하고 있었습니다. 커널이 데이터를 준비시켰으므로, 셸은 <code>read()</code> 시스템 콜을 통해 드디어 <code>ls\n</code> 데이터를 읽어들입니다.</p>
</li>
<li>
<p><strong>셸 (명령어 해석 및 실행)</strong>: 셸은 읽어들인 <code>ls\n</code> 문자열을 해석합니다. 공백과 개행 문자를 기준으로 첫 번째 단어인 <code>ls</code>를 실행할 명령어로 인식합니다. 셸은 <code>fork()</code>와 <code>execve()</code> 시스템 콜을 사용하여 <code>ls</code>라는 새로운 프로세스를 생성하고 실행합니다. 이때, 자식 프로세스인 <code>ls</code>는 부모인 셸의 표준 입출력을 상속받으므로, <code>ls</code>의 표준 출력(stdout) 역시 <strong>PTY 슬레이브 FD</strong>를 가리키게 됩니다.</p>
</li>
<li>
<p><strong><code>ls</code> 프로세스</strong>: <code>ls</code> 프로그램은 현재 디렉토리의 파일 및 폴더 목록을 조회하여 텍스트 데이터(예: <code>file1.txt\nfolder1\nfile2.txt\n</code>)를 생성합니다. 이 결과 텍스트를 자신의 표준 출력(stdout)인 <strong>PTY 슬레이브 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY 드라이버) - 출력 중계</strong>: 슬레이브 측에 데이터가 쓰인 것을 감지하고, 이 데이터를 그대로 **PTY 마스터 FD 쪽으로 전달(중계)**합니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터 - 결과 렌더링</strong>: 터미널 에뮬레이터는 항상 자신의 <strong>PTY 마스터 FD</strong>에 읽을 데이터가 있는지 주시하고 있습니다. <code>ls</code>의 결과 텍스트가 도착하면, 이를 읽어서 화면에 렌더링합니다. 만약 텍스트에 색상 등을 위한 이스케이프 시퀀스가 포함되어 있다면, 이를 해석하여 색깔 있는 텍스트로 표시합니다.</p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> 사용자의 키 입력이 <strong>터미널 에뮬레이터 → 커널 드라이버(마스터 측) → 커널 드라이버의 처리(Echo, Buffering) → 커널 드라이버(슬레이브 측) → 셸</strong> 순서로 전달되고, 명령어의 결과는 역순으로 사용자에게 돌아오는 가장 기본적인 파이프라인 구조를 보여줌.</p>
</blockquote>
<hr>
<h4 id="case-2-사용자가"><strong>Case 2: 사용자가 <code>Ctrl+C</code>를 누를 때 (신호 처리)</strong></h4>
<ol>
<li>
<p><strong>상황</strong>: 사용자가 셸에서 <code>sleep 100</code> 같은 오래 걸리는 명령을 실행시킨 상태입니다. 이 <code>sleep</code> 프로세스는 현재 터미널 세션의 <strong>전면(foreground) 프로세스</strong>입니다.</p>
</li>
<li>
<p><strong>사용자</strong>: 명령을 중단시키기 위해 <code>Ctrl</code> 키와 <code>C</code> 키를 동시에 누릅니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: 이 키 조합이 일반적인 문자 입력이 아니라 특별한 제어 명령임을 인지합니다. 유닉스 터미널 규약에 따라 <code>Ctrl+C</code>는 <strong><code>INTR</code> (interrupt) 제어 문자</strong>에 해당하며, 이는 ASCII 코드 <code>3</code> (<code>0x03</code>, End of Text)에 매핑됩니다. 터미널 에뮬레이터는 이 <code>0x03</code> 바이트 하나를 <strong>PTY 마스터 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY/TTY 드라이버) - 제어 문자 해석</strong>: 커널 드라이버는 마스터 측에서 <code>0x03</code> 바이트를 읽습니다. 터미널이 <code>cooked</code> 모드이고, <code>ISIG</code> (Interpret Signals) 플래그가 켜져 있는 상태이므로, 커널은 이 바이트를 일반 데이터로 취급하지 않습니다. 대신, 터미널 설정(termios)을 참조하여 <code>0x03</code>이 <code>VINTR</code> 문자와 일치함을 확인하고, 이를 <strong>&ldquo;SIGINT 신호를 생성하라&quot;는 이벤트로 변환</strong>합니다.</p>
</li>
<li>
<p><strong>커널 (프로세스 관리 모듈)</strong>: PTY/TTY 드라이버로부터 신호 생성 요청을 받습니다. 커널은 이 PTY 세션과 연결된 **&ldquo;전면 프로세스 그룹(foreground process group)&rdquo;**을 찾습니다. 이 그룹에는 현재 명령을 실행하고 있는 <code>sleep 100</code> 프로세스가 포함되어 있습니다.</p>
</li>
<li>
<p><strong>커널 (신호 전달)</strong>: 커널은 해당 전면 프로세스 그룹에 속한 모든 프로세스에게 <strong><code>SIGINT</code> 신호를 전달</strong>합니다.</p>
</li>
<li>
<p><strong><code>sleep</code> 프로세스</strong>: <code>SIGINT</code> 신호를 수신합니다. <code>sleep</code> 프로그램은 이 신호에 대한 별도의 처리기(handler)를 등록해두지 않았으므로, 신호에 대한 **기본 동작(default action)**을 수행합니다. <code>SIGINT</code>의 기본 동작은 <strong>&ldquo;프로세스 종료&rdquo;</strong> 입니다.</p>
</li>
<li>
<p><strong>프로세스 종료</strong>: <code>sleep 100</code> 프로세스는 즉시 종료됩니다.</p>
</li>
<li>
<p><strong>셸</strong>: 자식 프로세스(<code>sleep</code>)가 종료되었음을 감지하고, 다음 명령을 입력받기 위해 새로운 프롬프트를 화면에 출력합니다. (이 과정은 Case 1의 7~9번과 유사하게 진행됩니다.)</p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> 터미널 에뮬레이터는 단지 특정 바이트(<code>0x03</code>)를 보낼 뿐, 실제 그 바이트를 해석하여 운영체제 수준의 이벤트(<strong>신호</strong>)로 변환하고, 올바른 대상(<strong>전면 프로세스 그룹</strong>)에게 전달하는 복잡한 작업의 주체는 전적으로 <strong>커널</strong>임.</p>
</blockquote>
<hr>
<h4 id="case-3-사용자가-입력-중"><strong>Case 3: 사용자가 입력 중 <code>Backspace</code>로 수정할 때 (입력 편집)</strong></h4>
<ol>
<li>
<p><strong>사용자</strong>: <code>ls</code>를 입력하려다가 실수로 <code>lp</code>를 입력하는 상황을 가정합니다. 키보드로 <code>l</code>, <code>s</code>, <code>Backspace</code>, <code>p</code>, <code>Enter</code> 순으로 누릅니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: 각 키 입력에 해당하는 바이트들을 순서대로 <strong>PTY 마스터 FD에 씁니다.</strong></p>
<ul>
<li><code>l</code> → <code>0x6C</code></li>
<li><code>s</code> → <code>0x73</code></li>
<li><code>Backspace</code> → <code>0x08</code> (Backspace 제어 문자)</li>
<li><code>p</code> → <code>0x70</code></li>
<li><code>Enter</code> → <code>0x0A</code></li>
</ul>
</li>
<li>
<p><strong>커널 (PTY/TTY 드라이버) - 단계별 처리</strong>: <code>cooked</code> 모드의 커널 드라이버가 이 바이트 스트림을 순차적으로 처리합니다.</p>
<ul>
<li><strong><code>l</code>, <code>s</code> 수신</strong>: Case 1과 동일하게, <code>l</code>과 <code>s</code>를 Echo하여 마스터 FD로 되돌려 보내고, 내부 라인 버퍼에는 <code>ls</code>를 저장합니다. 터미널 화면에는 <code>ls</code>가 보입니다.</li>
<li><strong><code>Backspace</code>(<code>0x08</code>) 수신</strong>: 커널 드라이버는 터미널 설정(termios)을 참조하여 <code>0x08</code>이 <code>VERASE</code> (지우기) 문자와 일치함을 확인합니다. 이를 <strong>&ldquo;라인 버퍼에서 한 글자 지우기&rdquo;</strong> 명령으로 해석합니다.
<ul>
<li><strong>버퍼 수정</strong>: 내부 라인 버퍼의 맨 끝에 있던 <code>s</code>를 삭제합니다. 이제 라인 버퍼의 내용은 <code>l</code>이 됩니다.</li>
<li><strong>화면 수정 지시</strong>: 사용자가 시각적으로도 글자가 지워졌음을 인지할 수 있도록, 화면을 수정하라는 지시를 터미널 에뮬레이터에게 보내야 합니다. 가장 일반적인 방법은 <strong>&ldquo;커서를 한 칸 뒤로, 그 자리에 공백을 출력, 다시 커서를 한 칸 뒤로&rdquo;</strong> 라는 동작을 유발하는 제어 시퀀스를 보내는 것입니다. 이 시퀀스는 보통 <code>\b \b</code> (바이트 <code>0x08</code>, <code>0x20</code>, <code>0x08</code>) 입니다. 커널 드라이버는 이 세 바이트를 <strong>PTY 마스터 FD 쪽으로 써줍니다.</strong></li>
</ul>
</li>
<li><strong>터미널 에뮬레이터 (화면 수정)</strong>: 마스터 FD에서 <code>\b \b</code> 시퀀스를 읽고, 이를 명령으로 해석하여 화면의 커서를 한 칸 뒤로 옮겼다가, 공백을 찍어 <code>s</code>를 덮어쓰고, 다시 커서를 그 자리로 돌려놓습니다. 이제 화면에는 <code>l</code>만 보이고 커서는 그 뒤에서 깜빡입니다.</li>
<li><strong><code>p</code> 수신</strong>: 커널 드라이버는 <code>p</code>(<code>0x70</code>)를 수신합니다. <code>Echo</code> 기능에 의해 이 바이트를 마스터 FD로 되돌려 보내고, 수정된 라인 버퍼(<code>l</code>) 뒤에 <code>p</code>를 추가합니다. 라인 버퍼는 이제 <code>lp</code>가 됩니다. 터미널 화면에는 <code>lp</code>가 표시됩니다.</li>
<li><strong><code>Enter</code> 수신</strong>: <code>Enter</code>(<code>0x0A</code>)를 수신하고, 한 줄 입력이 끝났다고 판단합니다. 최종적으로 확정된 라인 버퍼의 내용 <code>lp</code>와 <code>\n</code>을 합쳐 <code>lp\n</code>을 만듭니다.</li>
</ul>
</li>
<li>
<p><strong>커널 (PTY 드라이버) -&gt; 셸</strong>: 사용자의 모든 오타와 수정 과정은 커널 드라이버 수준에서 모두 처리되었습니다. 셸에게는 오직 최종 결과물인 <strong><code>lp\n</code></strong> 만 <strong>PTY 슬레이브 FD를 통해</strong> 전달됩니다.</p>
</li>
<li>
<p><strong>셸</strong>: <code>lp\n</code>을 읽고 <code>lp</code>라는 명령을 실행하려 하지만, 그런 명령이 없으므로 &ldquo;command not found&rdquo; 같은 오류 메시지를 표준 에러(stderr)로 출력합니다. 이 오류 메시지는 Case 1의 7~9번과 같은 경로를 통해 터미널 화면에 표시됩니다.</p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> 우리가 당연하게 여기는 한 줄 내의 간단한 입력 편집(글자 추가, 삭제)조차 애플리케이션(셸)이 아니라 <strong>커널의 TTY 드라이버</strong>가 담당하는 중요한 기능임. 셸은 이런 편집 과정을 전혀 알지 못하고, 깨끗하게 정제된 최종 입력 라인만 전달받음.</p>
</blockquote>
<h4 id="case-4"><strong>Case 4: <code>read -s</code>로 비밀번호를 입력할 때 (터미널 모드 변경)</strong></h4>
<ol>
<li>
<p><strong>셸</strong>: 사용자가 셸 프롬프트에서 <code>read -s password</code>와 같은 명령이 포함된 스크립트를 실행합니다. 셸은 이 명령을 해석하여 <code>read</code> 내장 명령어나 관련 유틸리티를 실행합니다.</p>
</li>
<li>
<p><strong><code>read</code> 명령어 (ioctl 호출)</strong>: <code>read</code> 명령어는 <code>-s</code> (silent) 옵션을 인지합니다. 비밀번호 입력을 화면에 표시하지 않기 위해, 자신의 표준 입력(stdin)인 **PTY 슬레이브 파일 디스크립터(FD)**에 대해 <strong><code>ioctl()</code> 시스템 콜을 호출</strong>합니다. 이 시스템 콜은 커널에게 &ldquo;이 터미널의 설정을 변경해달라&quot;고 요청하는 것입니다. 구체적으로는 현재 터미널 속성을 가져와서 <code>ECHO</code> 플래그를 비활성화한 후, 변경된 속성을 다시 설정합니다.</p>
</li>
<li>
<p><strong>커널 (PTY/TTY 드라이버)</strong>: <code>ioctl()</code> 호출을 수신하고, 해당 PTY 슬레이브에 대한 내부 설정에서 <strong><code>ECHO</code> 기능을 끕니다.</strong> 이제부터 이 PTY 슬레이브로 들어오는 데이터는 자동으로 PTY 마스터 쪽으로 반사되지 않습니다.</p>
</li>
<li>
<p><strong>사용자</strong>: 화면에 프롬프트가 뜬 상태에서 비밀번호 <code>pass</code>를 입력합니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: 키보드 입력을 받아 <code>p</code>, <code>a</code>, <code>s</code>, <code>s</code>에 해당하는 바이트들을 순서대로 자신이 열고 있는 <strong>PTY 마스터 FD에 씁니다(write).</strong></p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: 마스터 측에 쓰인 <code>p</code>, <code>a</code>, <code>s</code>, <code>s</code> 바이트를 읽습니다. 하지만 현재 이 터미널 세션은 <code>ECHO</code>가 꺼져 있으므로, <strong>이 바이트들을 다시 마스터 FD 쪽으로 써주지 않습니다.</strong></p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: PTY 마스터 FD로부터 되돌아오는 데이터가 없으므로, 화면에 아무것도 그리지 않습니다. 사용자 눈에는 입력이 안 되는 것처럼 보입니다.</p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: <code>ECHO</code>는 꺼졌지만, 여전히 <code>cooked mode</code>의 다른 기능(Line Buffering)은 활성화되어 있습니다. 따라서 수신한 <code>pass</code>를 내부 라인 버퍼에 저장합니다.</p>
</li>
<li>
<p><strong>사용자</strong>: 입력이 끝났음을 알리기 위해 <code>Enter</code> 키를 누릅니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <code>Enter</code> 키에 해당하는 <code>0x0A</code> 바이트를 <strong>PTY 마스터 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: <code>0x0A</code> 바이트를 수신하고, 한 줄 입력이 끝났다고 판단합니다. 버퍼에 저장해 둔 <code>pass</code>와 합쳐 <code>pass\n</code>이라는 완전한 데이터를 만듭니다.</p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: 완성된 <code>pass\n</code> 데이터를 <strong>PTY 슬레이브 FD에서 읽을 수 있도록 준비</strong>시킵니다.</p>
</li>
<li>
<p><strong><code>read</code> 명령어</strong>: 자신의 표준 입력(stdin)인 <strong>PTY 슬레이브 FD에서 읽기(read)를 시도</strong>하고, <code>pass\n</code> 데이터를 가져옵니다. 이 데이터를 <code>password</code> 셸 변수에 저장합니다.</p>
</li>
<li>
<p><strong><code>read</code> 명령어 (ioctl 복구)</strong>: 비밀번호 입력 후, ECHO 플래그를 원래 상태로 되돌립니다.</p>
</li>
<li>
<p><strong>셸 프롬프트 복귀</strong>: 사용자 입력이 다시 화면에 표시되는 평상시 상태로 돌아옵니다.</p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> 애플리케이션(<code>read</code>)이 <code>ioctl()</code>을 통해 <strong>커널 드라이버</strong>의 동작 모드를 일시적으로 변경하여 터미널의 기본 기능(Echo)을 제어함.</p>
</blockquote>
<hr>
<h4 id="case-5"><strong>Case 5: <code>vim</code> 같은 전체 화면 프로그램을 실행할 때 (Raw 모드와 화면 렌더링)</strong></h4>
<ol>
<li>
<p><strong>셸</strong>: 사용자가 <code>vim file.txt</code>를 입력하고 Enter를 누르면, 셸은 <code>vim</code> 프로세스를 생성하고 실행합니다. 이때 <code>vim</code>의 표준 입출력/에러는 <strong>PTY 슬레이브 FD</strong>로 연결됩니다.</p>
</li>
<li>
<p><strong><code>vim</code> (터미널 모드 변경)</strong>: <code>vim</code>은 시작과 동시에, 전체 화면을 직접 제어하기 위해 <strong><code>ioctl()</code> 시스템 콜을 호출</strong>합니다. 이 호출을 통해 <strong>커널 PTY/TTY 드라이버</strong>에게 터미널 모드를 <code>cooked</code>에서 <strong><code>raw</code> 모드로 변경</strong>하도록 요청합니다.</p>
<ul>
<li><strong>Raw 모드</strong>: <code>ECHO</code>, <code>Line Buffering</code>, 특수 문자(Ctrl+C 등)의 신호 변환, 입력 편집 등 커널이 제공하는 대부분의 편의 기능을 모두 끕니다. 이제 키 입력은 발생 즉시, 아무런 가공 없이 <code>vim</code> 프로세스에 전달됩니다.</li>
</ul>
</li>
<li>
<p><strong><code>vim</code> (화면 초기화)</strong>: <code>vim</code>은 전체 화면을 새로 그려야 합니다. 이를 위해 터미널을 제어하는 <strong>이스케이프 시퀀스</strong>들을 생성하여 자신의 표준 출력(stdout)인 <strong>PTY 슬레이브 FD에 씁니다.</strong></p>
<ul>
<li>예시 시퀀스: <code>\033[?1049h</code> (대체 화면 버퍼 사용), <code>\033[2J</code> (화면 전체 지우기), <code>\033[H</code> (커서 홈 위치로 이동) 등.</li>
</ul>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: 슬레이브 측에 쓰인 이스케이프 시퀀스들을 읽습니다. <code>raw</code> 모드이므로 특별한 해석 없이 그대로 <strong>PTY 마스터 FD 쪽으로 전달</strong>합니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <strong>PTY 마스터 FD에서</strong> 이스케이프 시퀀스들을 읽습니다. 이 바이트들을 화면에 문자로 출력하는 대신, <strong>명령으로 해석하여 실행</strong>합니다. (화면을 지우고, 대체 버퍼를 활성화하는 등)</p>
</li>
<li>
<p><strong><code>vim</code> (내용 렌더링)</strong>: <code>vim</code>은 파일 내용, 상태 표시줄, 줄 번호 등을 포함한 텍스트를 계산하여 마찬가지로 <strong>PTY 슬레이브 FD에 씁니다.</strong> 이 데이터 역시 <strong>커널 드라이버</strong>를 거쳐 <strong>터미널 에뮬레이터</strong>로 전달되고 화면에 그려집니다.</p>
</li>
<li>
<p><strong>사용자</strong>: <code>j</code> 키를 눌러 커서를 아래로 이동시킵니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <code>j</code> 키 입력을 받아 바이트(<code>0x6A</code>)를 <strong>PTY 마스터 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: <code>raw</code> 모드이므로 <code>0x6A</code> 바이트를 읽자마자 아무런 버퍼링이나 해석 없이 즉시 <strong>PTY 슬레이브 FD에서 읽을 수 있도록 준비</strong>시킵니다.</p>
</li>
<li>
<p><strong><code>vim</code></strong>: <strong>슬레이브 FD에서</strong> <code>0x6A</code> 바이트를 즉시 읽고, 이를 &ldquo;커서를 한 줄 아래로 이동&rdquo; 명령으로 내부적으로 해석합니다.</p>
</li>
<li>
<p><strong><code>vim</code> (화면 업데이트)</strong>: <code>vim</code>은 화면의 변화를 최소화하는 방식으로 필요한 업데이트를 계산합니다. 이 경우, 단지 커서 위치만 바꾸면 되므로, 커서 이동 이스케이프 시퀀스(예: <code>\033[11;5H</code> - &ldquo;11행 5열로 이동&rdquo;)를 생성하여 <strong>PTY 슬레이브 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: 이 시퀀스를 그대로 <strong>PTY 마스터 FD 쪽으로 전달</strong>합니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <strong>마스터 FD에서</strong> 커서 이동 시퀀스를 읽고, 명령으로 해석하여 <strong>화면에 보이는 커서를 실제로 이동시킵니다.</strong></p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> <code>raw</code> 모드에서 <strong>커널 드라이버</strong>는 단순 중계자 역할로 바뀌고, 애플리케이션(<code>vim</code>)과 <strong>터미널 에뮬레이터</strong>가 이스케이프 시퀀스를 통해 화면의 모든 요소를 직접 제어함.</p>
</blockquote>
<hr>
<h4 id="case-6-위쪽-화살표-키로-히스토리-검색할-때-애플리케이션의-시퀀스-해석"><strong>Case 6: 위쪽 화살표 키로 히스토리 검색할 때 (애플리케이션의 시퀀스 해석)</strong></h4>
<ol>
<li>
<p><strong>사용자</strong>: 셸 프롬프트가 떠 있는 상태에서 <code>위쪽 화살표(↑)</code> 키를 누릅니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <code>위쪽 화살표</code> 키가 단일 ASCII 문자가 아니라는 것을 인지합니다. 터미널 종류(예: xterm)에 따라 미리 약속된 <strong>이스케이프 시퀀스</strong>로 변환합니다. 가장 일반적인 시퀀스는 <code>\033[A</code> 입니다. 이 세 바이트(<code>0x1B</code>, <code>0x5B</code>, <code>0x41</code>)를 <strong>PTY 마스터 FD에 씁니다.</strong></p>
</li>
<li>
<p><strong>커널 (PTY/TTY 드라이버)</strong>: 마스터 측에서 이 세 바이트를 차례로 읽습니다. <code>cooked</code> 모드이지만, <code>\033[A</code>는 커널이 특별히 신호로 바꾸거나 편집 명령으로 해석하는 시퀀스가 아닙니다. 따라서 이 바이트들을 일반적인 데이터로 취급하여 내부 라인 버퍼에 추가합니다.</p>
<ul>
<li><em>참고: <code>Enter</code>가 눌리지 않았으므로 아직 셸에게 전달되지는 않습니다.</em></li>
</ul>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: <strong>(이 부분은 셸의 설정에 따라 다릅니다. 대부분의 현대 셸은 아래와 같이 동작합니다.)</strong> <code>bash</code>나 <code>zsh</code> 같은 셸은 <code>readline</code> 라이브러리를 사용하며, 이 라이브러리는 효율적인 상호작용을 위해 시작 시 <code>ioctl</code>로 터미널을 <code>canonical</code>(cooked) 모드가 아닌, 약간 변형된 모드로 설정할 수 있습니다. 이 경우, <code>\033[A</code> 같은 시퀀스가 입력되면 라인 버퍼링을 거치지 않고 즉시 셸에게 전달될 수 있습니다. 여기서는 더 일반적인 <code>canonical</code> 모드를 가정하고, <strong>셸이 어떻게든 이 데이터를 읽는다고 가정하고 진행하겠습니다.</strong> (실제로는 <code>read</code> 시스템 콜이 바이트 단위로 읽을 수 있습니다.)</p>
</li>
<li>
<p><strong>셸</strong>: <strong>PTY 슬레이브 FD를 통해</strong> <code>\033[A</code> 라는 바이트 시퀀스를 읽습니다.</p>
</li>
<li>
<p><strong>셸 (readline 라이브러리)</strong>: 셸(또는 셸이 사용하는 <code>readline</code> 라이브러리)은 이 바이트 시퀀스를 해석합니다. <code>\033</code>으로 시작하는 것을 보고 이스케이프 시퀀스임을 인지하고, 뒤따르는 <code>[A</code>를 &ldquo;이전 히스토리&rdquo; 명령으로 매핑된 테이블에서 찾습니다.</p>
</li>
<li>
<p><strong>셸 (명령 실행)</strong>: &ldquo;이전 히스토리&rdquo; 명령을 실행합니다. 히스토리 파일(<code>~/.bash_history</code> 등)을 참조하여 가장 최근의 명령어(예: <code>vim file.txt</code>)를 가져옵니다.</p>
</li>
<li>
<p><strong>셸 (화면 업데이트)</strong>: 셸은 사용자에게 현재 입력 줄이 이전 명령어로 대체되었음을 보여줘야 합니다. 이를 위해 터미널 제어 시퀀스를 조합하여 <strong>PTY 슬레이브 FD에 씁니다.</strong></p>
<ul>
<li><code>\r</code> (Carriage Return): 커서를 줄의 맨 앞으로 이동.</li>
<li><code>\033[K</code> (Erase in Line): 커서 위치부터 줄 끝까지 내용 지우기.</li>
<li><code>vim file.txt</code>: 가져온 히스토리 텍스트.</li>
</ul>
</li>
<li>
<p><strong>커널 (PTY 드라이버)</strong>: 슬레이브에 쓰인 이 시퀀스들과 텍스트를 읽어 <strong>PTY 마스터 FD 쪽으로 전달</strong>합니다.</p>
</li>
<li>
<p><strong>터미널 에뮬레이터</strong>: <strong>마스터 FD에서</strong> 이 데이터 스트림을 읽습니다. <code>\r</code>과 <code>\033[K</code>는 명령으로 해석하여 실행하고(커서를 옮기고 줄을 지움), <code>vim file.txt</code>는 텍스트로 인식하여 화면에 그립니다.</p>
</li>
</ol>
<blockquote>
<p><strong>💡 이 시나리오의 핵심:</strong> 화살표 키와 같은 특수 키 입력은 <strong>터미널 에뮬레이터</strong>가 이스케이프 시퀀스로 변환하고, 이 시퀀스의 의미를 해석하여 특정 동작(히스토리 검색)을 수행하는 것은 **커널이 아닌 애플리케이션(셸)**의 책임임.</p>
</blockquote>
<h3 id="추가--tty-pty">추가 =&gt; TTY? PTY?</h3>
<h4 id="1-커널의-tty-서브시스템-tty-subsystem--tty-core">1. 커널의 <strong>TTY 서브시스템 (TTY Subsystem / TTY Core)</strong></h4>
<p>이것이 흔히 사람들이 &ldquo;커널의 TTY 드라이버&quot;라고 넓은 의미로 말할 때 가리키는 대상입니다. TTY 서브시스템은 특정 하드웨어나 PTY에 종속되지 않는, <strong>터미널의 핵심 동작 로직을 담고 있는 커널의 공통 모듈</strong>입니다.</p>
<ul>
<li><strong>역할</strong>: 터미널의 &ldquo;두뇌&rdquo; 또는 &ldquo;공통 로직&quot;입니다.</li>
<li><strong>주요 기능 (Line Discipline)</strong>:
<ul>
<li><strong>입력 편집 (Line Buffering)</strong>: <code>cooked</code> 모드에서 줄 단위로 입력을 모으고, <code>Backspace</code> 등을 처리합니다.</li>
<li><strong>문자 에코 (Echo)</strong>: 입력된 문자를 되돌려 보내 화면에 보이게 합니다.</li>
<li><strong>신호 생성 (Signal Generation)</strong>: <code>Ctrl+C</code> 같은 제어 문자를 <code>SIGINT</code> 같은 실제 신호로 변환합니다.</li>
<li><strong>흐름 제어 (Flow Control)</strong>: 데이터가 너무 빨리 오고 갈 때 이를 조절합니다. (주로 시리얼 통신에서 중요)</li>
<li><strong>문자 변환</strong>: <code>Enter</code> 키를 <code>\n</code>(LF) 또는 <code>\r\n</code>(CRLF)으로 변환하는 등의 규칙을 적용합니다.</li>
</ul>
</li>
<li><strong>특징</strong>: 이 서브시스템은 <strong>추상화</strong>되어 있습니다. 데이터가 실제 물리적인 시리얼 포트에서 오는지, 가상 터미널인 PTY에서 오는지는 신경 쓰지 않습니다. 그저 자신에게 데이터를 넣어주고, 자신이 처리한 데이터를 가져갈 하위 드라이버가 있기만 하면 됩니다.</li>
</ul>
<h4 id="2-커널의-pty-드라이버-pty-driver">2. 커널의 <strong>PTY 드라이버 (PTY Driver)</strong></h4>
<p>PTY 드라이버는 TTY 서브시스템에 연결되는 <strong>여러 종류의 하위 드라이버 중 하나</strong>입니다. 실제 하드웨어를 제어하는 대신, <strong>소프트웨어적으로 터미널 장치를 흉내 내는 역할</strong>을 전문적으로 수행합니다.</p>
<ul>
<li><strong>역할</strong>: TTY 서브시스템을 위한 **&ldquo;가상 하드웨어 드라이버&rdquo;**입니다.</li>
<li><strong>주요 기능</strong>:
<ul>
<li><strong>마스터-슬레이브 쌍 생성</strong>: <code>ioctl</code> 등을 통해 터미널 에뮬레이터가 사용할 마스터(Master) FD와 셸이 사용할 슬레이브(Slave) FD라는 한 쌍의 통신 채널을 만듭니다.</li>
<li><strong>데이터 중계</strong>:
<ul>
<li>마스터 측에서 온 데이터(터미널 에뮬레이터의 입력)를 <strong>TTY 서브시스템으로 밀어 넣습니다.</strong></li>
<li>TTY 서브시스템이 처리를 마친 데이터(셸에게 갈 데이터)를 슬레이브 측에서 읽을 수 있게 해줍니다.</li>
<li>슬레이브 측에서 온 데이터(셸의 출력)를 마스터 측으로 그대로 전달합니다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>특징</strong>: PTY 드라이버 자체는 <code>Echo</code>나 <code>Line Buffering</code> 같은 복잡한 로직을 가지고 있지 않습니다. 이 모든 작업은 <strong>TTY 서브시스템에 위임</strong>합니다. PTY 드라이버의 핵심 임무는 오직 가상의 데이터 통로를 만들고 유지하는 것입니다.</li>
</ul>
<hr>
<h4 id="둘의-관계와-협력-방식">둘의 관계와 협력 방식</h4>
<table>
  <thead>
      <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: left"><strong>커널의 TTY 서브시스템 (Line Discipline)</strong></th>
          <th style="text-align: left"><strong>커널의 PTY 드라이버</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>역할</strong></td>
          <td style="text-align: left">터미널의 핵심 동작 규칙(두뇌)</td>
          <td style="text-align: left">가상의 터미널 장치(입출력 통로)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>핵심 기능</strong></td>
          <td style="text-align: left">Echo, Line Buffering, Signal 생성</td>
          <td style="text-align: left">마스터-슬레이브 쌍 생성 및 데이터 중계</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>추상화 수준</strong></td>
          <td style="text-align: left">높음 (하드웨어 독립적)</td>
          <td style="text-align: left">낮음 (TTY 서브시스템에 데이터를 공급)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>관계</strong></td>
          <td style="text-align: left"><strong>상위 모듈</strong>. PTY 드라이버의 서비스를 받음</td>
          <td style="text-align: left"><strong>하위 모듈</strong>. TTY 서브시스템의 서비스를 이용함</td>
      </tr>
  </tbody>
</table>
<p><strong>사용자가 <code>ls</code>를 입력하는 과정을 이 둘의 관계로 다시 보면 다음과 같습니다.</strong></p>
<ol>
<li><strong>터미널 에뮬레이터</strong>가 <code>l</code>, <code>s</code> 바이트를 <strong>PTY 마스터 FD</strong>에 씁니다.</li>
<li><strong>PTY 드라이버</strong>가 이 데이터를 감지합니다.</li>
<li><strong>PTY 드라이버</strong>는 이 데이터를 &ldquo;가상 장치에서 입력이 들어왔다&quot;고 알리며 <strong>TTY 서브시스템</strong>으로 전달합니다.</li>
<li><strong>TTY 서브시스템</strong>은 <code>cooked</code> 모드 규칙에 따라 다음을 수행합니다.
<ul>
<li><code>l</code>, <code>s</code>를 Echo하기 위해 다시 <strong>PTY 드라이버</strong>에게 &ldquo;이 데이터를 마스터 쪽으로 보내라&quot;고 지시합니다.</li>
<li>내부 라인 버퍼에 <code>ls</code>를 저장합니다.</li>
</ul>
</li>
<li>(Enter 입력 후) <strong>TTY 서브시스템</strong>은 완성된 <code>ls\n</code>을 <strong>PTY 드라이버</strong>에게 &ldquo;이 데이터를 슬레이브 쪽에서 읽을 수 있게 하라&quot;고 전달합니다.</li>
<li><strong>셸</strong>이 <strong>PTY 슬레이브 FD</strong>에서 <code>ls\n</code>을 읽어갑니다.</li>
</ol>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>셸에서 이벤트가 출발하지 않는 경우가 있을 수 있다 ex)시그널&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>주소 바인딩 실습(소스코드 부터 프로세스까지) | My Test Site</title>
    

    
    
    <meta name="description" content="주소 바인딩(Address Binding) 과정 심층 분석 1. 주소 바인딩의 개념과 목적 **주소 바인딩(Address Binding)**이란 프로그램의 소스 코드에 사용된 변수나 함수 같은 심볼릭 주소(Symbolic Address)가 실제 물리 메모리 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%8B%A4%EC%8A%B5%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%B6%80%ED%84%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B9%8C%EC%A7%80/">

    
    
    
    <meta property="og:title" content="주소 바인딩 실습(소스코드 부터 프로세스까지)">
    <meta property="og:description" content="주소 바인딩(Address Binding) 과정 심층 분석 1. 주소 바인딩의 개념과 목적 **주소 바인딩(Address Binding)**이란 프로그램의 소스 코드에 사용된 변수나 함수 같은 심볼릭 주소(Symbolic Address)가 실제 물리 메모리 …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%8B%A4%EC%8A%B5%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%B6%80%ED%84%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B9%8C%EC%A7%80/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="주소 바인딩 실습(소스코드 부터 프로세스까지)">
    <meta name="twitter:description" content="주소 바인딩(Address Binding) 과정 심층 분석 1. 주소 바인딩의 개념과 목적 **주소 바인딩(Address Binding)**이란 프로그램의 소스 코드에 사용된 변수나 함수 같은 심볼릭 주소(Symbolic Address)가 실제 물리 메모리 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>주소 바인딩 실습(소스코드 부터 프로세스까지) **page.html**</h1>
    <h2 id="주소-바인딩address-binding-과정-심층-분석">주소 바인딩(Address Binding) 과정 심층 분석</h2>
<h3 id="1-주소-바인딩의-개념과-목적">1. 주소 바인딩의 개념과 목적</h3>
<p>**주소 바인딩(Address Binding)**이란 프로그램의 소스 코드에 사용된 변수나 함수 같은 심볼릭 주소(Symbolic Address)가 실제 물리 메모리(Physical Memory)의 주소로 변환되는 전체 과정을 의미합니다. 이 과정은 컴퓨터가 프로그램을 실행하기 위한 핵심적인 메커니즘입니다.</p>
<h4 id="목적">목적</h4>
<ul>
<li><strong>재배치(Relocation)</strong>: 프로그램을 메모리의 어느 위치에든 적재하여 실행할 수 있도록 합니다. 만약 주소가 고정되어 있다면 여러 프로그램을 동시에 실행하기 어렵습니다.</li>
<li><strong>메모리 보호(Memory Protection)</strong>: 각 프로세스가 자신에게 할당된 메모리 영역만 접근하도록 격리하여 시스템의 안정성을 높입니다.</li>
<li><strong>메모리 효율성 증대</strong>: 가상 메모리(Virtual Memory), 공유 라이브러리(Shared Library) 등의 기법을 통해 한정된 물리 메모리를 여러 프로세스가 효율적으로 나누어 사용할 수 있게 합니다.</li>
</ul>
<p>본 문서는 리눅스 CLI 환경에서 제공하는 다양한 도구를 활용하여, <strong>컴파일 → 링크 → 적재 → 실행</strong> 각 단계에서 주소 바인딩이 어떻게 이루어지는지 구체적인 명령과 출력을 통해 심층적으로 추적하고 분석하는 것을 목표로 합니다.</p>
<hr>
<h3 id="2-실습-환경-구성">2. 실습 환경 구성</h3>
<p>실습을 위해 간단한 C 코드를 작성합니다. 이 코드는 전역 변수, 함수 등을 포함하여 각 단계별 변화를 관찰하기에 용이합니다.</p>
<h4 id="예제-코드-addr_testc">예제 코드 (<code>addr_test.c</code>)</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> initialized_global_var <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> uninitialized_global_var;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> const_global_var <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Function address</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> static_local_var <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> local_var <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">function</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Address of initialized_global_var: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>initialized_global_var);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Address of main function: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, main);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="3-1단계-컴파일-시간-바인딩-compile-time-binding">3. 1단계: 컴파일 시간 바인딩 (Compile-Time Binding)</h3>
<p><strong>목표</strong>: 소스 코드의 심볼릭 주소(변수명, 함수명)가 컴파일러에 의해 <strong>재배치 가능한(Relocatable) 주소</strong>로 변환되는 과정을 확인합니다. 이 주소는 각 오브젝트 파일(<code>.o</code>) 내에서의 상대적인 오프셋(offset)입니다.</p>
<h4 id="1-오브젝트-파일-생성">1. 오브젝트 파일 생성</h4>
<p><code>gcc</code>의 <code>-c</code> 옵션은 링킹을 수행하지 않고 컴파일만 진행하여 오브젝트 파일을 생성합니다.</p>
<p>Bash</p>
<pre tabindex="0"><code>gcc -c addr_test.c -o addr_test.o
</code></pre><h4 id="2-심볼-테이블-분석-nm">2. 심볼 테이블 분석 (<code>nm</code>)</h4>
<p><code>nm</code> 도구는 오브젝트 파일의 심볼 테이블을 보여줍니다. 이를 통해 각 심볼이 어떤 섹션에, 어떤 상대 주소로 할당되었는지 확인할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nm addr_test.o
</span></span></code></pre></div><p><strong>출력 예시 및 분석</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>000000000000001e T <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> D initialized_global_var
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000035</span> T main
</span></span><span style="display:flex;"><span>                 U printf
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000004</span> C uninitialized_global_var
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><ul>
<li><strong>주소</strong>: <code>0x00...</code>으로 시작하는 이 값들은 최종 메모리 주소가 아닌, 파일 내의 **상대 주소(오프셋)**입니다.</li>
<li><strong>심볼 타입</strong>:
<ul>
<li><code>T</code>: <code>.text</code> 섹션(코드)에 위치한 심볼. <code>main</code>, <code>function</code> 함수가 해당됩니다.</li>
<li><code>D</code>: <code>.data</code> 섹션(초기화된 데이터)에 위치한 심볼. <code>initialized_global_var</code>가 해당됩니다.</li>
<li><code>C</code>: Common 심볼. 초기화되지 않은 전역 변수(<code>uninitialized_global_var</code>)로, 크기만 명시되고 최종 위치는 링커가 결정합니다.</li>
<li><code>U</code>: Undefined. 이 파일 내에 정의되지 않은 심볼로, <code>printf</code>처럼 외부 라이브러리에서 가져와야 함을 의미합니다.</li>
</ul>
</li>
</ul>
<h4 id="3-섹션별-상세-분석-objdump">3. 섹션별 상세 분석 (<code>objdump</code>)</h4>
<p><code>objdump -d</code>는 코드 섹션(<code>.text</code>)을 디스어셈블하여 명령어 수준에서 상대 주소를 보여줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>objdump -d addr_test.o
</span></span></code></pre></div><blockquote>
<p>출력된 어셈블리 코드에서 <code>call</code>이나 <code>mov</code> 명령어의 대상 주소가 <code>0</code> 또는 상대적인 값으로 표시된 것을 볼 수 있습니다. 이는 링커가 채워주어야 할 부분입니다.</p>
</blockquote>
<hr>
<h3 id="4-2단계-링크-시간-바인딩-link-time-binding">4. 2단계: 링크 시간 바인딩 (Link-Time Binding)</h3>
<p><strong>목표</strong>: 링커가 여러 오브젝트 파일과 라이브러리를 결합하여 <strong>단일 실행 파일</strong>을 만드는 과정을 확인합니다. 이 과정에서 재배치 가능 주소는 프로그램의 <strong>가상 주소 공간(Virtual Address Space)</strong> 내의 **절대 주소(Absolute Address)**로 확정됩니다.</p>
<h4 id="1-실행-파일-생성">1. 실행 파일 생성</h4>
<p>오브젝트 파일을 링킹하여 실행 파일을 생성합니다. 이 과정에서 <code>printf</code> 같은 외부 함수의 주소도 연결됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gcc addr_test.o -o addr_test
</span></span></code></pre></div><h4 id="2-실행-파일의-심볼-주소-확인-readelf">2. 실행 파일의 심볼 주소 확인 (<code>readelf</code>)</h4>
<p><code>readelf -s</code>는 ELF(Executable and Linkable Format) 형식 파일의 심볼 테이블을 더 상세히 보여줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>readelf -s ./addr_test | grep <span style="color:#e6db74">&#39;main\|function\|initialized&#39;</span>
</span></span></code></pre></div><p><strong>출력 예시 및 분석</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  38: <span style="color:#ae81ff">0000000000004030</span>     <span style="color:#ae81ff">4</span> OBJECT  GLOBAL DEFAULT   <span style="color:#ae81ff">15</span> initialized_global_var
</span></span><span style="display:flex;"><span>  63: <span style="color:#ae81ff">0000000000001159</span>    <span style="color:#ae81ff">26</span> FUNC    GLOBAL DEFAULT   <span style="color:#ae81ff">14</span> <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span>  69: <span style="color:#ae81ff">0000000000001173</span>    <span style="color:#ae81ff">69</span> FUNC    GLOBAL DEFAULT   <span style="color:#ae81ff">14</span> main
</span></span></code></pre></div><ul>
<li>이제 주소(<code>0x4030</code>, <code>0x1159</code> 등)는 <code>0</code>이 아닌, <strong>가상 메모리 주소</strong>로 확정되었습니다.</li>
<li>이 주소는 프로세스가 시작될 때 할당될 논리적인 주소이며, 모든 심볼이 고유한 가상 주소를 갖게 됩니다.</li>
</ul>
<hr>
<h3 id="5-3단계-적재-시간-바인딩-load-time-binding">5. 3단계: 적재 시간 바인딩 (Load-Time Binding)</h3>
<p><strong>목표</strong>: 운영체제(OS)의 로더(Loader)가 실행 파일을 메모리에 올릴 때, 프로그램의 각 세그먼트(코드, 데이터 등)가 프로세스의 가상 주소 공간에 어떻게 매핑되는지 확인합니다.</p>
<h4 id="1-프로세스-실행-및-pid-확인">1. 프로세스 실행 및 PID 확인</h4>
<p>프로세스를 백그라운드로 실행하고 해당 PID(Process ID)를 변수에 저장합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./addr_test &amp;
</span></span><span style="display:flex;"><span>PID<span style="color:#f92672">=</span>$!
</span></span></code></pre></div><h4 id="2-프로세스-메모리-맵-확인-pmap">2. 프로세스 메모리 맵 확인 (<code>pmap</code>)</h4>
<p><code>pmap</code>은 특정 프로세스의 메모리 맵을 보여주는 강력한 도구입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pmap $PID
</span></span></code></pre></div><p><strong>출력 예시 및 분석</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>000055a3d0ab4000      4K r-xp /path/to/addr_test  &lt;-- Code <span style="color:#f92672">(</span>.text<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>000055a3d0acb000      4K r--p /path/to/addr_test  &lt;-- Read-only data
</span></span><span style="display:flex;"><span>000055a3d0acc000      4K rw-p /path/to/addr_test  &lt;-- Read-write data <span style="color:#f92672">(</span>.data, .bss<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>00007ffc8d9e8000    132K rw-p <span style="color:#f92672">[</span>stack<span style="color:#f92672">]</span>              &lt;-- Stack
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><ul>
<li><strong>첫 번째 열</strong>: 각 메모리 영역의 <strong>시작 가상 주소</strong>입니다.</li>
<li><strong>ASLR (Address Space Layout Randomization)</strong> 때문에 프로그램을 실행할 때마다 이 시작 주소는 변경될 수 있습니다. <code>readelf</code>에서 본 오프셋은 유지된 채, 전체적인基底 주소(Base Address)가 바뀌는 것입니다.</li>
</ul>
<h4 id="3-proc-파일-시스템으로-확인">3. <code>/proc</code> 파일 시스템으로 확인</h4>
<p><code>/proc/&lt;PID&gt;/maps</code> 파일은 <code>pmap</code>보다 더 상세한 정보를 제공합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /proc/$PID/maps
</span></span></code></pre></div><blockquote>
<p>출력 형식은 <code>pmap</code>과 유사하지만, 파일 오프셋, 디바이스/inode 정보 등 더 많은 세부 정보를 포함합니다. 이 파일을 통해 코드, 데이터, 스택, 힙 및 동적 라이브러리가 가상 주소 공간에 어떻게 배치되었는지 명확히 볼 수 있습니다.</p>
</blockquote>
<hr>
<h3 id="6-4단계-실행-시간-바인딩-execution-time-binding">6. 4단계: 실행 시간 바인딩 (Execution-Time Binding)</h3>
<p><strong>목표</strong>: 프로그램이 실제로 실행되는 동안 <strong>MMU(Memory Management Unit)</strong> 하드웨어가 가상 주소를 물리 주소로 동적으로 변환하는 개념을 간접적으로 확인합니다. 현대 OS는 대부분 이 방식을 사용합니다.</p>
<h4 id="1-페이지-폴트page-fault-관찰-perf">1. 페이지 폴트(Page Fault) 관찰 (<code>perf</code>)</h4>
<p>가상 주소가 처음 접근될 때, 해당 데이터가 물리 메모리에 없다면 <strong>페이지 폴트</strong>가 발생합니다. 이때 OS는 디스크에서 데이터를 물리 메모리로 가져오고 페이지 테이블을 업데이트합니다. 이것이 바로 실행 시간 바인딩의 핵심 순간입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># -e page-faults 옵션으로 페이지 폴트 이벤트 카운팅</span>
</span></span><span style="display:flex;"><span>perf stat -e page-faults ./addr_test
</span></span></code></pre></div><p><strong>출력 예시</strong>:</p>
<pre tabindex="0"><code> Address of initialized_global_var: 0x55d8b2f9a030
 Address of main function: 0x55d8b2f98173

 Performance counter stats for &#39;./addr_test&#39;:

               105      page-faults

       0.001099684 seconds time elapsed
</code></pre><blockquote>
<p><code>105</code>개의 페이지 폴트가 발생했음을 보여줍니다. 이는 프로그램 실행에 필요한 코드/데이터 페이지가 실행 시점에 동적으로 물리 메모리에 바인딩되었음을 의미합니다.</p>
</blockquote>
<h4 id="2-가상-주소--물리-주소-매핑-확인-pagemap-고급">2. 가상 주소 → 물리 주소 매핑 확인 (<code>pagemap</code>, 고급)</h4>
<p><code>/proc/&lt;PID&gt;/pagemap</code> 파일은 각 가상 페이지에 대한 물리 페이지 프레임 번호(PFN) 정보를 담고 있습니다. 이를 통해 최종적인 가상-물리 주소 매핑을 직접 확인할 수 있지만, 루트 권한이 필요하며 파싱이 복잡합니다. 이는 주소 변환의 가장 낮은 수준을 보여주는 증거입니다.</p>
<p>관심 있는 사용자는 <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" class="external-link" target="_blank" rel="noopener noreferrer" >kernel.org의 pagemap 문서</a>를 참조하여 직접 스크립트를 작성해볼 수 있습니다.</p>
<hr>
<h3 id="7-전체-과정-요약">7. 전체 과정 요약</h3>
<table>
  <thead>
      <tr>
          <th><strong>바인딩 단계</strong></th>
          <th><strong>목적</strong></th>
          <th><strong>핵심 도구</strong></th>
          <th><strong>주소의 상태</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>컴파일 시간</strong></td>
          <td>심볼릭 주소를 상대 주소로 변환</td>
          <td><code>gcc -c</code>, <code>nm</code>, <code>objdump</code></td>
          <td><strong>재배치 가능 주소 (Relocatable Address)</strong></td>
      </tr>
      <tr>
          <td><strong>링크 시간</strong></td>
          <td>여러 오브젝트를 묶어 가상 주소 결정</td>
          <td><code>gcc</code>, <code>readelf -s</code></td>
          <td><strong>절대 가상 주소 (Absolute Virtual Address)</strong></td>
      </tr>
      <tr>
          <td><strong>적재 시간</strong></td>
          <td>실행 파일을 프로세스 가상 공간에 매핑</td>
          <td><code>pmap</code>, <code>/proc/PID/maps</code></td>
          <td><strong>가상 메모리 주소 (Mapped Virtual Address)</strong></td>
      </tr>
      <tr>
          <td><strong>실행 시간</strong></td>
          <td>MMU가 가상 주소를 물리 주소로 변환</td>
          <td>MMU (HW), <code>perf</code>, <code>/proc/PID/pagemap</code></td>
          <td><strong>물리 주소 (Physical Address)</strong></td>
      </tr>
  </tbody>
</table>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
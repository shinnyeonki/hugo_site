<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>spring controller 추상화 단계별 어노테이션 파라미터 | My Test Site</title>
    

    
    
    <meta name="description" content="추상화 단계별 설명 Level 1: Servlet API 직접 사용 (가장 낮은 추상화 단계)
Spring이 있기 전, Java 웹 개발의 근간인 Servlet API를 직접 사용하는 방식입니다. Spring Controller에서도 이 객체들을 직접 파라미터로 받아 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/spring-controller-%EC%B6%94%EC%83%81%ED%99%94-%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0/">

    
    
    
    <meta property="og:title" content="spring controller 추상화 단계별 어노테이션 파라미터">
    <meta property="og:description" content="추상화 단계별 설명 Level 1: Servlet API 직접 사용 (가장 낮은 추상화 단계)
Spring이 있기 전, Java 웹 개발의 근간인 Servlet API를 직접 사용하는 방식입니다. Spring Controller에서도 이 객체들을 직접 파라미터로 받아 …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/spring-controller-%EC%B6%94%EC%83%81%ED%99%94-%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="spring controller 추상화 단계별 어노테이션 파라미터">
    <meta name="twitter:description" content="추상화 단계별 설명 Level 1: Servlet API 직접 사용 (가장 낮은 추상화 단계)
Spring이 있기 전, Java 웹 개발의 근간인 Servlet API를 직접 사용하는 방식입니다. Spring Controller에서도 이 객체들을 직접 파라미터로 받아 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>spring controller 추상화 단계별 어노테이션 파라미터 **page.html**</h1>
    <h3 id="추상화-단계별-설명">추상화 단계별 설명</h3>
<ol>
<li>
<p><strong>Level 1: Servlet API 직접 사용 (가장 낮은 추상화 단계)</strong></p>
<ul>
<li>Spring이 있기 전, Java 웹 개발의 근간인 Servlet API를 직접 사용하는 방식입니다.</li>
<li>Spring Controller에서도 이 객체들을 직접 파라미터로 받아 모든 것을 수동으로 제어할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Level 2: 기본 매핑과 요청 데이터 추출</strong></p>
<ul>
<li>Servlet API를 직접 다루는 불편함을 줄이고, 특정 URL 요청을 특정 메서드에 연결(매핑)하고 요청 데이터를 쉽게 추출하는 단계입니다.</li>
</ul>
</li>
<li>
<p><strong>Level 3: 데이터 바인딩 및 응답 데이터 처리</strong></p>
<ul>
<li>요청 파라미터들을 객체(DTO)에 자동으로 담아주거나, 응답할 데이터를 모델에 담아 View로 전달하는 등 데이터 처리를 자동화하는 단계입니다.</li>
</ul>
</li>
<li>
<p><strong>Level 4: REST API를 위한 추상화</strong></p>
<ul>
<li>전통적인 HTML View 반환이 아닌, JSON/XML 같은 데이터 자체를 응답하는 RESTful API 개발에 특화된 고수준 추상화 단계입니다.</li>
</ul>
</li>
<li>
<p><strong>Level 5: 편의성을 위한 조합 및 축약 (가장 높은 추상화 단계)</strong></p>
<ul>
<li>여러 어노테이션의 기능을 하나로 합치거나, 코드를 더 간결하게 만들어주는 &lsquo;문법적 설탕(Syntactic Sugar)&rsquo; 단계입니다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="상세-설명-낮은-추상화---높은-추상화-순">상세 설명 (낮은 추상화 -&gt; 높은 추상화 순)</h2>
<h3 id="level-1-servlet-api-직접-사용-lowest-abstraction">Level 1: Servlet API 직접 사용 (Lowest Abstraction)</h3>
<p>이 단계에서는 Spring의 도움을 최소한으로 받고, Java Servlet의 핵심 객체를 직접 다룹니다.</p>
<table>
  <thead>
      <tr>
          <th>파라미터</th>
          <th>문법 예시</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>HttpServletRequest</code></td>
          <td><code>public void method(HttpServletRequest request)</code></td>
          <td>HTTP 요청 정보를 모두 담고 있는 객체입니다. 헤더, 파라미터, 쿠키, 세션, Body 등 모든 요청 데이터에 직접 접근할 수 있습니다. (<code>request.getParameter(&quot;name&quot;)</code>처럼 사용)</td>
      </tr>
      <tr>
          <td><code>HttpServletResponse</code></td>
          <td><code>public void method(HttpServletResponse response)</code></td>
          <td>HTTP 응답을 제어하는 객체입니다. 응답 상태 코드(Status Code), 헤더, 쿠키를 설정하거나 응답 Body에 직접 데이터를 쓸 수 있습니다. (<code>response.getWriter().write(&quot;hello&quot;)</code>처럼 사용)</td>
      </tr>
      <tr>
          <td><code>HttpSession</code></td>
          <td><code>public void method(HttpSession session)</code></td>
          <td>세션 객체를 직접 다룰 때 사용합니다. 세션에 데이터를 저장(<code>session.setAttribute(...)</code>)하거나 조회(<code>session.getAttribute(...)</code>)할 수 있습니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="level-2-기본-매핑과-요청-데이터-추출">Level 2: 기본 매핑과 요청 데이터 추출</h3>
<p>URL과 메서드를 연결하고, URL의 특정 부분을 파라미터로 쉽게 가져옵니다.</p>
<table>
  <thead>
      <tr>
          <th>어노테이션/파라미터</th>
          <th>문법 예시</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>@Controller</code></td>
          <td><code>@Controller public class MyController { ... }</code></td>
          <td>클래스 레벨에 붙이며, 해당 클래스가 Spring MVC의 컨트롤러임을 나타냅니다. Spring이 이 클래스를 스캔하여 웹 요청을 처리하는 핸들러로 사용합니다.</td>
      </tr>
      <tr>
          <td><code>@RequestMapping</code></td>
          <td><code>@RequestMapping(&quot;/hello&quot;)</code> or <code>@RequestMapping(value=&quot;/hello&quot;, method=RequestMethod.GET)</code></td>
          <td>특정 URL 경로와 HTTP 메서드를 처리할 메서드에 연결(매핑)합니다. 클래스와 메서드 레벨 모두에 사용할 수 있습니다. HTTP 메서드를 명시하지 않으면 모든 메서드(GET, POST 등)를 허용합니다.</td>
      </tr>
      <tr>
          <td><code>@RequestParam</code></td>
          <td><code>public void method(@RequestParam(&quot;name&quot;) String name)</code></td>
          <td>URL의 쿼리 파라미터(<code>?name=John</code>)나 form-data 값을 메서드 파라미터에 바인딩합니다. <code>required</code> (기본값 true), <code>defaultValue</code> 속성을 통해 필수 여부나 기본값을 지정할 수 있습니다.</td>
      </tr>
      <tr>
          <td><code>@PathVariable</code></td>
          <td><code>@RequestMapping(&quot;/users/{userId}&quot;) public void method(@PathVariable(&quot;userId&quot;) Long id)</code></td>
          <td>URL 경로의 일부를 변수로 사용할 때 씁니다. (<code>/users/123</code> 에서 <code>123</code>을 <code>id</code> 변수에 바인딩). RESTful API에서 리소스를 식별할 때 주로 사용됩니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="level-3-데이터-바인딩-및-응답-데이터-처리">Level 3: 데이터 바인딩 및 응답 데이터 처리</h3>
<p>요청 데이터를 객체에 자동으로 담거나, View에 전달할 데이터를 편리하게 관리합니다.</p>
<table>
  <thead>
      <tr>
          <th>어노테이션/파라미터</th>
          <th>문법 예시</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>@ModelAttribute</code></td>
          <td><code>public String method(@ModelAttribute UserDto userDto)</code></td>
          <td>여러 요청 파라미터를 객체(DTO, VO)의 필드에 자동으로 바인딩합니다. 예를 들어 <code>?name=John&amp;age=30</code> 요청이 오면, <code>name</code>과 <code>age</code> 필드를 가진 <code>UserDto</code> 객체를 생성하고 값을 채워줍니다. 또한, 이 어노테이션이 붙은 객체는 자동으로 Model에 추가되어 View에서 사용할 수 있습니다.</td>
      </tr>
      <tr>
          <td><code>Model</code> / <code>Map</code></td>
          <td><code>public String method(Model model)</code></td>
          <td>View에 전달할 데이터를 담는 컨테이너 역할을 합니다. 메서드 파라미터로 선언하면 Spring이 자동으로 객체를 주입해줍니다. <code>model.addAttribute(&quot;key&quot;, value)</code> 형태로 데이터를 추가하면 View(JSP, Thymeleaf 등)에서 해당 데이터를 사용할 수 있습니다. <code>Map</code>도 동일하게 동작합니다.</td>
      </tr>
      <tr>
          <td><code>ModelAndView</code></td>
          <td><code>public ModelAndView method() { return new ModelAndView(&quot;viewName&quot;); }</code></td>
          <td><strong>Model</strong>과 <strong>View</strong>를 하나로 합친 객체입니다. 처리 결과를 보여줄 View의 이름과 View에 전달할 데이터를 함께 담아 반환할 수 있습니다. 최근에는 <code>Model</code> 파라미터와 <code>String</code> (View 이름) 반환을 더 선호하는 추세입니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="level-4-rest-api를-위한-추상화">Level 4: REST API를 위한 추상화</h3>
<p>JSON/XML과 같은 메시지 기반 통신을 위한 핵심적인 추상화입니다.</p>
<table>
  <thead>
      <tr>
          <th>어노테이션/파라미터</th>
          <th>문법 예시</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>@RequestBody</code></td>
          <td><code>public void method(@RequestBody UserDto userDto)</code></td>
          <td>요청의 Body에 담겨 오는 데이터(주로 JSON, XML)를 Java 객체로 변환(역직렬화, Deserialization)해줍니다. 내부적으로 <code>HttpMessageConverter</code>(주로 Jackson)가 동작하여 이 변환 과정을 자동으로 처리합니다. 클라이언트가 JSON 데이터를 보내면, 해당 JSON 구조와 일치하는 DTO 객체에 값을 채워줍니다.</td>
      </tr>
      <tr>
          <td><code>@ResponseBody</code></td>
          <td><code>@ResponseBody public UserDto method() { ... }</code></td>
          <td>메서드가 반환하는 Java 객체를 HTTP 응답 Body에 직접 써넣도록 지시합니다. View를 찾는 것이 아니라, 반환된 객체를 JSON이나 XML 등의 데이터 형식으로 변환(직렬화, Serialization)하여 클라이언트에 전송합니다. REST API의 응답을 만들 때 필수적입니다.</td>
      </tr>
      <tr>
          <td><code>ResponseEntity&lt;T&gt;</code></td>
          <td><code>public ResponseEntity&lt;UserDto&gt; method() { ... }</code></td>
          <td><code>@ResponseBody</code>의 확장판으로, 응답 데이터(Body)뿐만 아니라 HTTP 상태 코드(Status Code)와 헤더(Header)까지 세밀하게 제어하여 반환하고 싶을 때 사용합니다. <code>ResponseEntity.ok(body)</code>, <code>ResponseEntity.created(uri).build()</code> 와 같이 유연한 응답 구성이 가능합니다.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="level-5-편의성을-위한-조합-및-축약-highest-abstraction">Level 5: 편의성을 위한 조합 및 축약 (Highest Abstraction)</h3>
<p>자주 사용되는 패턴을 하나의 어노테이션으로 묶어 코드의 가독성과 생산성을 높입니다.</p>
<table>
  <thead>
      <tr>
          <th>어노테이션/파라미터</th>
          <th>문법 예시</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>@RestController</code></td>
          <td><code>@RestController public class MyApiController { ... }</code></td>
          <td><strong><code>@Controller</code> + <code>@ResponseBody</code></strong> 의 조합입니다. 이 어노테이션을 클래스에 붙이면, 해당 컨트롤러의 모든 메서드에는 기본적으로 <code>@ResponseBody</code>가 적용됩니다. 따라서 모든 메서드가 View를 반환하는 대신 데이터(JSON 등)를 반환하게 되므로, REST API를 만들 때 매우 편리합니다.</td>
      </tr>
      <tr>
          <td><code>@GetMapping</code></td>
          <td><code>@GetMapping(&quot;/users/{id}&quot;)</code></td>
          <td><strong><code>@RequestMapping(method = RequestMethod.GET)</code></strong> 의 축약형입니다. HTTP GET 요청을 처리하는 핸들러를 간결하게 매핑할 수 있습니다.</td>
      </tr>
      <tr>
          <td><code>@PostMapping</code></td>
          <td><code>@PostMapping(&quot;/users&quot;)</code></td>
          <td><strong><code>@RequestMapping(method = RequestMethod.POST)</code></strong> 의 축약형입니다. HTTP POST 요청을 처리합니다.</td>
      </tr>
      <tr>
          <td><code>@PutMapping</code></td>
          <td><code>@PutMapping(&quot;/users/{id}&quot;)</code></td>
          <td><strong><code>@RequestMapping(method = RequestMethod.PUT)</code></strong> 의 축약형입니다. HTTP PUT 요청을 처리합니다.</td>
      </tr>
      <tr>
          <td><code>@DeleteMapping</code></td>
          <td><code>@DeleteMapping(&quot;/users/{id}&quot;)</code></td>
          <td><strong><code>@RequestMapping(method = RequestMethod.DELETE)</code></strong> 의 축약형입니다. HTTP DELETE 요청을 처리합니다.</td>
      </tr>
      <tr>
          <td><code>@PatchMapping</code></td>
          <td><code>@PatchMapping(&quot;/users/{id}&quot;)</code></td>
          <td><strong><code>@RequestMapping(method = RequestMethod.PATCH)</code></strong> 의 축약형입니다. HTTP PATCH 요청을 처리합니다.</td>
      </tr>
  </tbody>
</table>
<h3 id="요약-추상화의-흐름">요약: 추상화의 흐름</h3>
<p><strong>Servlet API (<code>HttpServletRequest</code>)</strong>
-&gt; &ldquo;이 URL을 이 메서드에 연결해줘&rdquo; <strong>(<code>@RequestMapping</code>)</strong>
-&gt; &ldquo;URL 파라미터는 이 변수에 넣어줘&rdquo; <strong>(<code>@RequestParam</code>)</strong>
-&gt; &ldquo;여러 파라미터를 이 객체에 알아서 채워줘&rdquo; <strong>(<code>@ModelAttribute</code>)</strong>
-&gt; &ldquo;요청 Body의 JSON을 이 객체로 바꿔줘&rdquo; <strong>(<code>@RequestBody</code>)</strong>
-&gt; &ldquo;메서드 반환값을 바로 JSON으로 응답해줘&rdquo; <strong>(<code>@ResponseBody</code>)</strong>
-&gt; &ldquo;이 컨트롤러는 전부 REST API용이니 모든 메서드에 <code>@ResponseBody</code>를 붙여줘&rdquo; <strong>(<code>@RestController</code>)</strong>
-&gt; &ldquo;<code>@RequestMapping(method=GET)</code> 대신 <code>@GetMapping</code>으로 간단히 쓰자&rdquo; <strong>(<code>@GetMapping</code> 등)</strong></p>
<p>이처럼 Spring은 개발자가 저수준의 반복적인 작업을 하지 않고, 비즈니스 로직에 집중할 수 있도록 점점 더 편리하고 높은 수준의 추상화를 제공하는 방향으로 발전해왔습니다.</p>
<hr>
<hr>
<h3 id="추상화-단계별-설명-1">추상화 단계별 설명</h3>
<p>Spring 프레임워크는 개발자가 웹 개발의 복잡한 저수준 세부 사항에서 벗어나 비즈니스 로직에 집중할 수 있도록 다양한 수준의 추상화를 제공합니다. 여기서는 가장 낮은 추상화 단계부터 높은 추상화 단계까지, Spring이 어떻게 개발 경험을 간소화하는지 단계별로 살펴보겠습니다.</p>
<hr>
<h3 id="level-1-servlet-api-직접-사용-가장-낮은-추상화-단계">Level 1: Servlet API 직접 사용 (가장 낮은 추상화 단계)</h3>
<p>이 단계는 Spring의 도움을 최소한으로 받고, Java Servlet의 핵심 객체를 직접 다루는 방식입니다. HTTP 요청/응답의 모든 요소를 바닥부터 제어해야 할 때, 또는 기존 Servlet 기반 코드를 Spring으로 마이그레이션할 때 유용합니다.</p>
<ul>
<li>
<p><strong><code>HttpServletRequest</code> (예시: <code>public void method(HttpServletRequest request)</code>)</strong>
HTTP 요청 정보를 모두 담고 있는 객체입니다. 헤더, 파라미터, 쿠키, 세션, Body, 요청 URI, 원격지 IP 등 모든 요청 데이터에 직접 접근할 수 있습니다.</p>
<ul>
<li><strong>기본 사용:</strong>
<ul>
<li><code>String name = request.getParameter(&quot;name&quot;);</code></li>
<li><code>String userAgent = request.getHeader(&quot;User-Agent&quot;);</code></li>
</ul>
</li>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>동일 이름의 여러 파라미터 받기:</strong> <code>String[] interests = request.getParameterValues(&quot;interest&quot;);</code> (예: <code>?interest=coding&amp;interest=music</code> 요청 시)</li>
<li><strong>모든 헤더 이름 조회:</strong> <code>Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</code></li>
<li><strong>요청 Body 직접 읽기 (JSON):</strong> <code>String jsonBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>HttpServletResponse</code> (예시: <code>public void method(HttpServletResponse response)</code>)</strong>
HTTP 응답을 제어하는 객체입니다. 응답 상태 코드(Status Code), 헤더, 쿠키를 설정하거나 응답 Body에 직접 데이터를 쓸 수 있습니다.</p>
<ul>
<li><strong>기본 사용:</strong>
<ul>
<li><code>response.setStatus(HttpServletResponse.SC_CREATED);</code> (201 상태 코드 설정)</li>
<li><code>response.getWriter().write(&quot;hello world&quot;);</code></li>
</ul>
</li>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>커스텀 헤더 추가:</strong> <code>response.setHeader(&quot;X-Custom-Auth&quot;, &quot;some-token&quot;);</code></li>
<li><strong>파일 다운로드를 위한 헤더 설정:</strong> <code>response.setContentType(&quot;application/octet-stream&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;data.csv\&quot;&quot;);</code></li>
<li><strong>에러 응답 보내기:</strong> <code>response.sendError(400, &quot;Invalid parameter&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>HttpSession</code> (예시: <code>public void method(HttpSession session)</code>)</strong>
세션 객체를 직접 다룰 때 사용합니다. 세션에 데이터를 저장(<code>setAttribute</code>), 조회(<code>getAttribute</code>), 무효화(<code>invalidate</code>)할 수 있습니다.</p>
<ul>
<li><strong>기본 사용:</strong>
<ul>
<li><code>session.setAttribute(&quot;cart&quot;, new Cart());</code></li>
<li><code>Cart cart = (Cart) session.getAttribute(&quot;cart&quot;);</code></li>
<li><code>session.invalidate();</code></li>
</ul>
</li>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>세션 타임아웃 설정:</strong> <code>session.setMaxInactiveInterval(1800);</code> (30분)</li>
<li><strong>세션 생성 시간 확인:</strong> <code>long creationTime = session.getCreationTime();</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>java.security.Principal</code> (예시: <code>public String getUsername(Principal principal)</code>)</strong>
현재 인증된 사용자 정보를 담고 있는 객체입니다. Spring Security와 함께 사용할 경우, <code>principal.getName()</code>을 통해 로그인한 사용자의 ID를 얻을 수 있습니다.</p>
<ul>
<li><strong>참고:</strong> 최신 Spring Security에서는 <code>@AuthenticationPrincipal</code> 어노테이션을 사용하여 더 타입-세이프하게 사용자 객체를 주입받는 것을 권장합니다.</li>
</ul>
</li>
<li>
<p><strong><code>java.util.Locale</code> (예시: <code>public void method(Locale locale)</code>)</strong>
요청의 지역 정보를 담고 있는 객체입니다. 클라이언트의 <code>Accept-Language</code> 헤더를 기반으로 결정되며, 다국어 처리 시 현재 언어에 맞는 메시지를 보여주는 데 사용됩니다.</p>
<ul>
<li><strong>예시:</strong> <code>locale.getLanguage()</code>는 &ldquo;ko&rdquo;, <code>locale.getCountry()</code>는 &ldquo;KR&rdquo;, <code>locale.toString()</code>는 &ldquo;ko_KR&rdquo; 등을 반환할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong><code>InputStream</code> / <code>Reader</code> (예시: <code>public void method(InputStream input, Reader reader)</code>)</strong>
요청 Body의 내용을 직접 스트림으로 읽을 때 사용합니다. 대용량 파일을 처리하거나, Spring의 메시지 컨버터를 거치지 않은 원본 데이터를 읽고 싶을 때 유용합니다.</p>
<ul>
<li><strong>예시 (파일 업로드 처리):</strong> <code>Files.copy(input, new File(&quot;uploaded-file.dat&quot;).toPath());</code></li>
</ul>
</li>
<li>
<p><strong><code>OutputStream</code> / <code>Writer</code> (예시: <code>public void method(OutputStream output, Writer writer)</code>)</strong>
응답 Body에 직접 스트림으로 데이터를 쓸 때 사용합니다. 대용량 파일을 다운로드시키거나, 특정 형식의 응답을 수동으로 구성할 때 사용됩니다.</p>
<ul>
<li><strong>예시 (대용량 CSV 생성):</strong> <code>try (PrintWriter printWriter = new PrintWriter(writer)) { printWriter.println(&quot;id,name&quot;); printWriter.println(&quot;1,John&quot;); }</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="level-2-기본-매핑과-요청-데이터-추출-1">Level 2: 기본 매핑과 요청 데이터 추출</h3>
<p>이 단계에서는 URL과 메서드를 연결하고, URL이나 헤더 등에서 원하는 값을 편리하게 추출할 수 있습니다.</p>
<ul>
<li>
<p><strong><code>@Controller</code> (예시: <code>@Controller public class MyController { ... }</code>)</strong>
클래스 레벨에 붙이며, 해당 클래스가 Spring MVC의 컨트롤러임을 나타냅니다. Spring이 이 클래스를 스캔하여 웹 요청을 처리하는 핸들러로 사용합니다.</p>
</li>
<li>
<p><strong><code>@RequestMapping</code> (예시: <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.POST, consumes=&quot;application/json&quot;, produces=&quot;application/json&quot;)</code>)</strong>
특정 URL 경로와 HTTP 메서드를 처리할 메서드에 연결(매핑)합니다.</p>
<ul>
<li>
<p><strong>속성 상세:</strong></p>
<ul>
<li><code>params</code>: 특정 파라미터가 있을 때만 매핑 (예: <code>params=&quot;mode=edit&quot;</code>).</li>
<li><code>headers</code>: 특정 헤더가 있을 때만 매핑 (예: <code>headers=&quot;X-API-VERSION=2&quot;</code>).</li>
<li><code>consumes</code>: 요청의 <code>Content-Type</code>을 제한. (예: <code>application/json</code>)</li>
<li><code>produces</code>: 응답의 <code>Content-Type</code>을 지정. (예: <code>application/xml</code>)</li>
</ul>
</li>
<li>
<p><strong>추가 예시 (클래스/메서드 조합):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@RequestMapping</span>(<span style="color:#e6db74">&#34;/users&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserController</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@RequestMapping</span>(<span style="color:#e6db74">&#34;/{id}&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getUser</span>() { <span style="color:#75715e">/* -&gt; /users/{id} */</span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>@RequestParam</code> (예시: <code>public void search(@RequestParam(value=&quot;q&quot;, required=false, defaultValue=&quot;spring&quot;) String query)</code>)</strong>
URL의 쿼리 파라미터(<code>?q=...</code>)나 <code>x-www-form-urlencoded</code> 형식의 form-data 값을 메서드 파라미터에 바인딩합니다.</p>
<ul>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>모든 파라미터 받기:</strong> <code>public void allParams(@RequestParam Map&lt;String, String&gt; paramMap)</code></li>
<li><strong>여러 값 받기:</strong> <code>public void listParams(@RequestParam List&lt;String&gt; interest)</code> (예: <code>?interest=a&amp;interest=b</code>)</li>
<li><strong>Java 8 <code>Optional</code> 사용:</strong> <code>public void optionalParam(@RequestParam Optional&lt;String&gt; query)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>@PathVariable</code> (예시: <code>@RequestMapping(&quot;/users/{userId}/orders/{orderId}&quot;) public void method(@PathVariable Long userId, @PathVariable Long orderId)</code>)</strong>
URL 경로의 일부를 변수로 사용할 때 씁니다. (예: <code>/users/123/orders/456</code> 에서 <code>123</code>과 <code>456</code>을 각각 <code>userId</code>, <code>orderId</code> 변수에 바인딩).</p>
<ul>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>변수명 다를 때:</strong> <code>@PathVariable(&quot;userId&quot;) Long id</code></li>
<li><strong>정규식으로 제한:</strong> <code>@GetMapping(&quot;/members/{memberId:[0-9]+}&quot;) public void getMember(@PathVariable Long memberId)</code></li>
<li><strong><code>Map</code>으로 받기:</strong> <code>@GetMapping(&quot;/{var1}/{var2}&quot;) public void pathVars(@PathVariable Map&lt;String, String&gt; pathVarMap)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>@RequestHeader</code> (예시: <code>public void method(@RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader(name=&quot;Accept-Language&quot;, required=false) String lang)</code>)</strong>
요청 헤더의 특정 값을 파라미터로 받아옵니다.</p>
<ul>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>모든 헤더 받기 (Map):</strong> <code>@RequestHeader Map&lt;String, String&gt; headerMap</code></li>
<li><strong>모든 헤더 받기 (객체):</strong> <code>@RequestHeader MultiValueMap&lt;String, String&gt; multiValueMap</code>, <code>@RequestHeader HttpHeaders headers</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>@CookieValue</code> (예시: <code>public void method(@CookieValue(value=&quot;JSESSIONID&quot;, required=false) String sessionId)</code>)</strong>
요청에 포함된 쿠키의 값을 파라미터로 받아옵니다.</p>
<ul>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>쿠키가 없을 때 예외:</strong> <code>required=true</code> (기본값)이고 쿠키가 없으면 <code>MissingRequestCookieException</code> 발생.</li>
<li><strong>기본값 설정:</strong> <code>@CookieValue(defaultValue = &quot;guest&quot;) String visitorId</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="level-3-데이터-바인딩-및-응답세션-처리">Level 3: 데이터 바인딩 및 응답/세션 처리</h3>
<p>이 단계에서는 요청 데이터를 객체에 자동으로 담거나, View에 전달할 데이터 및 세션을 편리하게 관리할 수 있습니다.</p>
<ul>
<li>
<p><strong><code>@ModelAttribute</code> (예시 1: <code>public String saveUser(@ModelAttribute UserDto userDto)</code>, 예시 2: <code>@ModelAttribute(&quot;categories&quot;) public List&lt;Category&gt; getCategories() { ... }</code>)</strong></p>
<ul>
<li>
<p><strong>1. (파라미터에서 사용 시)</strong> 여러 요청 파라미터를 객체(DTO, VO)의 필드에 자동으로 바인딩합니다. (예: <code>?name=John&amp;age=30</code> -&gt; <code>UserDto</code> 객체). 생략 가능합니다.</p>
</li>
<li>
<p><strong>2. (메서드에 사용 시)</strong> 특정 메서드 위에 붙이면, 해당 컨트롤러의 모든 요청 처리 전에 이 메서드가 먼저 실행되고 반환값이 Model에 자동으로 추가됩니다.</p>
</li>
<li>
<p><strong>추가 예시 (수정 폼):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@ModelAttribute</span>(<span style="color:#e6db74">&#34;user&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> User <span style="color:#a6e22e">findUser</span>(<span style="color:#a6e22e">@PathVariable</span> Long id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> userRepository.<span style="color:#a6e22e">findById</span>(id);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">updateUser</span>(<span style="color:#a6e22e">@ModelAttribute</span>(<span style="color:#e6db74">&#34;user&#34;</span>) User user) { <span style="color:#75715e">/* ... */</span> }
</span></span></code></pre></div><p>(위 예시는 <code>findUser</code>로 DB에서 user를 조회해 모델에 넣고, 요청 파라미터로 그 user 객체를 덮어씁니다.)</p>
</li>
</ul>
</li>
<li>
<p><strong><code>Model</code> / <code>ModelMap</code> / <code>Map</code> (예시: <code>public String method(Model model)</code>)</strong>
View에 전달할 데이터를 담는 컨테이너 역할을 합니다. <code>model.addAttribute(&quot;key&quot;, value)</code> 형태로 데이터를 추가하면 View(JSP, Thymeleaf 등)에서 해당 키로 데이터를 사용할 수 있습니다. <code>Model</code>, <code>ModelMap</code>, <code>Map</code>은 사실상 동일하게 동작합니다.</p>
</li>
<li>
<p><strong><code>ModelAndView</code> (예시: <code>public ModelAndView method() { ModelAndView mav = new ModelAndView(&quot;user/profile&quot;); mav.addObject(&quot;user&quot;, user); return mav; }</code>)</strong>
<strong>Model</strong>과 <strong>View</strong>를 하나로 합친 객체입니다. 처리 결과를 보여줄 View의 이름과 View에 전달할 데이터를 함께 담아 반환할 수 있습니다.</p>
<ul>
<li><strong>추가 예시 (상태 코드 설정):</strong> <code>mav.setStatus(HttpStatus.CREATED);</code></li>
</ul>
</li>
<li>
<p><strong><code>@SessionAttributes</code> (예시: <code>@Controller @SessionAttributes(&quot;user&quot;)</code>)</strong>
컨트롤러 클래스 레벨에 사용하여, Model에 추가된 특정 이름의 속성을 HTTP 세션에도 저장하도록 지정합니다. 여러 페이지에 걸쳐 특정 객체(ex: 장바구니, 폼 데이터)를 유지해야 할 때 편리합니다.</p>
<ul>
<li><strong><code>SessionStatus</code>와 함께 사용:</strong>
<code>public String complete(SessionStatus status) { status.setComplete(); return &quot;redirect:/&quot;; }</code> (세션 데이터 정리)</li>
</ul>
</li>
<li>
<p><strong><code>@SessionAttribute</code> (예시: <code>public void method(@SessionAttribute(name=&quot;user&quot;, required=false) User loggedInUser)</code>)</strong>
HTTP 세션에 저장된 특정 속성을 직접 파라미터로 받아올 때 사용합니다. <code>@SessionAttributes</code>와 달리, 세션에 있는 값을 직접 조회하는 용도입니다. 다른 곳(e.g., 필터)에서 세션에 넣은 값을 꺼낼 때 유용합니다.</p>
</li>
<li>
<p><strong><code>RedirectAttributes</code> (예시: <code>public String save(RedirectAttributes redirectAttributes) { redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;저장되었습니다!&quot;); return &quot;redirect:/users&quot;; }</code>)</strong>
리다이렉트 시 데이터를 전달하는 데 특화된 객체입니다.</p>
<ul>
<li><strong><code>addFlashAttribute</code></strong>: 1회성 데이터로, 리다이렉트된 페이지에서만 사용되고 세션에서 즉시 사라집니다. (Post-Redirect-Get 패턴에 유용). URL에 노출되지 않습니다.</li>
<li><strong><code>addAttribute</code></strong>: URL 쿼리 파라미터로 추가됩니다. (예: <code>return &quot;redirect:/users/{id}&quot;</code> 와 함께 사용 시 <code>{id}</code>에 바인딩, 나머지는 쿼리 파라미터)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="level-4-rest-api를-위한-추상화-1">Level 4: REST API를 위한 추상화</h3>
<p>이 단계는 전통적인 HTML View 반환이 아닌, JSON/XML과 같은 데이터 자체를 응답하는 RESTful API 개발에 특화된 고수준 추상화입니다.</p>
<ul>
<li>
<p><strong><code>@RequestBody</code> (예시: <code>public UserDto createUser(@RequestBody CreateUserRequest request)</code>)</strong>
요청의 Body에 담겨 오는 데이터(주로 JSON, XML)를 Java 객체로 변환(역직렬화)합니다. 내부적으로 <code>HttpMessageConverter</code>(주로 Jackson 라이브러리)가 동작합니다.</p>
<ul>
<li><strong>추가 예시:</strong>
<ul>
<li><strong>유효성 검사:</strong> <code>public void create(@Valid @RequestBody UserDto userDto, BindingResult bindingResult)</code></li>
<li><strong>Raw 데이터 받기:</strong> <code>public void rawJson(@RequestBody String jsonString)</code></li>
<li><strong>Map으로 받기:</strong> <code>public void mapBody(@RequestBody Map&lt;String, Object&gt; dataMap)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>@ResponseBody</code> (예시: <code>@ResponseBody @GetMapping(&quot;/api/users/1&quot;) public UserDto getUser() { ... }</code>)</strong>
메서드가 반환하는 Java 객체를 HTTP 응답 Body에 직접 써넣도록 지시합니다. View를 찾는 것이 아니라, 반환된 객체를 JSON이나 XML 등의 데이터 형식으로 변환(직렬화)하여 클라이언트에 전송합니다.</p>
</li>
<li>
<p><strong><code>HttpEntity&lt;T&gt;</code> (예시: <code>public String process(HttpEntity&lt;String&gt; httpEntity) { String body = httpEntity.getBody(); HttpHeaders headers = httpEntity.getHeaders(); ... }</code>)</strong>
요청의 헤더와 바디를 함께 감싼 객체입니다. <code>@RequestBody</code>와 <code>@RequestHeader</code>를 합친 것과 유사하며, 요청의 모든 요소를 한 번에 받아 분석할 때 유용합니다. <strong>응답 시에도 사용 가능합니다.</strong></p>
</li>
<li>
<p><strong><code>ResponseEntity&lt;T&gt;</code> (예시: <code>public ResponseEntity&lt;UserDto&gt; getUser(@PathVariable Long id) { UserDto user = userService.findById(id); HttpHeaders headers = new HttpHeaders(); headers.add(&quot;X-Custom-Header&quot;, &quot;value&quot;); return new ResponseEntity&lt;&gt;(user, headers, HttpStatus.OK); }</code>)</strong>
<code>@ResponseBody</code>의 확장판으로, 응답 데이터(Body)뿐만 아니라 **HTTP 상태 코드(Status Code)**와 **헤더(Header)**까지 세밀하게 제어하여 반환하고 싶을 때 사용합니다.</p>
<ul>
<li><strong>추가 예시 (빌더 패턴):</strong>
<ul>
<li><strong>성공:</strong> <code>return ResponseEntity.ok(user);</code></li>
<li><strong>생성됨:</strong> <code>URI location = ...; return ResponseEntity.created(location).build();</code></li>
<li><strong>콘텐츠 없음:</strong> <code>return ResponseEntity.noContent().build();</code></li>
<li><strong>요청 오류:</strong> <code>return ResponseEntity.badRequest().body(&quot;Error message&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>@ResponseStatus</code> (예시: <code>@ResponseStatus(HttpStatus.CREATED) @PostMapping(&quot;/users&quot;) public void createUser(...)</code>)</strong>
성공적인 응답의 HTTP 상태 코드를 지정하는 어노테이션입니다. <code>void</code>를 반환하거나 데이터만 반환하면서도 상태 코드를 200 OK가 아닌 201 Created, 204 No Content 등으로 설정하고 싶을 때 간편하게 사용합니다.</p>
<ul>
<li>
<p><strong>추가 예시 (예외 클래스에 적용):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@ResponseStatus</span>(value <span style="color:#f92672">=</span> HttpStatus.<span style="color:#a6e22e">NOT_FOUND</span>, reason <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;User not found&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserNotFoundException</span> <span style="color:#66d9ef">extends</span> RuntimeException {}
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<hr>
<h3 id="level-5-편의성을-위한-조합-및-축약-가장-높은-추상화-단계">Level 5: 편의성을 위한 조합 및 축약 (가장 높은 추상화 단계)</h3>
<p>이 단계에서는 자주 사용되는 패턴을 하나의 어노테이션으로 묶어 코드의 가독성과 생산성을 높입니다. &lsquo;문법적 설탕(Syntactic Sugar)&lsquo;의 대표적인 예시들입니다.</p>
<ul>
<li>
<p><strong><code>@RestController</code> (예시: <code>@RestController @RequestMapping(&quot;/api/users&quot;) public class UserApiController { ... }</code>)</strong>
<strong><code>@Controller</code> + <code>@ResponseBody</code></strong> 의 조합입니다. 이 어노테이션을 클래스에 붙이면, 해당 컨트롤러의 모든 메서드에는 기본적으로 <code>@ResponseBody</code>가 적용됩니다. 따라서 모든 메서드가 View를 반환하는 대신 데이터(JSON 등)를 반환하게 되므로, REST API를 만들 때 매우 편리합니다.</p>
</li>
<li>
<p><strong><code>@GetMapping</code> (예시: <code>@GetMapping(&quot;/{id}&quot;)</code>)</strong>
<strong><code>@RequestMapping(method = RequestMethod.GET)</code></strong> 의 축약형입니다.</p>
</li>
<li>
<p><strong><code>@PostMapping</code> (예시: <code>@PostMapping</code>)</strong>
<strong><code>@RequestMapping(method = RequestMethod.POST)</code></strong> 의 축약형입니다.</p>
</li>
<li>
<p><strong><code>@PutMapping</code> (예시: <code>@PutMapping(&quot;/{id}&quot;)</code>)</strong>
<strong><code>@RequestMapping(method = RequestMethod.PUT)</code></strong> 의 축약형입니다.</p>
</li>
<li>
<p><strong><code>@DeleteMapping</code> (예시: <code>@DeleteMapping(&quot;/{id}&quot;)</code>)</strong>
<strong><code>@RequestMapping(method = RequestMethod.DELETE)</code></strong> 의 축약형입니다.</p>
</li>
<li>
<p><strong><code>@PatchMapping</code> (예시: <code>@PatchMapping(&quot;/{id}&quot;)</code>)</strong>
<strong><code>@RequestMapping(method = RequestMethod.PATCH)</code></strong> 의 축약형입니다.</p>
</li>
<li>
<p><strong><code>@ControllerAdvice</code> / <code>@RestControllerAdvice</code> (예시: <code>@RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(IllegalArgumentException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ErrorResponse handleIllegalArgument(Exception e) { ... } }</code>)</strong>
<strong>전역 설정</strong>을 위한 고수준 추상화입니다.</p>
<ul>
<li><strong><code>@ExceptionHandler</code></strong>: 여러 컨트롤러에서 발생하는 특정 예외를 한 곳에서 공통으로 처리합니다.</li>
<li><strong><code>@ModelAttribute</code></strong>: 모든 컨트롤러에 공통으로 필요한 모델 데이터를 추가합니다.</li>
<li><strong><code>@InitBinder</code></strong>: 모든 컨트롤러에 적용될 데이터 바인딩 설정을 합니다.</li>
<li><code>@RestControllerAdvice</code>는 <code>@ControllerAdvice</code>와 <code>@ResponseBody</code>를 합친 것으로, 예외 처리 결과 자체를 JSON 같은 데이터로 응답할 때 사용합니다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="요약-추상화의-흐름-1">요약: 추상화의 흐름</h3>
<p>Spring은 개발자가 저수준의 반복적인 작업을 하지 않고, 비즈니스 로직에 집중할 수 있도록 점점 더 편리하고 높은 수준의 추상화를 제공하는 방향으로 발전해왔습니다.</p>
<ul>
<li>
<p><strong>Servlet API (HttpServletRequest)</strong></p>
<blockquote>
<p>&ldquo;HTTP 요청의 모든 것을 내가 직접 다룰게.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@RequestMapping</code></strong></p>
<blockquote>
<p>&ldquo;이 URL을 이 메서드에 연결하는 건 Spring에게 맡길게.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@CookieValue</code></strong></p>
<blockquote>
<p>&ldquo;요청에서 값 꺼내는 귀찮은 일도 Spring이 알아서 해줘.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@ModelAttribute</code></strong></p>
<blockquote>
<p>&ldquo;파라미터가 많아도 괜찮아. 객체로 한 번에 받을 수 있어.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@RequestBody</code></strong></p>
<blockquote>
<p>&ldquo;요청 Body의 JSON을 이 객체로 바꾸는 건 이제 신경 안 쓸래.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@ResponseBody</code></strong></p>
<blockquote>
<p>&ldquo;메서드 반환값을 바로 JSON으로 응답해줘. Java 객체를 다시 JSON으로 바꾸는 것도 Spring이 알아서 해줘.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@RestController</code></strong></p>
<blockquote>
<p>&ldquo;매번 <code>@ResponseBody</code> 붙이기 귀찮으니 이 컨트롤러는 전부 REST API용으로 <code>@RestController</code>만 선언할게.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@GetMapping</code> 등 HTTP 메서드별 축약 어노테이션</strong></p>
<blockquote>
<p>&ldquo;코드를 더 짧고 명확하게 만들자.&rdquo;</p>
</blockquote>
</li>
<li>
<p><strong>→ <code>@RestControllerAdvice</code></strong></p>
<blockquote>
<p>&ldquo;모든 컨트롤러에서 발생하는 예외는 여기서 한 번에 처리하자. 중복되는 예외 처리 코드는 한 곳에 모아서 관리할래.&rdquo;</p>
</blockquote>
</li>
</ul>
<p>각 단계의 특징을 이해하면 상황에 맞는 최적의 도구를 선택하여 효율적으로 개발할 수 있습니다.</p>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
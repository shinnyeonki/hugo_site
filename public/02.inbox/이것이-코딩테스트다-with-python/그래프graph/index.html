<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>그래프(graph) | My Test Site</title>
    

    
    
    <meta name="description" content="📖 그래프의 종류와 개념 hello pdf 테스트
그래프는 여러 개의 점(노드 또는 정점)들이 선으로 연결된 구조를 나타내는 수학적인 개념입니다. 그래프는 다양한 현실 세계의 문제를 모델링하고 분석하는 데 사용됩니다.
그래프의 용어 노드(Node) 또는 정점 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4-with-python/%EA%B7%B8%EB%9E%98%ED%94%84graph/">

    
    
    
    <meta property="og:title" content="그래프(graph)">
    <meta property="og:description" content="📖 그래프의 종류와 개념 hello pdf 테스트
그래프는 여러 개의 점(노드 또는 정점)들이 선으로 연결된 구조를 나타내는 수학적인 개념입니다. 그래프는 다양한 현실 세계의 문제를 모델링하고 분석하는 데 사용됩니다.
그래프의 용어 노드(Node) 또는 정점 …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4-with-python/%EA%B7%B8%EB%9E%98%ED%94%84graph/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="그래프(graph)">
    <meta name="twitter:description" content="📖 그래프의 종류와 개념 hello pdf 테스트
그래프는 여러 개의 점(노드 또는 정점)들이 선으로 연결된 구조를 나타내는 수학적인 개념입니다. 그래프는 다양한 현실 세계의 문제를 모델링하고 분석하는 데 사용됩니다.
그래프의 용어 노드(Node) 또는 정점 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>그래프(graph) **page.html**</h1>
    <h2 id="-그래프의-종류와-개념">📖 그래프의 종류와 개념</h2>
<p><a href="http://localhost:1313/02.inbox/2%EC%9D%98-%EB%B3%B4%EC%88%98%EB%A5%BC-%EC%9D%8C%EC%88%98-%ED%91%9C%ED%98%84%EB%B2%95%EC%9C%BC%EB%A1%9C-%EC%A0%95%ED%95%9C-%EC%9D%B4%EC%9C%A0/" class="internal-link">hello</a>
<a href="/08.media/Bootloader%20Boot%20Procedure.pdf" class="internal-file-link">pdf 테스트</a></p>
<p>그래프는 여러 개의 점(노드 또는 정점)들이 선으로 연결된 구조를 나타내는 <strong>수학적인 개념</strong>입니다. 그래프는 다양한 현실 세계의 문제를 모델링하고 분석하는 데 사용됩니다.</p>
<h2 id="그래프의-용어">그래프의 용어</h2>
<p>
        <img src="/08.media/20240428022601.png" alt="Pasted image 20240428022601 (Image resource not found)" ></p>
<dl>
<dt><code>노드(Node) 또는 정점(Vertex)</code> N or V</dt>
<dd>그래프에서 하나의 점을 나타냅니다. 노드는 데이터를 저장하는데 사용될 수 있습니다.<br>
<code>간선(Edge)</code>  E</dd>
<dd>그래프에서 노드와 노드를 연결하는 선을 나타냅니다. 간선은 노드 쌍 사이의 관계를 나타냅니다.<br>
<code>인접(Adjacent)</code></dd>
<dd>두 개의 노드가 간선으로 직접 연결되어 있는 상태를 말합니다. 인접한 노드는 서로 이웃이라고도 합니다.<br>
<code>차수(Degree)</code></dd>
<dd><strong>노드에 연결된 간선의 수</strong>를 나타냅니다. 무방향 그래프에서는 노드의 차수는 해당 노드와 인접한 노드의 수입니다.<br>
<code>경로(Path)</code></dd>
<dd>그래프에서 노드들을 연결하는 간선의 순서를 나타내는 순서쌍입니다. 경로의 길이는 경로에 속한 간선의 수입니다.<br>
<code>사이클(Cycle)</code></dd>
<dd>그래프에서 동일한 노드로 되돌아오는 경로를 말합니다. 즉, 경로의 시작 노드와 끝 노드가 동일한 경우를 말합니다.<br>
<code>가중치(Weight)</code></dd>
<dd>가중치 그래프에서 간선에 할당된 값 또는 비용을 나타냅니다. 가중치는 간선의 특성을 나타내는데 사용됩니다.</dd>
</dl>
<h2 id="그래프의-종류">그래프의 종류</h2>
<dl>
<dt><code>무방향 그래프</code> &amp; <code>방향 그래프</code></dt>
<dd>간선의 방향의 유무에 따라 구분되는 그래프<br>

        <img src="/08.media/20240428022606.png" alt="Pasted image 20240428022606 (Image resource not found)" ><br>
<code>가중치 그래프</code></dd>
<dd>그래프에 가중치 또는 비용이 할당된 그래프(네트워크 이론이나 신경망 이론에 활용되는 개념)<br>

        <img src="/08.media/20240428022605.png" alt="Pasted image 20240428022605 (Image resource not found)" ><br>
<code>연결 그래프</code> &amp; <code>비연결 그래프</code></dd>
<dd>모든 노드에 대해 경로가 존재하면 <strong>연결 그래프</strong>, 특정 노드에 대한 경로가 하나라도 존재하지 않을 경우 <strong>비연결 그래프</strong><br>

        <img src="/08.media/20240428022602.png" alt="Pasted image 20240428022602 (Image resource not found)" ><br>
<code>사이클 그래프</code> &amp; <code>비순환 그래프</code><br>

        <img src="/08.media/20240428022603.png" alt="Pasted image 20240428022603 (Image resource not found)" ><br>
<code>완전 그래프</code></dd>
<dd>그래프의 모든 노드가 연결되어 있는 그래프<br>

        <img src="/08.media/20240428022604.png" alt="Pasted image 20240428022604 (Image resource not found)" ></dd>
</dl>
<hr>
<h2 id="그래프의-한-종류인-트리에-대해">그래프의 한 종류인 트리에 대해🧐</h2>
<p>트리(Tree)는 그래프(Graph)의 한 종류로, <strong>계층적인 구조</strong>를 나타내는 <strong>비순환적인 연결 그래프</strong>입니다. 트리는 하나의 루트(Root) 노드에서 시작하여 다양한 자식(Child) 노드들로 확장되는 구조를 가지며, 각 노드는 하나의 부모(Parent) 노드와 연결되어 있습니다.</p>
<h2 id="트리의-특징-">트리의 특징 🔎</h2>
<p><code>계층 구조</code>: 트리는 하나의 루트 노드에서 시작하여 계층적인 구조를 형성합니다. 각 노드는 부모-자식 관계를 가지며, 자식 노드들은 동일한 계층에 속합니다.</p>
<p><code>방향성</code>: 트리는 방향 그래프의 한 형태로, 간선은 단방향으로 표시됩니다. 각 노드는 자식 노드들을 가리키는 방향으로 연결됩니다.</p>
<p><code>비순환성</code>: 트리는 순환 구조를 가지지 않습니다. 즉, 어떤 노드에서 시작해도 동일한 노드로 되돌아갈 수 있는 순환 경로가 존재하지 않습니다.</p>
<p><code>유일한 경로</code>: 루트 노드에서 어떤 노드까지의 경로는 유일합니다. 트리 내에서는 어떤 노드도 다른 경로를 통해 도달할 수 없습니다</p>
<h2 id="트리에-종류">트리에 종류</h2>
<dl>
<dt><code>이진 트리 (Binary Tree)</code></dt>
<dd>각 노드가 최대 <strong>두 개의 자식을 가질 수 있는 트리</strong>입니다. 이진 트리는 왼쪽 자식과 오른쪽 자식으로 구성되며, 자식의 배치에는 순서가 있습니다. 이진 트리는 데이터 검색, 정렬, 압축 등 다양한 애플리케이션에서 사용됩니다.</dd>
<dt><code>이진 탐색 트리 (Binary Search Tree)</code></dt>
<dd>이진 트리의 한 종류로, 이진 탐색의 원리를 기반으로 합니다. 모든 노드는 <strong>왼쪽 서브트리의 값보다 작고, 오른쪽 서브트리의 값보다 큰 키 값을 가집니다.</strong> 이진 탐색 트리는 데이터 검색, 정렬, 범위 검색 등에 효율적으로 사용됩니다.</dd>
<dt><code>AVL 트리</code></dt>
<dd>균형 이진 탐색 트리로서, 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1인 트리입니다. AVL 트리는 삽입, 삭제 시에 자동으로 균형을 유지하여 탐색 성능을 보장합니다.</dd>
<dt><code>레드-블랙 트리 (Red-Black Tree)</code></dt>
<dd>균형 이진 탐색 트리로서, 각 노드는 레드(Red) 또는 블랙(Black) 색깔을 가지며, 특정한 규칙을 따릅니다. 레드-블랙 트리는 AVL 트리보다 균형을 유지하는 데에 조금 덜 엄격한 규칙을 가지며, 데이터의 삽입과 삭제가 더 효율적입니다.</dd>
<dt><code>B-트리 (B-Tree)</code></dt>
<dd>다양한 자료 구조에서 사용되는 균형 탐색 트리입니다. B-트리는 노드마다 여러 개의 키 값을 가지며, 많은 수의 자식을 가질 수 있습니다. B-트리는 대용량 데이터베이스의 인덱스 구조나 파일 시스템에서 사용되는 것과 같은 곳에서 사용됩니다.</dd>
<dt><code>힙 (Heap)</code></dt>
<dd>이진 트리의 한 종류로, 최대 힙과 최소 힙으로 나눌 수 있습니다. 최대 힙은 부모 노드의 값이 자식 노드의 값보다 큰 힙이며, 최소 힙은 그 반대입니다. 힙은 우선순위 큐와 같은 자료 구조에서 사용되어 최댓값 또는 최솟값에 빠르게 접근할 수 있습니다.</dd>
</dl>
<hr>
<h3 id="그래프graph의-구현-2가지">그래프(Graph)의 구현 2가지</h3>
<h4 id="1-인접-리스트adjacency-list">1. 인접 리스트(Adjacency List)</h4>
<p>인접 리스트(Adjacency List)로 그래프를 표현하는 것이 <strong>가장 일반적인 방법</strong> 이다.</p>
<ul>
<li>모든 정점(혹은 노드)을 인접 리스트에 저장한다. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시한 것이다.
<ul>
<li>
<p>배열(혹은 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 리스트(배열, 동적 가변 크기 배열(ArrayList), 연결리스트(LinkedList) 등)를 이용해서 인접 리스트를 표현</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>0: 1
</span></span><span style="display:flex;"><span>1: 2
</span></span><span style="display:flex;"><span>2: 0, 3
</span></span><span style="display:flex;"><span>3: 2
</span></span><span style="display:flex;"><span>4: 6
</span></span><span style="display:flex;"><span>5: 4
</span></span><span style="display:flex;"><span>6: 5
</span></span></code></pre></div></li>
<li>
<p>정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 리스트에 쉽게 접근할 수 있다.</p>
</li>
</ul>
</li>
<li>무방향 그래프(Undirected Graph)에서 (a, b) 간선은 두 번 저장된다.
<ul>
<li>한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.</li>
<li>정점의 수: N, 간선의 수: E인 무방향 그래프의 경우
<ul>
<li>N개의 리스트, <strong>N개의 배열,</strong> 2E개의 노드가 필요</li>
</ul>
</li>
</ul>
</li>
<li>트리에선 특정 노드 하나(루트 노드)에서 다른 모든 노드로 접근이 가능 -&gt; Tree 클래스 불필요
<ul>
<li>
<p>그래프에선 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않음 -&gt; Graph 클래스 필요</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span> { <span style="color:#66d9ef">public</span> Node<span style="color:#f92672">[]</span> nodes; }
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 트리의 노드 클래스와 동일</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> String name;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Node<span style="color:#f92672">[]</span> children;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="2-인접-행렬adjacency-matrix">2. 인접 행렬(Adjacency Matrix)</h4>
<p>인접 행렬은 NxN 불린 행렬(Boolean Matrix)로써 matrix[i][j]가 true라면 i -&gt; j로의 간선이 있다는 뜻이다.</p>
<ul>
<li>
<p>0과 1을 이용한 정수 행렬(Integer Matrix)을 사용할 수도 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(간선 (i, j)가 그래프에 존재)
</span></span><span style="display:flex;"><span>  matrix<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  matrix<span style="color:#f92672">[</span>i<span style="color:#f92672">][</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0;
</span></span></code></pre></div></li>
<li>
<p>정점(노드)의 개수가 N인 그래프를 인접 행렬로 표현</p>
<ul>
<li>간선의 수와 무관하게 항상 n^2개의 메모리 공간이 필요하다.</li>
</ul>
</li>
<li>
<p>무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭 행렬(Symmetric Matrix)이 된다.</p>
<ul>
<li>물론 방향 그래프는 대칭 행렬이 안 될 수도 있다.</li>
</ul>
</li>
<li>
<p>인접 리스트를 사용한 그래프 알고리즘들(Ex. 너비 우선 탐색) 또한 인접 행렬에서도 사용이 가능하다.</p>
<ul>
<li>하지만 인접 행렬은 조금 <strong>효율성이 떨어진다.</strong></li>
<li>인접 리스트는 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있지만 인접 행렬에서는 <strong>인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 한다.</strong></li>
</ul>
</li>
</ul>
<p>==인접 리스트와 인접 행렬 중 선택 방법==</p>
<ul>
<li>인접 리스트
<ul>
<li>그래프 내에 적은 숫자의 간선만을 가지는 <strong>희소 그래프(Sparse Graph)</strong> 의 경우</li>
<li>장점
<ul>
<li>어떤 노드에 <strong>인접한 노드들</strong> 을 쉽게 찾을 수 있다.</li>
<li>그래프에 존재하는 <strong>모든 간선의 수</strong> 는 O(N+E) 안에 알 수 있다.: 인접 리스트 전체를 조사한다.</li>
</ul>
</li>
<li>단점
<ul>
<li>간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수만큼의 시간이 필요</li>
</ul>
</li>
</ul>
</li>
<li>인접 행렬
<ul>
<li>그래프에 간선이 많이 존재하는 <strong>밀집 그래프(Dense Graph)</strong> 의 경우</li>
<li>장점
<ul>
<li>두 정점을 연결하는 <strong>간선의 존재 여부</strong> (M[i][j])를 O(1) 안에 즉시 알 수 있다.</li>
<li><strong>정점의 차수</strong> 는 O(N) 안에 알 수 있다.: 인접 배열의 i번 째 행 또는 열을 모두 더한다.</li>
</ul>
</li>
<li>단점
<ul>
<li>어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.</li>
<li>그래프에 존재하는 모든 간선의 수는 O(N^2) 안에 알 수 있다.: 인접 행렬 전체를 조사한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
        <img src="/08.media/20240428022603.png" alt="Pasted image 20240428022603 (Image resource not found)" ></p>
<p>
        <img src="/08.media/20240428022602.png" alt="Pasted image 20240428022602 (Image resource not found)" ></p>
<blockquote>
<p>밀집 그래프(dense graph)는 간선의 수가 최대 간선의 수에 가까운 그래프이다. 그와 반대로, <strong>간선이 얼마 없는 그래프</strong>는 희소 그래프(sparse graph)라고 한다.</p>
</blockquote>
<h3 id="그래프graph의-탐색">그래프(Graph)의 탐색</h3>
<p>일반적인 방법 두 가지:<br>
<strong><a href="https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html" class="external-link" target="_blank" rel="noopener noreferrer" >깊이 우선 탐색(Depth-First Search)</a></strong> 과 <strong><a href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" class="external-link" target="_blank" rel="noopener noreferrer" >너비 우선 탐색(Breadth-First Search)</a></strong></p>
<p>루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법</p>
<ul>
<li>즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다.</li>
<li>사용하는 경우: <strong>모든 노드를 방문</strong> 하고자 하는 경우에 이 방법을 선택한다.
<ul>
<li>깊이 우선 탐색이 너비 우선 탐색보다 좀 더 간단하다.</li>
</ul>
</li>
</ul>
<p>루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법</p>
<ul>
<li>즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.</li>
<li>사용하는 경우: <strong>두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때</strong> 이 방법을 선택한다.
<ul>
<li>Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우</li>
<li>깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야 할지도 모른다.</li>
<li>너비 우선 탐색의 경우 - Ash와 가까운 관계부터 탐색</li>
</ul>
</li>
</ul>
<hr>
<h3 id="알고리즘에서-그래프">알고리즘에서 그래프</h3>
<p>알고리즘 코딩테스트에서는 다양한 그래프 알고리즘과 그래프 기반의 문제들이 출제될 수 있습니다. 주요한 그래프 알고리즘과 문제 유형은 다음과 같습니다:</p>
<dl>
<dt><code>깊이 우선 탐색 (Depth-First Search, DFS)</code></dt>
<dd>그래프의 모든 노드를 탐색하고, 각 노드를 방문한 순서를 기록하는 알고리즘입니다. 주로 그래프 탐색, 사이클 판별, 연결 요소 확인 등에 사용됩니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/43165" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>너비 우선 탐색 (Breadth-First Search, BFS)</code></dt>
<dd>루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/43163" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>다익스트라 알고리즘 (Dijkstra's Algorithm)</code></dt>
<dd>가중치 그래프에서 시작 노드로부터 모든 다른 노드까지의 최단 경로를 찾는 알고리즘입니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/12978" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>벨만-포드 알고리즘 (Bellman-Ford Algorithm)</code></dt>
<dd>가중치 그래프에서 시작 노드로부터 모든 다른 노드까지의 최단 경로를 찾는 알고리즘입니다. 음수 가중치를 가진 간선이 있는 경우에도 동작합니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/12978" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>크루스칼 알고리즘 (Kruskal's Algorithm)</code></dt>
<dd>가중치 그래프에서 최소 신장 트리를 찾는 알고리즘입니다. 모든 간선을 가중치 순으로 정렬한 뒤, 사이클을 형성하지 않는 간선을 추가하여 트리를 형성합니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/42861" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>프림 알고리즘 (Prim's Algorithm)</code></dt>
<dd>가중치 그래프에서 최소 신장 트리를 찾는 알고리즘입니다. 시작 노드에서부터 출발하여, 현재 트리와 연결되지 않은 노드 중 최소 가중치의 간선을 선택하여 트리를 확장합니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/42861" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>위상 정렬 (Topological Sorting)</code></dt>
<dd>방향 그래프에서 노드들을 선형적으로 정렬하는 알고리즘입니다. 선행 관계가 있는 작업의 우선 순위를 결정하는 데 사용됩니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/49191" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
<dt><code>최소 공통 조상 (Lowest Common Ancestor, LCA)</code></dt>
<dd>트리에서 두 노드의 가장 가까운 공통 조상을 찾는 알고리즘입니다. 주로 트리 구조를 활용한 문제에서 사용됩니다.<br>
<a href="https://school.programmers.co.kr/learn/courses/30/lessons/43165" class="external-link" target="_blank" rel="noopener noreferrer" >문제 풀어보기</a></dd>
</dl>
<p>이 외에도 그래프 기반의 다양한 문제 유형이 있을 수 있으며, 각 문제에 맞는 적절한 알고리즘을 선택하여 문제를 해결하는 것이 중요합니다.</p>
<hr>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
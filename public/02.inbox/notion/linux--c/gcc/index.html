<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>gcc | My Test Site</title>
    

    
    
    <meta name="description" content="GCC(GNU Compiler Collection)는 C 컴파일러입니다. C언어를 컴퓨터가 읽을 수 있도록 번역해야 하는데 리눅스에서는 Visual Studio C&#43;&#43;과 같이 윈도우에서 쓰이는 프로그램이 사용 불가합니다. 그래서 리눅스용의 대표 C컴파일러가 GCC인 것 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/02.inbox/notion/linux--c/gcc/">

    
    
    
    <meta property="og:title" content="gcc">
    <meta property="og:description" content="GCC(GNU Compiler Collection)는 C 컴파일러입니다. C언어를 컴퓨터가 읽을 수 있도록 번역해야 하는데 리눅스에서는 Visual Studio C&#43;&#43;과 같이 윈도우에서 쓰이는 프로그램이 사용 불가합니다. 그래서 리눅스용의 대표 C컴파일러가 GCC인 것 …">
    <meta property="og:url" content="http://localhost:1313/02.inbox/notion/linux--c/gcc/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="gcc">
    <meta name="twitter:description" content="GCC(GNU Compiler Collection)는 C 컴파일러입니다. C언어를 컴퓨터가 읽을 수 있도록 번역해야 하는데 리눅스에서는 Visual Studio C&#43;&#43;과 같이 윈도우에서 쓰이는 프로그램이 사용 불가합니다. 그래서 리눅스용의 대표 C컴파일러가 GCC인 것 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>gcc **page.html**</h1>
    <p>GCC(GNU Compiler Collection)는 C 컴파일러입니다. C언어를 컴퓨터가 읽을 수 있도록 번역해야 하는데 리눅스에서는 Visual Studio C++과 같이 윈도우에서 쓰이는 프로그램이 사용 불가합니다. 그래서 리눅스용의 대표 C컴파일러가 GCC인 것입니다.</p>
<p>C 파일을 컴파일 할 경우의 단계는 아래와 같습니다.</p>
<p>![](<a href="https://blog.kakaocdn.net/dn/x8xPL/btq0HabcJAh/n5rCuGjzpUtynbDi3n00m0/img.png]%28https://blog.kakaocdn.net/dn/x8xPL/btq0HabcJAh/n5rCuGjzpUtynbDi3n00m0/img.png%29" class="external-link" target="_blank" rel="noopener noreferrer" >https://blog.kakaocdn.net/dn/x8xPL/btq0HabcJAh/n5rCuGjzpUtynbDi3n00m0/img.png](https://blog.kakaocdn.net/dn/x8xPL/btq0HabcJAh/n5rCuGjzpUtynbDi3n00m0/img.png)</a></p>
<p><strong>전처리 단계</strong> : c 파일을 gcc 컴파일러로 컴파일 할 경우 전처리 단계가 진행되는데 결과로 i 파일을 만들어냅니다.</p>
<p>이 단계에서는 헤더파일을 포함하고 매크로 확장을 합니다.</p>
<p>#include &lt;stdio.h&gt; 와 같은 헤더파일 처리</p>
<p>#define HUNDRED = 100 과 같은 매크로 처리</p>
<p>gcc는 cpp라는 전처리기를 사용하는데</p>
<p><strong>gcc -E hello.c -o hello.i</strong></p>
<p>를 입력하면 전처리 단계 까지만 진행되어 hello.i 파일이 생성됩니다.</p>
<p><strong>컴파일 단계</strong> : 전처리된 파일로 컴파일을 진행하여 어셈블리어로 된 파일인 s 파일을 생성합니다. cll 을 사용합니다.</p>
<p><strong>gcc -S hello.c</strong></p>
<p>를 입력하면 hello.s 파일이 생성됩니다.</p>
<p><a href="https://blog.kakaocdn.net/dn/b0NjMT/btq1pz2N6Pn/WJLO8wtNHvxKz93vg9AlR0/img.png" class="external-link" target="_blank" rel="noopener noreferrer" >
    <img src="https://blog.kakaocdn.net/dn/b0NjMT/btq1pz2N6Pn/WJLO8wtNHvxKz93vg9AlR0/img.png" alt="" ></a></p>
<p>hello.s 파일(어셈블리 코드)</p>
<p><strong>어셈블 단계</strong> : 어셈블리어로 쓰여진 s 파일을 컴퓨터가 이해할 수 있는 기계어로 된 파일인 o 파일로 변환합니다. gcc는 as라는 어셈블러를 사용합니다.</p>
<p><strong>gcc -c hello.c</strong></p>
<p>이 명령어의 결과로 바이너리 파일인 hello.o(object 파일)을 얻을 수 있습니다.</p>
<p><strong>링크 단계</strong> : 라이브러리 함수와 여러 오브젝트 파일들을 연결해서 실행 파일인 a.out을 생성합니다.</p>
<p><strong>gcc hello.c -o hello</strong></p>
<p>결과물은 코드와 데이터를 포함하는 실행 가능한 바이너리 파일인 hello.exe입니다.</p>
<p>아무리 간단한 C 프로그램이라고 해도 단계를 세분화 해서 보면 바로 실행 파일이 생성되는 것이 아니고 이와 같은 절차를 거칩니다.</p>
<p>임베디드 프로그래밍을 할 때 c 파일 뿐만 아니라 여러 가지 파일이 나오는데 잘 인식GCC(GNU Compiler Collection)는 C 컴파일러입니다. C언어를 컴퓨터가 읽을 수 있도록 번역해야 하는데 리눅스에서는 Visual Studio C++과 같이 윈도우에서 쓰이는 프로그램이 사용 불가합니다. 그래서 리눅스용의 대표 C컴파일러가 GCC인 것입니다.</p>
<p>C 파일을 컴파일 할 경우의 단계를 요약하면 아래와 같습니다.</p>
<p><a href="https://blog.kakaocdn.net/dn/eu1UH7/btq1qOk8XgQ/TeDREHIi6PjCq7umCjp3EK/img.png" class="external-link" target="_blank" rel="noopener noreferrer" >
    <img src="https://blog.kakaocdn.net/dn/eu1UH7/btq1qOk8XgQ/TeDREHIi6PjCq7umCjp3EK/img.png" alt="" ></a></p>
<p>전처리 단계 : c 파일을 gcc 컴파일러로 컴파일 할 경우 전처리 단계가 진행되는데 결과로 i 파일을 만들어냅니다.</p>
<p>컴파일 단계 : 전처리된 파일로 어셈블리어로 된 파일인 s 파일을 생성합니다.</p>
<p>어셈블 단계 : 어셈블리어로 쓰여진 s 파일을 컴퓨터가 이해할 수 있는 기계어로 된 파일인 o 파일로 변환합니다.</p>
<p>링크 단계 : 라이브러리 함수와 여러 오브젝트 파일들을 연결해서 실행 파일인 a.out을 생성합니다.</p>
<p>아무리 간단한 C 프로그램이라고 해도 단계를 세분화 해서 보면 바로 실행 파일이 생성되는 것이 아니고 이와 같은 절차를 거칩니다.</p>
<p>임베디드 프로그래밍을 할 때 c 파일 뿐만 아니라 여러 가지 파일이 나오는데 당황하지 않을 수 있겠죠~</p>
<p>GCC와 연결해서 동작 할 수 있도록 해보겠습니다.</p>
<ul>
<li>
<p>E Preprocess only; do not compile, assemble or link.<br>
-S Compile only; do not assemble or link.<br>
-c Compile and assemble, but do not link.<br>
-o <file> Place the output into <file>.<br>
-pie Create a dynamically linked position independent<br>
executable.</p>
</li>
<li>
<p>출력 종류 제어: 실행 파일, 객체 파일, 어셈블러 파일 또는 사전 처리된 소스를 생성합니다.</p>
</li>
<li>
<p>C 언어 방언 제어: 컴파일할 C 언어의 표준이나 변형을 지정합니다.</p>
</li>
<li>
<p>경고 옵션: 컴파일러가 얼마나 까다롭게 경고 메시지를 출력할지 결정합니다.</p>
</li>
<li>
<p>디버깅 옵션: 디버깅을 위한 정보를 코드에 삽입하거나 제거합니다.</p>
</li>
<li>
<p>최적화 옵션: 코드의 실행 속도나 크기를 최적화하는 방법을 선택합니다.</p>
</li>
<li>
<p>전처리기 옵션: 헤더 파일이나 매크로 정의를 제어하거나 종속성 정보를 생성합니다.</p>
</li>
<li>
<p>어셈블러 옵션: 어셈블러에게 전달할 옵션을 지정합니다.</p>
</li>
<li>
<p>링크 옵션: 라이브러리나 링커 스크립트를 지정하거나 링크 과정을 제어합니다.</p>
</li>
<li>
<p>디렉토리 옵션: 헤더 파일이나 라이브러리, 컴파일러 실행 파일을 찾을 수 있는 디렉토리를 추가하거나 변경합니다.</p>
</li>
<li>
<p>코드 생성 옵션: 함수 호출, 데이터 레이아웃, 레지스터 사용법 등과 관련된 규칙을 지정합니다.</p>
</li>
<li>
<p>개발자 옵션: GCC 구성 정보, 통계, 디버깅 덤프 등을 출력하거나 검사합니다.</p>
</li>
<li>
<p>하위 모델 옵션: 특정 프로세서 변형이나 타겟 아키텍처에 대한 컴파일을 수행합니다.</p>
</li>
</ul>
<p>전처리 단계 <strong>gcc -E hello.c -o hello.i</strong></p>
<p>컴파일 단계 <strong>gcc -S hello.c</strong></p>
<p>어셈블 단계 <strong>gcc -c hello.c</strong></p>
<p>링크 단계 <strong>gcc hello.c -o hello</strong></p>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
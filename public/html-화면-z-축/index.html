<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>html 화면 z 축 | My Test Site</title>
    

    
    
    <meta name="description" content="✦ 네, 더 자세히 설명해 드리겠습니다. 이 현상은 웹 브라우저가 요소를 화면에 그리는 방식, 특히 **스태킹 컨텍스트(Stacking Context)**와 z-index라는 개념 때문에 발생합니다. 그리고 검색 결과가 가리지 않는 이유는 검색창과 검색 결과 항목의 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/html-%ED%99%94%EB%A9%B4-z-%EC%B6%95/">

    
    
    
    <meta property="og:title" content="html 화면 z 축">
    <meta property="og:description" content="✦ 네, 더 자세히 설명해 드리겠습니다. 이 현상은 웹 브라우저가 요소를 화면에 그리는 방식, 특히 **스태킹 컨텍스트(Stacking Context)**와 z-index라는 개념 때문에 발생합니다. 그리고 검색 결과가 가리지 않는 이유는 검색창과 검색 결과 항목의 …">
    <meta property="og:url" content="http://localhost:1313/html-%ED%99%94%EB%A9%B4-z-%EC%B6%95/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="html 화면 z 축">
    <meta name="twitter:description" content="✦ 네, 더 자세히 설명해 드리겠습니다. 이 현상은 웹 브라우저가 요소를 화면에 그리는 방식, 특히 **스태킹 컨텍스트(Stacking Context)**와 z-index라는 개념 때문에 발생합니다. 그리고 검색 결과가 가리지 않는 이유는 검색창과 검색 결과 항목의 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>html 화면 z 축 **page.html**</h1>
    <p>✦ 네, 더 자세히 설명해 드리겠습니다. 이 현상은 웹 브라우저가 요소를 화면에 그리는 방식, 특히 **스태킹 컨텍스트(Stacking Context)**와 <code>z-index</code>라는 개념 때문에 발생합니다. 그리고 검색 결과가 가리지 않는 이유는 검색창과 검색 결과 항목의 CSS <code>position</code> 속성 차이 때문입니다.</p>
<hr>
<h3 id="현상이-발생하는-원리---왜-검색창만-가리는가">현상이 발생하는 원리 - 왜 검색창만 가리는가?</h3>
<p>웹 페이지의 요소들은 단순히 2차원 평면에 있는 것이 아니라, 3차원 공간처럼 서로 겹쳐질 수 있는 &lsquo;레이어(layer)&rsquo; 구조를 가집니다. 어떤 요소가 다른 요소의 위나 아래에 그려질지 결정하는 규칙이 바로 &lsquo;스태킹(쌓임) 순서&rsquo;입니다.</p>
<ol>
<li>
<p><strong>기본 쌓임 순서</strong>: 기본적으로 HTML 코드에서 나중에 나오는 요소가 먼저 나온 요소보다 위에 쌓입니다.</p>
</li>
<li>
<p><strong>스태킹 컨텍스트의 형성</strong>: 특정 CSS 속성은 요소와 그 자식들을 위한 &lsquo;독립된 레이어 그룹&rsquo;을 만드는데, 이를 스태킹 컨텍스트라고 합니다.</p>
<ul>
<li>대표적으로 <code>position</code> 속성이 <code>relative</code>, <code>absolute</code>, <code>fixed</code>, <code>sticky</code>이면서 <code>z-index</code>가 <code>auto</code>가 아닌 값을 가질 때 (또는 <code>z-index</code>가 없더라도 특정 조건에서), 또는 <code>opacity</code>가 1 미만일 때 등이 스태킹 컨텍스트를 형성합니다.</li>
<li><strong>중요한 점은 <code>position: relative</code>만으로도 <code>z-index</code> 없이 스태킹 컨텍스트를 형성할 수 있으며, 이는 때때로 예상치 못한 쌓임 순서를 야기할 수 있다는 것입니다.</strong></li>
</ul>
</li>
<li>
<p><strong>현재 문제 상황 분석</strong>:</p>
<ul>
<li>
<p><strong>탭 바 (<code>&lt;nav&gt;</code> 또는 <code>div</code>):</strong> <code>position: sticky</code> 속성을 가지고 있습니다. 이 속성은 스크롤될 때 화면 특정 위치에 &lsquo;달라붙게&rsquo; 만듭니다. 하지만 <code>z-index</code> 값이 명시적으로 지정되지 않았습니다. <code>sticky</code> 요소는 스태킹 컨텍스트를 형성하지만, <code>z-index: auto</code>일 경우, 다른 요소들과의 쌓임 순서가 모호해질 수 있습니다. 특히 아래 설명할 <code>position: relative</code> 요소와 만났을 때 브라우저 렌더링 엔진이 헷갈리는 경우가 발생합니다.</p>
</li>
<li>
<p><strong>검색창 (<code>&lt;input&gt;</code>):</strong> <code>.src/js/ui/search-ui.js</code>에서 생성되는 검색창은 다음과 같은 구조를 가집니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mb-4&#34;</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;relative&#34;</span>&gt;  <span style="color:#75715e">&lt;!-- ★★★ 바로 이 부분입니다! position: relative이 적용됨 ★★★ --&gt;</span>
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;searchInput&#34;</span> <span style="color:#960050;background-color:#1e0010">...</span>&gt;
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">div</span>&gt;
</span></span></code></pre></div><p><code>class=&quot;relative&quot;</code>는 해당 <code>div</code>에 <code>position: relative;</code> 속성을 적용합니다. 이 <code>position: relative</code> 속성은 <code>z-index</code>가 명시되지 않더라도 <strong>새로운 스태킹 컨텍스트를 형성</strong>합니다.</p>
</li>
<li>
<p><strong>검색 결과 (<code>&lt;div&gt;</code>):</strong> 검색 결과 항목들은 <code>position</code> 속성이 명시적으로 지정되어 있지 않습니다. 즉, 기본값인 <code>position: static</code>을 가집니다. <code>static</code> 요소는 새로운 스태킹 컨텍스트를 형성하지 않으며, 일반적인 문서 흐름과 쌓임 순서를 따릅니다.</p>
</li>
</ul>
</li>
<li>
<p><strong>겹침 발생 원인 (검색창만 해당):</strong></p>
<ul>
<li>사이드바 내부에서 스크롤이 발생하면, &lsquo;스크롤되는 콘텐츠&rsquo; 영역(검색창 포함)과 &lsquo;상단에 고정된&rsquo; 영역(탭 바)이 겹치게 됩니다.</li>
<li>이때, <code>z-index</code>가 없는 <code>position: sticky</code> 탭 바와 <code>z-index</code>가 없는 <code>position: relative</code> 검색창 컨테이너가 만나게 됩니다. 이 두 요소 모두 스태킹 컨텍스트를 형성하지만, 어느 쪽이 더 높은지 명확한 우선순위가 없습니다.</li>
<li><strong>이러한 모호한 상황에서 브라우저의 렌더링 엔진은 <code>position: relative</code>를 가진 요소를 (비록 <code>z-index</code>가 <code>auto</code>여도) <code>position: sticky</code>만 있는 요소보다 더 &lsquo;앞으로&rsquo; 가져오려는 경향이 있습니다.</strong> 따라서 스크롤되어 움직이는 검색창이 sticky로 고정만 되어있는 탭 바보다 높은 레이어로 판단되어 위로 올라타는 현상이 발생하는 것입니다.</li>
<li><strong>검색 결과는 <code>position: static</code>이므로 스태킹 컨텍스트를 형성하지 않고, 일반적인 문서 흐름에 따라 <code>sticky</code> 요소의 아래로 자연스럽게 지나갑니다. 그래서 검색 결과는 탭 바를 가리지 않는 것입니다.</strong></li>
</ul>
</li>
</ol>
<p>쉽게 비유하자면, 투명한 필름(요소) 여러 장을 겹쳐 놓았는데, 각 필름의 상하 관계(<code>z-index</code>)를 명확히 지정해주지 않은 상황과 같습니다. 특히, &lsquo;강력한 접착제&rsquo;(<code>position: relative</code> 또는 <code>absolute</code> 같은 속성)를 사용한 필름이 &lsquo;약한 접착제&rsquo;(<code>position: sticky</code>만 있는 경우)를 사용한 필름보다 더 튀어나와 보이는 경향이 있는 것입니다.</p>
<hr>
<h3 id="코드를-변경하면-해결되는-원리">코드를 변경하면 해결되는 원리</h3>
<p>제안 드린 해결책은 탭 바의 쌓임 순서를 <strong>가장 명확하고 강력하게</strong> 지정하는 것입니다.</p>
<ol>
<li>
<p><strong><code>z-10</code> 클래스 추가</strong>: <code>index.html</code>의 <code>sticky</code> 속성을 가진 탭 바 <code>div</code>에 <code>z-10</code> 클래스를 추가하면, 이 요소에는 <code>z-index: 10;</code>이라는 CSS 속성이 적용됩니다.</p>
</li>
<li>
<p><strong>명시적인 스태킹 컨텍스트 형성</strong>: <code>position: sticky</code>와 <code>z-index: 10</code>이 함께 적용되면서, 탭 바는 &lsquo;레벨 10&rsquo;의 <strong>가장 확실하고 강력한 독립된 스태킹 컨텍스트</strong>를 형성합니다.</p>
</li>
<li>
<p><strong>쌓임 순서 정리</strong>:</p>
<ul>
<li><strong>탭 바</strong>: 이제 &lsquo;레벨 10&rsquo;에 위치하게 됩니다.</li>
<li><strong>검색창 컨테이너</strong>: <code>position: relative</code>로 스태킹 컨텍스트를 형성하지만, <code>z-index</code>가 명시되지 않았으므로 &lsquo;레벨 0&rsquo; (기본 레벨)에 머무릅니다. 브라우저의 기본 규칙에 따라 <code>z-index: auto</code>는 명시된 <code>z-index</code> 값보다 낮은 것으로 간주됩니다.</li>
<li><strong>검색 결과</strong>: <code>position: static</code>이므로 스태킹 컨텍스트를 형성하지 않으며, <code>z-index</code>는 적용되지 않습니다. &lsquo;레벨 0&rsquo;보다도 더 기본층에 속합니다.</li>
</ul>
</li>
<li>
<p><strong>결과</strong>: 이제 브라우저는 명확한 지시를 받았습니다. 스크롤이 일어나 검색창이나 검색 결과가 탭 바 위치로 올라오더라도, &lsquo;레벨 0&rsquo; 이하에 있는 검색창과 검색 결과는 &lsquo;레벨 10&rsquo;에 있는 탭 바의 아래를 지나가게 됩니다. 따라서 더 이상 탭 바를 덮는 현상이 발생하지 않습니다.</p>
</li>
</ol>
<hr>
<p><strong>결론적으로, <code>z-index</code>를 추가하는 것은 &ldquo;이 탭 바는 다른 어떤 요소보다 항상 위에 있어야 해!&ldquo;라고 브라우저에게 명확하게 알려주는 행위이며, 이를 통해 <code>position</code> 속성으로 인해 발생할 수 있는 모든 모호했던 요소 간의 상하 관계를 가장 확실하게 바로잡는 것입니다.</strong> <code>position: relative</code>가 적용된 검색창뿐만 아니라, 향후 다른 <code>position</code> 속성을 가진 요소들이 추가되더라도 탭 바는 항상 최상단에 유지될 것입니다.</p>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
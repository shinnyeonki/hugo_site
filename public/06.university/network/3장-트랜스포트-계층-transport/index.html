<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>3장 트랜스포트 계층 (transport) | My Test Site</title>
    

    
    
    <meta name="description" content="packet 이름 : segment
udp 의 패킷을 특수하게 네트워크 계층에서 사용하는 패킷의 이름인 datagram 이라는 이름을 사용할 때도 있다
개괄 udp, tcp 공통 기능
프로세스대 프로세드 데이터 전달(multiplexing, demultiplexing) …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/06.university/network/3%EC%9E%A5-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%AC%ED%8A%B8-%EA%B3%84%EC%B8%B5-transport/">

    
    
    
    <meta property="og:title" content="3장 트랜스포트 계층 (transport)">
    <meta property="og:description" content="packet 이름 : segment
udp 의 패킷을 특수하게 네트워크 계층에서 사용하는 패킷의 이름인 datagram 이라는 이름을 사용할 때도 있다
개괄 udp, tcp 공통 기능
프로세스대 프로세드 데이터 전달(multiplexing, demultiplexing) …">
    <meta property="og:url" content="http://localhost:1313/06.university/network/3%EC%9E%A5-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%AC%ED%8A%B8-%EA%B3%84%EC%B8%B5-transport/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="3장 트랜스포트 계층 (transport)">
    <meta name="twitter:description" content="packet 이름 : segment
udp 의 패킷을 특수하게 네트워크 계층에서 사용하는 패킷의 이름인 datagram 이라는 이름을 사용할 때도 있다
개괄 udp, tcp 공통 기능
프로세스대 프로세드 데이터 전달(multiplexing, demultiplexing) …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>3장 트랜스포트 계층 (transport) **page.html**</h1>
    <p>packet 이름 : segment</p>
<blockquote>
<p>udp 의 패킷을 특수하게 네트워크 계층에서 사용하는 패킷의 이름인 datagram 이라는 이름을 사용할 때도 있다</p>
</blockquote>
<h3 id="개괄">개괄</h3>
<p><strong>udp, tcp 공통 기능</strong></p>
<ul>
<li>프로세스대 프로세드 데이터 전달(multiplexing, demultiplexing)</li>
<li>오류 검출(check sum)</li>
</ul>
<p><strong>tcp 특수 기능</strong></p>
<ul>
<li>신뢰적인 데이터 전송
<ul>
<li>흐름제어</li>
<li>순서번호</li>
<li>확인응답</li>
<li>타이머</li>
</ul>
</li>
<li>혼잡제어</li>
</ul>
<h3 id="프로세스대-프로세드-데이터">프로세스대 프로세드 데이터</h3>
<p>
        <img src="/08.media/20250408120817.png" alt=" (Image resource not found)" >
트랜스포트 계층 다중화, 역 다중화 : 호스트대 호스트 전달을 프로세스대 프로세스 전달로 확장하는 과정</p>
<p>네트워크 소켓의 식별자 포멧</p>
<ul>
<li>transport -&gt; socket (-&gt; application(process)) : depmultiplexing 적절한 소켓으로 데이터를 전송 : 분리하는 과정</li>
<li>socket -&gt; transport (-&gt; network) : multiplexing 소켓으로 부터 받은 데이터를 패킷화(segment) 해서 아래 계층으로 보낸다</li>
</ul>
<p>udp 식별자</p>
<ul>
<li>source port</li>
<li>destination port</li>
</ul>
<blockquote>
<p>상황 : udp 소켓 <code>19157</code>을 가진 호스트 A 의 프로세스가 호스트 B 의 UDP 소켓 <code>46428</code>을 가진 프로세스에게 애플리케이션 데이터 전송을 원한다고 가정하자.</p>
</blockquote>
<blockquote>
<p>호스트 A 의 트랜스포트 계층은 애츨리케이션 데이터, 출발지 포트 번호(19157), 목적지 포트번호(46428), 그리고 2개의 다른값 #ModificationRequired 을 포함하는 트랜스포트계층 세그먼트를 생성한다. <br>
트랜스포트 계층은 만들어진 세그먼트를 네트워크 계층으로 전달한다.
네트워크 계층은 세그먼트를 IP 데이터그램으로 캡술화하고 best-effort 서비스로 수신 호스트로 전달한다.
&hellip; 이동중 &hellip;
수신호스트에서 네트워크 계층에서 받은 segment는  트랜스포트계층에서 목적지 포트번호 46428을 검사하고 그 세그먼트를 포트 46428로 식별되는 소켓에 전달한다</p>
</blockquote>
<ul>
<li>호스트 A의 소켓: <code>(A의 IP 주소, 19157)</code></li>
<li>호스트 B의 소켓: <code>(B의 IP 주소, 46428)</code></li>
</ul>
<h3 id="checksum">checksum</h3>
<p>헤더의 checksum 필드는은 16비트로 이루어져있음</p>
<p>송신자는 data의 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행해서 checksum 에 넣는다
합산시에는 윤회식 합산(wrap around)를 수행한다</p>
<p>수신자는 data의 모든 16비트 워드합산과 checksum 을 합치면 1111111111111111 이 나오면 오류가 없다고 판단한다(0이 한개라도 있으면 오류가 발생했다고 판단한다)</p>
<h3 id="신뢰적인-data전송">신뢰적인 data전송</h3>
<h4 id="rdt-10">rdt 1.0</h4>
<blockquote>
<p>완벽하게 신뢰적인 채널 상에서의 데이터 전송</p>
</blockquote>
<ul>
<li>비트오류 없음</li>
<li>패킷로스가 없음</li>
</ul>
<p>
        <img src="/08.media/20250410015692.png" alt="Pasted image 20250410015692 (Image resource not found)" ></p>
<h4 id="rdt-20-전송-후-대기-stop-and-wait">rdt 2.0 (전송 후 대기 stop-and-wait)</h4>
<blockquote>
<p>비트 오류가 있는 채널상에서의 신뢰적인 데이터 전송</p>
</blockquote>
<ul>
<li>패킷로스가 없음</li>
</ul>
<p>필요기능</p>
<ul>
<li>오류검출</li>
<li>수신자 피드백</li>
<li>재전송</li>
</ul>
<p>
        <img src="/08.media/20250410020249.png" alt="Pasted image 20250410020249 (Image resource not found)" >
긍정확인응답(ACK), 부정확인응답(NAK)</p>
<p>만약 ack, nak 응답자체가 훼손되었을 경우는 어떻게 하는가?</p>
<h5 id="rdt-21">rdt 2.1</h5>
<ul>
<li>체크섬(checksum) 비트를 충분히 추가하여 송신자가 수신된 패킷의 오류를 검출할 뿐만 아니라, 오류를 직접 수정할 수 있도록 합니다.</li>
<li>송신자는 ack, nak 를 받지 않는 모든 패킷을 재전송 한다 <strong>중복 패킷 처리 문제</strong> 수신자는 ACK 또는 NAK가중복된 데이터 패킷이 도착할 가능성이 있습니다.</li>
</ul>
<p>데이터 패킷에 새로운 필드를 추가하고 필드안에 순서번호(sequence number)를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙이는 것이다
1개의 비트 즉 2개의 상태번호만 있으면 된다</p>
<p>
        <img src="/08.media/20250410022180.png" alt="Pasted image 20250410022180 (Image resource not found)" >

        <img src="/08.media/20250410052285.png" alt="Pasted image 20250410052285 (Image resource not found)" ></p>
<p>2.0 상태에서 2배 크기의 fsm 이다 sequence number 개수로 인해</p>
<p>nak 대신 이전패킷의 비정상 수신의 ack 를 보내도 되지 않을까?
nak 대신 last recived ok</p>
<h4 id="rdt-22">rdt 2.2</h4>
<p>ack 자체에 순서번호(sequence number)를 포함해서 보내도록 하고 nak 는 필요없다<br>

        <img src="/08.media/20250410052788.png" alt="Pasted image 20250410052788 (Image resource not found)" >

        <img src="/08.media/20250410052896.png" alt="Pasted image 20250410052896 (Image resource not found)" ></p>
<h3 id="rdt30-alternating-bit-protocol">rdt3.0 (alternating-bit protocol)</h3>
<blockquote>
<p>비트 오류와 패킷로스가 있는 채널상에서의 신뢰적인 데이터 전송</p>
</blockquote>
<p>
        <img src="/08.media/20250410055361.png" alt="Pasted image 20250410055361 (Image resource not found)" ></p>
<p>rdt3.0 송신자 측에서 (오류 발생이나 이전 패킷에) 대한 ack 가 발생하면 바로 재전송하지 않고   timeout 까지 기다리고 그렇게 하는 이유가 2번 연속으로 보내는 경우가 발생할 수 있다 인데 이것의 예시가 떠오르지 않아 질문드립니다</p>
<h3 id="pipelining">pipelining</h3>
<p>필요기능 :<br>
sequence number 의 범위가 커져야 한다<br>
프로토콜의 송신측과 수신측은 패킷 1개 이상을 버퍼링 해야 한다</p>
<p><strong>L (Packet Size)</strong> : 패킷의 크기(packet size)<br>
<strong>R (Transmission Rate)</strong> : 송신 속도 (1Gbps)<br>
<strong>RTT (Round-Trip Time)</strong> : 데이터 패킷이 발신자에서 수신자로 전달된 후, ACK가 다시 발신자에게 돌아오는 데 걸리는 전체 왕복 시간</p>
<h4 id="gbn-go-back-n">GBN (go back N)</h4>
<p><strong>특정 조건에서 송신자가 이미 전송한 여러 패킷(N개)을 다시 전송해야 하는 특징</strong>

        <img src="/08.media/20250410085576.png" alt="Pasted image 20250410085576 (Image resource not found)" ></p>
<h4 id="selective-repeat-sr">Selective Repeat (SR)</h4>
<p><strong>손실된 패킷만 재전송하는 특징</strong></p>
<h3 id="-1-gbn-vs-sr-개요-요약">🔄 <strong>1. GBN vs SR: 개요 요약</strong></h3>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Go-Back-N (GBN)</th>
          <th>Selective Repeat (SR)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>ACK 방식</strong></td>
          <td>누적적 ACK (Cumulative ACK)</td>
          <td>개별 ACK</td>
      </tr>
      <tr>
          <td><strong>패킷 재전송</strong></td>
          <td>타임아웃된 패킷부터 window 내 모든 패킷 재전송</td>
          <td>오직 손실/에러 난 패킷만 재전송</td>
      </tr>
      <tr>
          <td><strong>Receiver 버퍼링</strong></td>
          <td>불필요 (out-of-order 패킷 모두 폐기)</td>
          <td>필요 (out-of-order 패킷 저장 후 순서 정렬)</td>
      </tr>
      <tr>
          <td><strong>Window 크기 제한</strong></td>
          <td>N (window size)</td>
          <td>최대 2^k-1 / 2 (sequence number space 절반)</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="-2-시나리오-설정-공통">🧱 <strong>2. 시나리오 설정 (공통)</strong></h4>
<ul>
<li><strong>최대 SEQ 번호</strong>: 7 (즉, k=3 bits)</li>
<li><strong>Window Size (N)</strong>: 4</li>
<li><strong>전송해야 할 패킷</strong>: pkt0, pkt1, pkt2, pkt3, pkt4, pkt5</li>
<li><strong>pkt2 유실</strong></li>
<li><strong>ACK 수신 순서</strong>: ACK0, ACK1, ACK2 지연됨 → timeout 발생</li>
</ul>
<hr>
<h4 id="-3-go-back-n-gbn-시뮬레이션">🟩 <strong>3. Go-Back-N (GBN) 시뮬레이션</strong></h4>
<h6 id="-sender-측">✅ <strong>Sender 측</strong></h6>
<table>
  <thead>
      <tr>
          <th>Event</th>
          <th>Window (base ~ nextseqnum - 1)</th>
          <th>Sent Packets</th>
          <th>Status</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>초기 상태</td>
          <td>[0, 0]</td>
          <td>없음</td>
          <td>대기</td>
          <td>base = 0, nextseqnum = 0</td>
      </tr>
      <tr>
          <td>rdt_send(data0)</td>
          <td>[0, 0] → [0, 0]</td>
          <td>pkt0 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 1</td>
      </tr>
      <tr>
          <td>rdt_send(data1)</td>
          <td>[0, 1]</td>
          <td>pkt1 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 2</td>
      </tr>
      <tr>
          <td>rdt_send(data2)</td>
          <td>[0, 2]</td>
          <td>pkt2 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 3</td>
      </tr>
      <tr>
          <td>rdt_send(data3)</td>
          <td>[0, 3]</td>
          <td>pkt3 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 4</td>
      </tr>
      <tr>
          <td>ACK0 수신</td>
          <td>[1, 3]</td>
          <td>-</td>
          <td>base = 1</td>
          <td>타이머 재시작</td>
      </tr>
      <tr>
          <td>ACK1 수신</td>
          <td>[2, 3]</td>
          <td>-</td>
          <td>base = 2</td>
          <td>타이머 재시작</td>
      </tr>
      <tr>
          <td>Timeout (pkt2 미수신)</td>
          <td>[2, 3]</td>
          <td>pkt2~pkt3 재전송</td>
          <td>재전송</td>
          <td>타이머 리셋</td>
      </tr>
      <tr>
          <td>ACK2 수신</td>
          <td>[3, 3]</td>
          <td>-</td>
          <td>base = 3</td>
          <td>타이머 중지</td>
      </tr>
      <tr>
          <td>ACK3 수신</td>
          <td>[4, 3] → [4, 4]</td>
          <td>-</td>
          <td>base = 4</td>
          <td>다음 패킷 보낼 수 있음</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>🔁 <strong>GBN 특징</strong>: 누적 ACK를 기준으로 window sliding하며, 한번 유실되면 window 내 모든 패킷 재전송.</p>
</blockquote>
<hr>
<h6 id="-receiver-측">❌ <strong>Receiver 측</strong></h6>
<table>
  <thead>
      <tr>
          <th>수신 패킷</th>
          <th>expectedseqnum</th>
          <th>결과</th>
          <th>ACK 전송</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>pkt0</td>
          <td>0</td>
          <td>in-order</td>
          <td>ACK0</td>
      </tr>
      <tr>
          <td>pkt1</td>
          <td>1</td>
          <td>in-order</td>
          <td>ACK1</td>
      </tr>
      <tr>
          <td>pkt3</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK1 재전송</td>
      </tr>
      <tr>
          <td>pkt4</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK1 재전송</td>
      </tr>
      <tr>
          <td>pkt5</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK1 재전송</td>
      </tr>
      <tr>
          <td>pkt2</td>
          <td>2</td>
          <td>in-order (마침내)</td>
          <td>ACK2 전송</td>
      </tr>
      <tr>
          <td>pkt3</td>
          <td>3</td>
          <td>in-order</td>
          <td>ACK3 전송</td>
      </tr>
      <tr>
          <td>pkt4</td>
          <td>4</td>
          <td>in-order</td>
          <td>ACK4 전송</td>
      </tr>
      <tr>
          <td>pkt5</td>
          <td>5</td>
          <td>in-order</td>
          <td>ACK5 전송</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>⚠️ <strong>GBN Receiver</strong>: 잘못된 순서의 패킷은 무시하고 마지막으로 받은 in-order 패킷에 대한 ACK 계속 송신.</p>
</blockquote>
<hr>
<h4 id="-4-selective-repeat-sr-시뮬레이션">🟦 <strong>4. Selective Repeat (SR) 시뮬레이션</strong></h4>
<h5 id="-sender-측-1">✅ <strong>Sender 측</strong></h5>
<table>
  <thead>
      <tr>
          <th>Event</th>
          <th>Window (base ~ nextseqnum - 1)</th>
          <th>Sent Packets</th>
          <th>Status</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>초기 상태</td>
          <td>[0, 0]</td>
          <td>없음</td>
          <td>대기</td>
          <td>base = 0, nextseqnum = 0</td>
      </tr>
      <tr>
          <td>rdt_send(data0)</td>
          <td>[0, 0] → [0, 0]</td>
          <td>pkt0 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 1</td>
      </tr>
      <tr>
          <td>rdt_send(data1)</td>
          <td>[0, 1]</td>
          <td>pkt1 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 2</td>
      </tr>
      <tr>
          <td>rdt_send(data2)</td>
          <td>[0, 2]</td>
          <td>pkt2 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 3</td>
      </tr>
      <tr>
          <td>rdt_send(data3)</td>
          <td>[0, 3]</td>
          <td>pkt3 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 4</td>
      </tr>
      <tr>
          <td>ACK0 수신</td>
          <td>[1, 3]</td>
          <td>-</td>
          <td>base = 1</td>
          <td>타이머 재시작</td>
      </tr>
      <tr>
          <td>ACK1 수신</td>
          <td>[2, 3]</td>
          <td>-</td>
          <td>base = 2</td>
          <td>타이머 재시작</td>
      </tr>
      <tr>
          <td>ACK3 수신</td>
          <td>[2, 3]</td>
          <td>-</td>
          <td>아직 base = 2</td>
          <td>pkt2는 미수신</td>
      </tr>
      <tr>
          <td>Timeout (pkt2)</td>
          <td>[2, 3]</td>
          <td>pkt2 재전송</td>
          <td>only pkt2 재전송</td>
          <td>타이머 리셋</td>
      </tr>
      <tr>
          <td>ACK2 수신</td>
          <td>[3, 3]</td>
          <td>-</td>
          <td>base = 3</td>
          <td>모든 ack 받음</td>
      </tr>
      <tr>
          <td>rdt_send(data4)</td>
          <td>[3, 4]</td>
          <td>pkt4 보냄</td>
          <td>전송</td>
          <td>nextseqnum = 5</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>📦 <strong>SR 특징</strong>: 누적 ACK 아님 → 각각의 패킷에 대해 독립적으로 확인 가능. loss가 하나뿐이라면 그 하나만 재전송.</p>
</blockquote>
<hr>
<h5 id="-receiver-측-1">✅ <strong>Receiver 측</strong></h5>
<table>
  <thead>
      <tr>
          <th>수신 패킷</th>
          <th>expectedseqnum</th>
          <th>결과</th>
          <th>ACK 전송</th>
          <th>버퍼 내용</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>pkt0</td>
          <td>0</td>
          <td>in-order</td>
          <td>ACK0</td>
          <td>-</td>
      </tr>
      <tr>
          <td>pkt1</td>
          <td>1</td>
          <td>in-order</td>
          <td>ACK1</td>
          <td>-</td>
      </tr>
      <tr>
          <td>pkt3</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK3</td>
          <td>pkt3 save</td>
      </tr>
      <tr>
          <td>pkt4</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK4</td>
          <td>pkt4 save</td>
      </tr>
      <tr>
          <td>pkt5</td>
          <td>2</td>
          <td>out-of-order</td>
          <td>ACK5</td>
          <td>pkt5 save</td>
      </tr>
      <tr>
          <td>pkt2</td>
          <td>2</td>
          <td>in-order</td>
          <td>ACK2</td>
          <td>pkt3, pkt4, pkt5 deliver 가능</td>
      </tr>
      <tr>
          <td>(after ACK2)</td>
          <td>6</td>
          <td>-</td>
          <td>-</td>
          <td>buffer empty</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>💡 <strong>SR Receiver</strong>: out-of-order 패킷을 버퍼링하여 순서 복구 후 일괄 전달 (in-order delivery)</p>
</blockquote>
<hr>
<h4 id="-5-주요-비교-요약">📊 <strong>5. 주요 비교 요약</strong></h4>
<table>
  <thead>
      <tr>
          <th>항목</th>
          <th>Go-Back-N</th>
          <th>Selective Repeat</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>ACK 종류</strong></td>
          <td>누적 ACK</td>
          <td>개별 ACK</td>
      </tr>
      <tr>
          <td><strong>재전송 범위</strong></td>
          <td>window 내 전체</td>
          <td>손실된 패킷만</td>
      </tr>
      <tr>
          <td><strong>Receiver 버퍼</strong></td>
          <td>필요 없음</td>
          <td>필요함</td>
      </tr>
      <tr>
          <td><strong>채널 효율성</strong></td>
          <td>packet error 많으면 낮음</td>
          <td>packet error 많아도 높음</td>
      </tr>
      <tr>
          <td><strong>복잡도</strong></td>
          <td>낮음</td>
          <td>높음</td>
      </tr>
      <tr>
          <td><strong>사용 예</strong></td>
          <td>UDP 기반 간단한 RDT</td>
          <td>TCP (유사 구조)</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="-결론">🧾 <strong>결론</strong></h4>
<ul>
<li><strong>GBN</strong>은 <strong>간단하지만 비효율적</strong>입니다. 하나의 패킷 유실 시 window 내 모든 패킷을 다시 보내야 해서 네트워크 과부하를 유발할 수 있습니다.</li>
<li><strong>SR</strong>은 <strong>더 복잡하지만 효율적</strong>입니다. 손실된 패킷만 재전송하고, receiver 측에서 out-of-order 패킷을 적절히 버퍼링하여 순서 정렬 후 전달합니다.</li>
</ul>
<h3 id="rtt">RTT</h3>
<p>Sample RTT 대략적인 RTT</p>
<h4 id="rtt-문제">RTT 문제</h4>
<p>아래는 **Exponential Weighted Moving Average (EWMA)**와 관련된 TCP의 Round-Trip Time (RTT) 추정 및 Timeout Interval 계산을 다루는 문제 3개입니다. 각 문제는 초기값과 샘플 데이터를 제공하며, 여러분이 주어진 공식을 적용하여 값을 계산하도록 설계되었습니다.</p>
<hr>
<h5 id="문제-1-estimatedrtt-계산"><strong>문제 1: EstimatedRTT 계산</strong></h5>
<p><strong>주어진 정보:</strong></p>
<ul>
<li>초기 EstimatedRTT = 100ms</li>
<li>α (가중치 계수) = 0.125 (즉, ( $\alpha = 1/8$ ))</li>
<li>SampleRTT 값:
<ul>
<li>첫 번째 SampleRTT = 120ms</li>
<li>두 번째 SampleRTT = 90ms</li>
<li>세 번째 SampleRTT = 110ms</li>
</ul>
</li>
</ul>
<p><strong>질문:</strong></p>
<ol>
<li>첫 번째 SampleRTT를 기반으로 업데이트된 EstimatedRTT를 계산하세요.</li>
<li>두 번째 SampleRTT를 기반으로 다시 업데이트된 EstimatedRTT를 계산하세요.</li>
<li>세 번째 SampleRTT를 기반으로 최종 EstimatedRTT를 계산하세요.</li>
</ol>
<hr>
<h5 id="문제-2-devrtt-rtt-변동성-계산"><strong>문제 2: DevRTT (RTT 변동성) 계산</strong></h5>
<p><strong>주어진 정보:</strong></p>
<ul>
<li>초기 DevRTT = 0ms</li>
<li>β (가중치 계수) = 0.25</li>
<li>위에서 계산한 EstimatedRTT 값들:
<ul>
<li>첫 번째 EstimatedRTT = 101.25ms</li>
<li>두 번째 EstimatedRTT = 100.625ms</li>
<li>세 번째 EstimatedRTT = 101.094ms</li>
</ul>
</li>
<li>SampleRTT 값:
<ul>
<li>첫 번째 SampleRTT = 120ms</li>
<li>두 번째 SampleRTT = 90ms</li>
<li>세 번째 SampleRTT = 110ms</li>
</ul>
</li>
</ul>
<p><strong>질문:</strong></p>
<ol>
<li>첫 번째 SampleRTT를 기반으로 업데이트된 DevRTT를 계산하세요.</li>
<li>두 번째 SampleRTT를 기반으로 다시 업데이트된 DevRTT를 계산하세요.</li>
<li>세 번째 SampleRTT를 기반으로 최종 DevRTT를 계산하세요.</li>
</ol>
<hr>
<h5 id="문제-3-timeoutinterval-계산"><strong>문제 3: TimeoutInterval 계산</strong></h5>
<p><strong>주어진 정보:</strong></p>
<ul>
<li>위에서 계산한 최종 EstimatedRTT = 101.094ms</li>
<li>위에서 계산한 최종 DevRTT = 2.34375ms</li>
<li>TimeoutInterval 공식:
$\text{TimeoutInterval} = \text{EstimatedRTT} + 4 \cdot \text{DevRTT}$</li>
</ul>
<p><strong>질문:</strong></p>
<ol>
<li>최종 TimeoutInterval을 계산하세요.</li>
<li>만약 Timeout이 발생했다면, TimeoutInterval은 어떻게 업데이트되나요? (초기 TimeoutInterval = 1초)</li>
<li>Timeout 이후에 새로운 SampleRTT = 105ms가 측정되었고, EstimatedRTT와 DevRTT가 업데이트되었다고 가정할 때, TimeoutInterval을 재계산하세요.</li>
</ol>
<hr>
<h5 id="풀이-방법-안내"><strong>풀이 방법 안내</strong></h5>
<ol>
<li><strong>EstimatedRTT 계산</strong>: 아래 공식을 사용합니다.
$\text{EstimatedRTT} = (1 - \alpha) \cdot \text{EstimatedRTT} + \alpha \cdot \text{SampleRTT}$</li>
<li><strong>DevRTT 계산</strong>: 아래 공식을 사용합니다.
$\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot |\text{SampleRTT} - \text{EstimatedRTT}|$</li>
<li><strong>TimeoutInterval 계산</strong>: 아래 공식을 사용합니다.
$\text{TimeoutInterval} = \text{EstimatedRTT} + 4 \cdot \text{DevRTT}$</li>
</ol>
<hr>
<h5 id="힌트"><strong>힌트</strong></h5>
<ul>
<li>계산 과정에서 소수점 처리를 정확히 해야 합니다.</li>
<li>TimeoutInterval이 두 배로 증가하는 경우는 Timeout이 발생했을 때만 해당됩니다.</li>
<li>모든 계산은 단계별로 진행하고, 중간 결과를 기록하세요.</li>
</ul>
<hr>
<h5 id="예상-답안-형식"><strong>예상 답안 형식</strong></h5>
<h6 id="문제-1-예시-답안"><strong>문제 1 예시 답안:</strong></h6>
<ol>
<li>첫 번째 EstimatedRTT:
$\text{EstimatedRTT} = 0.875 \cdot 100 + 0.125 \cdot 120 = 101.25 , \text{ms}$</li>
<li>두 번째 EstimatedRTT:
$\text{EstimatedRTT} = 0.875 \cdot 101.25 + 0.125 \cdot 90 = 100.625 , \text{ms}$</li>
<li>세 번째 EstimatedRTT:
$\text{EstimatedRTT} = 0.875 \cdot 100.625 + 0.125 \cdot 110 = 101.094 , \text{ms}$</li>
</ol>
<h6 id="문제-2-예시-답안"><strong>문제 2 예시 답안:</strong></h6>
<ol>
<li>첫 번째 DevRTT:
$\text{DevRTT} = 0.75 \cdot 0 + 0.25 \cdot |120 - 101.25| = 2.5 , \text{ms}$</li>
<li>두 번째 DevRTT:
$\text{DevRTT} = 0.75 \cdot 2.5 + 0.25 \cdot |90 - 100.625| = 2.1875 , \text{ms}$</li>
<li>세 번째 DevRTT:
$\text{DevRTT} = 0.75 \cdot 2.1875 + 0.25 \cdot |110 - 101.094| = 2.34375 , \text{ms}$</li>
</ol>
<h6 id="문제-3-예시-답안"><strong>문제 3 예시 답안:</strong></h6>
<ol>
<li>최종 TimeoutInterval:
$\text{TimeoutInterval} = 101.094 + 4 \cdot 2.34375 = 110.5875 , \text{ms}$</li>
<li>Timeout 발생 시:
$\text{TimeoutInterval} = 2 \cdot 110.5875 = 221.175 , \text{ms}$</li>
<li>Timeout 이후 재계산:
(새로운 EstimatedRTT와 DevRTT를 기반으로 다시 계산)</li>
</ol>
<hr>
<p>이 문제들은 EWMA와 TCP 타임아웃 메커니즘을 이해하고 실제 계산 능력을 테스트하기 위해 설계되었습니다. 문제를 풀면서 주어진 공식을 잘 적용해 보세요! 😊</p>
<h3 id="tcp">TCP</h3>
<h4 id="tcp의-기본-동작-원리">TCP의 기본 동작 원리**</h4>
<p>TCP는 세 가지 주요 이벤트를 처리하며, 각 이벤트에 따라 특정 작업을 수행합니다:</p>
<h5 id="1-애플리케이션으로부터-데이터-수신"><strong>(1) 애플리케이션으로부터 데이터 수신</strong></h5>
<ul>
<li>TCP는 애플리케이션 계층으로부터 데이터를 받아 이를 TCP 세그먼트로 캡슐화합니다.</li>
<li>각 세그먼트에는 시퀀스 번호(sequence number)가 포함됩니다. 이는 세그먼트 내 첫 바이트의 바이트 스트림 번호를 나타냅니다.</li>
<li>타이머가 이미 실행 중이 아니라면, 세그먼트를 IP 계층으로 전달할 때 타이머를 시작합니다.</li>
</ul>
<h5 id="2-타임아웃-발생"><strong>(2) 타임아웃 발생</strong></h5>
<ul>
<li>타임아웃이 발생하면, TCP는 해당 세그먼트를 재전송합니다.</li>
<li>이후 타이머를 다시 시작합니다.</li>
</ul>
<h5 id="3-ackacknowledgment-수신"><strong>(3) ACK(Acknowledgment) 수신</strong></h5>
<ul>
<li>수신자로부터 ACK가 도착하면, TCP는 ACK 필드 값 <code>y</code>와 <code>SendBase</code>를 비교합니다.
<ul>
<li><code>SendBase</code>: 가장 오래된 미확인 바이트의 시퀀스 번호.</li>
<li><code>y &gt; SendBase</code>라면, 하나 이상의 세그먼트가 성공적으로 전달되었음을 의미합니다.</li>
<li>TCP는 <code>SendBase</code>를 업데이트하고, 아직 확인되지 않은 세그먼트가 남아 있다면 타이머를 다시 시작합니다.</li>
</ul>
</li>
</ul>
<h4 id="tcp의-신뢰성-보장-메커니즘"><strong>TCP의 신뢰성 보장 메커니즘</strong></h4>
<p>TCP는 데이터 전송의 신뢰성을 보장하기 위해 다양한 기법을 사용합니다. 이 과정에서 TCP는 **Go-Back-N(GBN)**과 <strong>Selective Repeat(SR)</strong> 프로토콜의 특징을 혼합한 하이브리드 방식으로 동작합니다. 이를 아래와 같이 상세히 설명하겠습니다.</p>
<hr>
<h5 id="1-타임아웃-및-재전송"><strong>(1) 타임아웃 및 재전송</strong></h5>
<ul>
<li>TCP는 각 세그먼트에 대해 <strong>타임아웃 간격(<code>TimeoutInterval</code>)</strong> 을 설정합니다.
<ul>
<li><code>TimeoutInterval</code>은 <code>EstimatedRTT</code>(예상 왕복 시간)과 <code>DevRTT</code>(왕복 시간 편차)를 기반으로 계산됩니다.</li>
<li>만약 특정 세그먼트에 대한 ACK가 타임아웃 내에 도착하지 않으면, 해당 세그먼트를 <strong>재전송</strong>합니다.</li>
<li><strong>지수 백오프 알고리즘</strong>: 타임아웃이 발생할 때마다 다음 타임아웃 간격은 이전 값의 두 배로 설정됩니다. 예를 들어, 초기 타임아웃 간격이 0.75초라면, 첫 번째 재전송 후에는 1.5초, 두 번째 재전송 후에는 3.0초로 증가합니다. 이는 네트워크 혼잡 상태를 완화하기 위한 제한된 형태의 혼잡 제어입니다.</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-누적-ackcumulative-acknowledgment"><strong>(2) 누적 ACK(Cumulative Acknowledgment)</strong></h5>
<ul>
<li>TCP는 기본적으로 <strong>누적 ACK 방식</strong>을 사용하여 수신자가 받은 데이터를 확인합니다.
<ul>
<li>예: 수신자가 <code>ACK = y</code>를 보내면, 이는 &ldquo;바이트 번호 <code>y</code> 이전의 모든 데이터가 성공적으로 수신되었음&quot;을 의미합니다.</li>
<li>이를 통해 송신자는 손실된 세그먼트를 빠르게 감지하고 재전송할 수 있습니다.</li>
<li><strong>하이브리드 특징</strong>: 일부 TCP 구현은 순서가 맞지 않는(out-of-order) 세그먼트를 버퍼링하며, 선택적 ACK(SACK, Selective Acknowledgment) [RFC 2018]를 사용하여 특정 세그먼트를 개별적으로 ACK할 수 있습니다. 이를 통해 SR 스타일의 선택적 재전송이 가능해집니다.</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-단일-타이머-관리"><strong>(3) 단일 타이머 관리</strong></h5>
<ul>
<li>효율성을 위해 TCP는 <strong>단일 타이머</strong>만 사용합니다.
<ul>
<li>이 타이머는 가장 오래된 미확인 세그먼트와 연결됩니다.</li>
<li>새로운 ACK가 도착하거나 타임아웃이 발생하면 타이머를 조정합니다.</li>
<li><strong>Fast Retransmit</strong>: 타임아웃을 기다리지 않고도 중복 ACK(duplicate ACK)를 활용하여 손실된 세그먼트를 빠르게 재전송할 수 있습니다. 예를 들어, 동일한 ACK가 3번 이상 도착하면 송신자는 해당 세그먼트가 손실되었음을 판단하고 즉시 재전송합니다.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="tcp는-gbn인가-sr인가"><strong>TCP는 GBN인가, SR인가?</strong></h4>
<p>TCP의 에러 복구 메커니즘은 <strong>GBN</strong>과 <strong>SR</strong>의 혼합형이라고 할 수 있습니다. 이를 구체적으로 살펴보겠습니다:</p>
<h5 id="1-gbn과-유사한-특징"><strong>(1) GBN과 유사한 특징</strong></h5>
<ul>
<li>TCP는 누적 ACK를 사용하며, 중간에 손실된 세그먼트가 있더라도 이후 세그먼트를 개별적으로 ACK하지 않습니다.</li>
<li>TCP 송신자는 가장 오래된 미확인 바이트(<code>SendBase</code>)와 다음에 보낼 바이트(<code>NextSeqNum</code>)만 추적합니다. 이는 GBN의 특징과 유사합니다.</li>
</ul>
<h5 id="2-sr과-유사한-특징"><strong>(2) SR과 유사한 특징</strong></h5>
<ul>
<li>일부 TCP 구현은 순서가 맞지 않는 세그먼트를 버퍼링합니다. 이는 SR의 핵심 특징 중 하나입니다.</li>
<li>예를 들어, 송신자가 세그먼트 1, 2, &hellip;, N을 전송했고, 세그먼트 n의 ACK가 손실되었지만 나머지 ACK가 타임아웃 전에 도착했다고 가정합니다. 이 경우:
<ul>
<li>GBN은 세그먼트 n부터 모든 세그먼트(n, n+1, &hellip;, N)를 재전송합니다.</li>
<li>TCP는 최대 한 개의 세그먼트(n)만 재전송하며, 세그먼트 n+1의 ACK가 타임아웃 전에 도착했다면 세그먼트 n조차 재전송하지 않을 수 있습니다.</li>
</ul>
</li>
</ul>
<h5 id="3-선택적-acksack"><strong>(3) 선택적 ACK(SACK)</strong></h5>
<ul>
<li>선택적 ACK(SACK)를 사용하면 수신자가 특정 세그먼트를 개별적으로 ACK할 수 있습니다.</li>
<li>이를 통해 송신자는 이미 수신된 세그먼트를 재전송하지 않으며, SR 스타일의 선택적 재전송이 가능해집니다.</li>
</ul>
<hr>
<h4 id="결론"><strong>결론</strong></h4>
<p>TCP의 에러 복구 메커니즘은 기본적으로 <strong>GBN 스타일</strong>로 동작하지만, <strong>SACK</strong>와 <strong>Fast Retransmit</strong>을 통해 <strong>SR 스타일</strong>의 기능을 추가로 제공합니다. 따라서 TCP는 <strong>GBN과 SR의 하이브리드 모델</strong>로 분류됩니다.</p>
<p><strong>핵심 요약</strong>:</p>
<ul>
<li>기본적으로 GBN과 유사: 누적 ACK, 단일 타이머 사용.</li>
<li>선택적 ACK(SACK)와 Fast Retransmit을 통해 SR의 장점을 통합.</li>
<li>결과적으로 TCP는 GBN과 SR의 장점을 결합한 유연한 프로토콜입니다.</li>
<li></li>
</ul>
<h3 id="3way-handshake-vs-2way-handshake">3way handshake vs 2way handshake</h3>
<p>2-Way Handshake의 문제를 설명한 내용을 다시 정리하고, 핵심적인 문제점과 그로 인해 발생하는 상황을 상세히 설명하겠습니다.</p>
<hr>
<h4 id="2-way-handshake의-동작-방식"><strong>2-Way Handshake의 동작 방식</strong></h4>
<p>2-Way Handshake는 연결 설정을 위해 두 번의 메시지 교환만으로 완료됩니다:</p>
<ol>
<li>클라이언트 → 서버: SYN(연결 요청)</li>
<li>서버 → 클라이언트: ACK(연결 수락)</li>
</ol>
<p>이 과정에서 서버는 클라이언트의 연결 요청(SYN)을 받고, 즉시 연결이 확립되었다고 간주합니다. 하지만 이 방식은 신뢰성 있는 연결 설정을 보장하지 못하며, 특히 네트워크 지연이나 중복 패킷(Duplicate Packet)로 인해 문제가 발생할 수 있습니다.</p>
<hr>
<h4 id="문제-발생-시나리오"><strong>문제 발생 시나리오</strong></h4>
<h5 id="시나리오-old-duplicate-syn-패킷"><strong>시나리오: Old Duplicate SYN 패킷</strong></h5>
<ol>
<li>
<p><strong>클라이언트가 서버에 연결 요청(SYN)을 보냄</strong></p>
<ul>
<li>클라이언트는 서버와의 연결을 위해 SYN 패킷을 전송합니다.</li>
<li>그러나 이 패킷은 네트워크 지연 또는 손실로 인해 서버에 도착하지 않거나, 재전송되며 지연됩니다.</li>
</ul>
</li>
<li>
<p><strong>서버가 SYN 패킷을 수신하고 연결 수락(ACK)</strong></p>
<ul>
<li>서버는 클라이언트의 SYN 패킷을 수신하고, 연결 요청을 수락하기 위해 ACK 패킷을 클라이언트에게 전송합니다.</li>
<li>이로써 서버는 연결이 성공적으로 확립되었다고 판단합니다.</li>
</ul>
</li>
<li>
<p><strong>클라이언트와 서버가 데이터를 주고받으며 연결 종료</strong></p>
<ul>
<li>클라이언트와 서버는 데이터 통신을 완료하고 연결을 종료합니다.</li>
<li>클라이언트는 더 이상 해당 연결을 사용하지 않습니다.</li>
</ul>
</li>
<li>
<p><strong>지연된 SYN 패킷이 서버에 도착</strong></p>
<ul>
<li>초기에 전송되었던 SYN 패킷이 네트워크 지연으로 인해 이제야 서버에 도착합니다.</li>
<li>서버는 이 패킷을 새로운 연결 요청으로 오인합니다.</li>
</ul>
</li>
<li>
<p><strong>서버가 잘못된 연결 상태를 유지</strong></p>
<ul>
<li>서버는 지연된 SYN 패킷에 대해 ACK를 전송하며, 새로운 연결이 확립되었다고 판단합니다.</li>
<li>하지만 실제로 클라이언트는 이미 연결을 종료했으므로, 서버는 &ldquo;상대방이 없는 커넥션&quot;을 유지하게 됩니다.</li>
</ul>
</li>
</ol>
<hr>
<h4 id="발생하는-문제"><strong>발생하는 문제</strong></h4>
<h5 id="1-하프-오픈half-open-상태"><strong>1. 하프 오픈(Half-Open) 상태</strong></h5>
<ul>
<li>서버는 연결이 활성화된 상태로 판단하고 리소스를 할당하지만, 클라이언트는 이미 연결을 종료한 상태입니다.</li>
<li>이로 인해 서버는 불필요한 자원을 낭비하며, &ldquo;하프 오픈&rdquo; 상태의 커넥션을 유지하게 됩니다.</li>
</ul>
<h5 id="2-데이터-송수신-실패"><strong>2. 데이터 송수신 실패</strong></h5>
<ul>
<li>서버는 클라이언트로부터 추가 데이터를 기다리지만, 클라이언트는 이미 연결을 종료했으므로 데이터를 보내지 않습니다.</li>
<li>결과적으로 서버는 데이터를 받지 못하고, 결국 타임아웃(Time-out) 후 연결을 강제로 종료해야 합니다.</li>
</ul>
<h5 id="3-재전송retransmission-문제"><strong>3. 재전송(Retransmission) 문제</strong></h5>
<ul>
<li>클라이언트는 초기 SYN 패킷이 서버에 도착하지 않았다고 판단하여 재전송을 시도할 수 있습니다.</li>
<li>이러한 재전송된 SYN 패킷이 서버에 도착하면, 서버는 이를 또 다른 새로운 연결 요청으로 오인할 가능성이 큽니다.</li>
<li>이로 인해 서버는 여러 개의 유효하지 않은 연결을 생성하며, 자원을 더욱 낭비하게 됩니다.</li>
</ul>
<hr>
<h4 id="왜-이런-문제가-발생할까"><strong>왜 이런 문제가 발생할까?</strong></h4>
<p>2-Way Handshake는 단순히 &ldquo;요청 → 응답&quot;의 구조로 동작하기 때문에, 연결 요청이 실제로 현재 유효한 요청인지 확인할 방법이 없습니다.<br>
특히 <strong>네트워크 지연</strong>이나 <strong>중복 패킷</strong>이 존재할 경우, 다음과 같은 이유로 문제가 발생합니다:</p>
<ol>
<li><strong>Old Duplicate Packet 처리 불가능:</strong> 2-Way Handshake는 지연된 패킷을 구분할 방법이 없어, 이를 새로운 연결 요청으로 오인합니다.</li>
<li><strong>상태 동기화 부족:</strong> 클라이언트와 서버 간의 연결 상태가 완벽히 동기화되지 않아, 한쪽이 연결을 종료한 상태에서도 다른 쪽이 연결이 활성화된 것으로 판단할 수 있습니다.</li>
</ol>
<hr>
<h4 id="해결책-3-way-handshake"><strong>해결책: 3-Way Handshake</strong></h4>
<p>3-Way Handshake는 2-Way Handshake의 문제를 해결하기 위해 추가적인 단계를 포함합니다:</p>
<ol>
<li><strong>클라이언트 → 서버: SYN(연결 요청)</strong></li>
<li><strong>서버 → 클라이언트: SYN+ACK(연결 수락 및 확인 요청)</strong></li>
<li><strong>클라이언트 → 서버: ACK(최종 확인)</strong></li>
</ol>
<p>이 과정에서 클라이언트와 서버는 서로의 상태를 명확히 동기화하며, 다음과 같은 장점을 제공합니다:</p>
<ol>
<li><strong>Old Duplicate Packet 무시:</strong> 지연된 SYN 패킷이 도착해도, 최종 ACK 단계가 없으면 연결이 확립되지 않습니다.</li>
<li><strong>상태 동기화 보장:</strong> 클라이언트와 서버가 모두 연결 확립을 확인하므로, 하프 오픈 상태를 방지합니다.</li>
<li><strong>신뢰성 있는 연결 설정:</strong> 재전송된 패킷을 유효하게 처리하거나 무시할 수 있어, 혼란을 줄입니다.</li>
</ol>
<hr>
<h4 id="결론-1"><strong>결론</strong></h4>
<p>2-Way Handshake는 간단하지만, 네트워크 지연 또는 중복 패킷으로 인해 문제가 발생할 수 있습니다. 특히, 하프 오픈 상태와 재전송 문제로 인해 서버 자원이 낭비되고, 데이터 송수신 실패 등의 문제가 생길 수 있습니다.<br>
따라서 TCP에서는 <strong>3-Way Handshake</strong>를 통해 신뢰성 있는 연결 설정을 보장하며, 이러한 문제를 효과적으로 해결합니다.</p>
<h3 id="tcp-flow-control-and-congestion-control">TCP flow control and congestion control</h3>
<ul>
<li>목적1 : 혼잡제어</li>
<li></li>
</ul>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
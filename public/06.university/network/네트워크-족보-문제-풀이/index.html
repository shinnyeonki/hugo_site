<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>네트워크 족보 문제 풀이 | My Test Site</title>
    

    
    
    <meta name="description" content="네트워크 라우터의 패킷 서비스 순서 문제 패킷 크기는 모두 동일하며, 다음 순서로 도착하여 큐에 이미 들어가 있다고 가정합니다:
P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12
각 패킷은 아래와 같이 클래스(Class) 별로 분 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/06.university/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A1%B1%EB%B3%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">

    
    
    
    <meta property="og:title" content="네트워크 족보 문제 풀이">
    <meta property="og:description" content="네트워크 라우터의 패킷 서비스 순서 문제 패킷 크기는 모두 동일하며, 다음 순서로 도착하여 큐에 이미 들어가 있다고 가정합니다:
P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12
각 패킷은 아래와 같이 클래스(Class) 별로 분 …">
    <meta property="og:url" content="http://localhost:1313/06.university/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A1%B1%EB%B3%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="네트워크 족보 문제 풀이">
    <meta name="twitter:description" content="네트워크 라우터의 패킷 서비스 순서 문제 패킷 크기는 모두 동일하며, 다음 순서로 도착하여 큐에 이미 들어가 있다고 가정합니다:
P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12
각 패킷은 아래와 같이 클래스(Class) 별로 분 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>네트워크 족보 문제 풀이 **page.html**</h1>
    <h1 id="네트워크-라우터의-패킷-서비스-순서-문제">네트워크 라우터의 패킷 서비스 순서 문제</h1>
<p>패킷 크기는 모두 동일하며, 다음 순서로 도착하여 큐에 이미 들어가 있다고 가정합니다:<br>
<strong>P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12</strong></p>
<p>각 패킷은 아래와 같이 <strong>클래스(Class)</strong> 별로 분류되어 있습니다:</p>
<ul>
<li><strong>Class 1</strong>: P2, P4, P7, P12</li>
<li><strong>Class 2</strong>: P3, P5, P10</li>
<li><strong>Class 3</strong>: P1, P6, P8, P9, P11</li>
</ul>
<h2 id="5-round-robin-scheduling-5점">5. Round Robin Scheduling (5점)</h2>
<ul>
<li>서비스는 <strong>Class 3 큐부터 시작</strong>됩니다.</li>
<li>각 클래스 내부에서는 <strong>패킷 번호 순서대로</strong> 서비스가 진행됩니다.</li>
</ul>
<h3 id="요구사항">요구사항:</h3>
<p>Round Robin 스케줄링 방식에 따라 패킷이 <strong>실제로 서비스되는 순서를 기술하시오</strong>.</p>
<h2 id="6-weighted-fair-queueing-wfq-scheduling-5점">6. Weighted Fair Queueing (WFQ) Scheduling (5점)</h2>
<ul>
<li>각 클래스의 가중치:
<ul>
<li>Class 1: 3</li>
<li>Class 2: 2</li>
<li>Class 3: 4</li>
</ul>
</li>
<li><strong>패킷 전송 시간은 동일</strong>하다고 가정합니다.</li>
<li><strong>가중치 계산 결과가 동일한 경우</strong>, <strong>번호가 작은 패킷이 우선</strong>으로 서비스됩니다.</li>
</ul>
<h3 id="요구사항-1">요구사항:</h3>
<p>WFQ 스케줄링 방식에 따라 패킷이 <strong>실제로 서비스되는 순서를 기술하시오</strong>.</p>
<p>각 스케줄링 기법에 따른 패킷 서비스 순서는 다음과 같습니다.</p>
<hr>
<h2 id="5-라운드-로빈round-robin-스케줄링">5. 라운드 로빈(Round Robin) 스케줄링</h2>
<p>서비스 순서: <strong>P1, P2, P3, P6, P4, P5, P8, P7, P10, P9, P12, P11</strong></p>
<h4 id="설명">설명</h4>
<p>라운드 로빈 스케줄링은 각 클래스 큐를 순서대로 돌아가며 공평하게 한 번씩 서비스하는 방식입니다. 문제의 조건에 따라 Class 3부터 시작하여 Class 1, Class 2 순서(3 → 1 → 2)로 순환하며 각 큐의 첫 번째 패킷을 서비스합니다.</p>
<ul>
<li><strong>1차 순환:</strong> Class 3의 <strong>P1</strong>, Class 1의 <strong>P2</strong>, Class 2의 <strong>P3</strong></li>
<li><strong>2차 순환:</strong> Class 3의 <strong>P6</strong>, Class 1의 <strong>P4</strong>, Class 2의 <strong>P5</strong></li>
<li><strong>3차 순환:</strong> Class 3의 <strong>P8</strong>, Class 1의 <strong>P7</strong>, Class 2의 <strong>P10</strong> (이후 Class 2는 비어있음)</li>
<li><strong>4차 순환:</strong> Class 3의 <strong>P9</strong>, Class 1의 <strong>P12</strong> (이후 Class 1은 비어있음)</li>
<li><strong>5차 순환:</strong> Class 3에 남은 <strong>P11</strong>을 서비스합니다.</li>
</ul>
<hr>
<h2 id="6-wfqweighted-fair-queueing-스케줄링">6. WFQ(Weighted Fair Queueing) 스케줄링</h2>
<p>서비스 순서: <strong>P1, P2, P3, P6, P4, P8, P5, P7, P9, P11, P12, P10</strong></p>
<h4 id="설명-1">설명</h4>
<p>WFQ 스케줄링은 가중치를 기반으로 각 패킷의 가상 종료 시간(Virtual Finish Time)을 계산하고, 이 값이 가장 작은 패킷을 우선적으로 서비스합니다. 가상 종료 시간은 <strong><code>이전 패킷의 종료 시간 + (패킷 전송 시간 / 가중치)</code></strong> 공식으로 계산됩니다. 모든 패킷의 크기가 동일하므로 &lsquo;패킷 전송 시간&rsquo;을 임의의 값(예: 12)으로 가정하여 계산할 수 있습니다.</p>
<ul>
<li><strong>주어진 가중치:</strong> Class 1 = 3, Class 2 = 2, Class 3 = 4</li>
</ul>
<ol>
<li>
<p><strong>시작:</strong> 각 큐의 첫 패킷(P1, P2, P3)의 가상 종료 시간을 계산합니다.</p>
<ul>
<li>P1(C3, w=4): <code>12 / 4 = 3</code></li>
<li>P2(C1, w=3): <code>12 / 3 = 4</code></li>
<li>P3(C2, w=2): <code>12 / 2 = 6</code></li>
<li>➡️ <strong>P1</strong> 선택 (값이 가장 작음)</li>
</ul>
</li>
<li>
<p><strong>다음:</strong> P1이 서비스된 Class 3의 다음 패킷(P6)의 가상 종료 시간을 계산합니다.</p>
<ul>
<li>P6(C3): <code>3 (P1의 값) + 12 / 4 = 6</code></li>
<li>P2(C1): <code>4</code></li>
<li>P3(C2): <code>6</code></li>
<li>➡️ <strong>P2</strong> 선택</li>
</ul>
</li>
<li>
<p><strong>다음:</strong> P2가 서비스된 Class 1의 다음 패킷(P4)을 계산합니다.</p>
<ul>
<li>P4(C1): <code>4 (P2의 값) + 12 / 3 = 8</code></li>
<li>P6(C3): <code>6</code></li>
<li>P3(C2): <code>6</code></li>
<li>➡️ P3와 P6의 값이 같으므로 패킷 번호가 낮은 <strong>P3</strong> 선택</li>
</ul>
</li>
</ol>
<p>이와 같은 방식으로 모든 패킷의 가상 종료 시간을 순차적으로 계산하고 비교하여 전체 서비스 순서를 결정합니다.</p>
<h1 id="네트워크-최단-경로-문제">네트워크 최단 경로 문제</h1>
<h2 id="네트워크-정보">네트워크 정보</h2>
<p>주어진 간선(링크)와 비용(Cost):</p>
<ul>
<li><code>ut</code> : 5</li>
<li><code>uv</code> : 6</li>
<li><code>ux</code> : 2</li>
<li><code>tw</code> : 2</li>
<li><code>vx</code> : 2</li>
<li><code>xw</code> : 2</li>
<li><code>xw</code> : 4 <em>(중복된 링크, 동일 노드 간 두 개의 연결 존재)</em></li>
<li><code>xy</code> : 3</li>
<li><code>xz</code> : 2</li>
<li><code>wz</code> : 1</li>
<li><code>yz</code> : 1</li>
</ul>
<p>각 점에서의 least cost path를 찾는 문제입니다.<br>
총 <strong>20점</strong> (문제 7: 10점, 문제 8: 10점)</p>
<hr>
<h2 id="7-dijkstras-algorithm-10점">7. Dijkstra’s Algorithm (10점)</h2>
<p><strong>요구사항:</strong><br>
node <code>u</code>에서 출발하여 <strong>Dijkstra’s algorithm</strong>을 사용해 각 노드(<code>t, v, w, x, y, z</code>)까지의 <strong>least cost path</strong>를 찾는 과정을 다음 표에 작성하시오.</p>
<p>만약 동일 Step에서 <strong>비용이 같은 경우</strong>, <strong>알파벳 순서가 빠른 노드를 먼저 선택</strong>합니다.</p>
<h3 id="제시된-표-형식">제시된 표 형식:</h3>
<table>
  <thead>
      <tr>
          <th>Step</th>
          <th>N&rsquo;</th>
          <th>D(t),p(t)</th>
          <th>D(v),p(v)</th>
          <th>D(w),p(w)</th>
          <th>D(x),p(x)</th>
          <th>D(y),p(y)</th>
          <th>D(z),p(z)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>u</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>1</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>2</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>3</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>4</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>5</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>6</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<blockquote>
<ul>
<li><code>D(n)</code> : node <code>n</code>까지의 누적 최소 비용</li>
<li><code>p(n)</code> : 이전(predecessor) 노드</li>
</ul>
</blockquote>
<hr>
<h2 id="8-bellman-ford-algorithm-10점">8. Bellman-Ford Algorithm (10점)</h2>
<p><strong>요구사항:</strong><br>
node <code>u</code>에서 출발하여 <strong>Bellman-Ford algorithm</strong>을 사용하여 hop 수를 증가시키며 각 노드(<code>t, v, w, x, y, z</code>)까지의 <strong>least cost path</strong>를 찾는 과정을 다음 표에 작성하시오.</p>
<p>각 단계에서 어떤 <strong>이웃</strong>(neighbor)에게 전달해야 하는지도 함께 기술하시오.</p>
<h3 id="제시된-표-형식-1">제시된 표 형식:</h3>
<table>
  <thead>
      <tr>
          <th>From u</th>
          <th>Cost to, (to neighbor of u)</th>
          <th>t</th>
          <th>v</th>
          <th>w</th>
          <th>x</th>
          <th>y</th>
          <th>z</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>up to 1 hop</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>up to 2 hops</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>up to 3 hops</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>up to 4 hops</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h1 id="네트워킹-관련-문제-총-20점">네트워킹 관련 문제 (총 20점)</h1>
<h2 id="9-서브넷팅-subnetting-문제-5점">9. 서브넷팅 (Subnetting) 문제 (5점)</h2>
<p><strong>문제:</strong><br>
<code>212.20.100.0/25</code> 네트워크에서 <strong>각 서브넷당 20개의 호스트</strong>가 사용할 수 있도록 <strong>서브넷팅</strong>(Subnetting)을 수행하려고 합니다.<br>
이때, <strong>최대한 많은 서브넷을 생성</strong>하기 위한 조건에 따라 다음 질문에 답하시오.</p>
<h3 id="질문">질문:</h3>
<ol>
<li>생성되는 <strong>최대 서브넷의 개수</strong>는 얼마입니까?</li>
<li>이렇게 만든 모든 서브넷을 사용할 경우, <strong>실제 사용 가능한 최대 호스트의 개수</strong>는 몇 개인가요?</li>
</ol>
<hr>
<h2 id="10-슈퍼네팅-supernetting-문제-5점">10. 슈퍼네팅 (Supernetting) 문제 (5점)</h2>
<p><strong>문제:</strong><br>
<code>212.20.100.0/25</code> 네트워크에 다른 네트워크를 합쳐서 <strong>약 500대 규모의 단일 네트워크</strong>(호스트 수 약 500개)를 만들기 위해 <strong>슈퍼네팅</strong>(Supernetting)을 수행하려고 합니다.</p>
<h3 id="질문-1">질문:</h3>
<ul>
<li>슈퍼네팅에 필요한 <strong>다른 네트워크 주소</strong>와</li>
<li><strong>합쳐진 단일 네트워크 주소</strong>를 <strong>CIDR 표기법</strong>으로 각각 제시하시오.</li>
</ul>
<hr>
<h2 id="11-sdnopenflow-flow-table-문제-5점">11. SDN/OpenFlow Flow Table 문제 (5점)</h2>
<p><strong>문제:</strong><br>
SDN 환경에서 다음과 같은 네트워크 구성이 있습니다:</p>
<ul>
<li>호스트: <code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code></li>
<li>스위치: <code>s1</code>, <code>s2</code>, <code>s3</code></li>
</ul>
<p>호스트 <code>h1</code>과 <code>h2</code>에서 보낸 데이터그램들이 <code>s3</code> 스위치를 거쳐 <code>s2</code>로 보내져, 최종적으로 <code>h3</code> 또는 <code>h4</code>로 전달되도록 하고자 합니다.</p>
<p><code>s3</code> 스위치의 <strong>OpenFlow Flow Table</strong>에 이 기능을 처리할 수 있는 <strong>2개의 엔트리</strong>(match &amp; action)를 작성하시오.</p>
<hr>
<h2 id="12-nat-network-address-translation-문제-5점">12. NAT (Network Address Translation) 문제 (5점)</h2>
<p><strong>문제:</strong><br>
다음 그림과 같은 NAT 라우터가 있다고 가정합니다.</p>
<ul>
<li>내부 네트워크 IP 대역: <code>192.168.0.0/24</code></li>
<li>외부 공인 IP 주소: <code>210.100.10.5</code></li>
<li>포트 번호 할당 범위: <code>4000 ~ 65535</code></li>
</ul>
<p>라우터는 아래와 같은 방식으로 연결된 세 호스트의 패킷을 처리하고 있습니다:</p>
<table>
  <thead>
      <tr>
          <th>호스트</th>
          <th>내부 IP</th>
          <th>외부 목적지 IP</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>H1</td>
          <td>192.168.0.1</td>
          <td>172.16.0.10</td>
      </tr>
      <tr>
          <td>H2</td>
          <td>192.168.0.2</td>
          <td>10.10.10.10</td>
      </tr>
      <tr>
          <td>H3</td>
          <td>192.168.0.3</td>
          <td>8.8.8.8</td>
      </tr>
  </tbody>
</table>
<h3 id="질문-2">질문:</h3>
<ol>
<li>각 호스트가 동시에 동일한 외부 서버(예: <code>8.8.8.8</code>)에 접속할 때, <strong>NAT 테이블</strong>에 저장되어야 하는 정보를 포함한 예시를 작성하시오.</li>
<li>NAT 라우터가 외부에서 들어오는 응답 패킷을 올바른 내부 호스트로 전달하는 방법을 설명하시오.</li>
</ol>
<h2 id="-데이터-전송-시-crcerror-detection-계산-문제">📝 데이터 전송 시 CRC(Error Detection) 계산 문제</h2>
<h3 id="문제-내용">문제 내용</h3>
<p>데이터 <code>D = 10111001010</code>을 전송할 때, <strong>순환 중복 검사</strong>(CRC, Cyclic Redundancy Check)를 사용하여 오류를 탐지하려고 합니다.</p>
<p>이때 사용하는 <strong>생성자</strong>(Generator Polynomial)는 <code>G = 1001</code>입니다.</p>
<h3 id="요구-사항">요구 사항</h3>
<ul>
<li>이 데이터에 <strong>CRC 값을 추가</strong>하기 위해 필요한 <strong>체크섬</strong>(FCS, Frame Check Sequence) 필드 값을 <strong>계산하시오</strong></li>
<li>계산 과정과 결과 값을 명확히 보이시오<br>
(5점)</li>
</ul>
<hr>
<h3 id="-예시-형식">🔍 예시 형식</h3>
<ul>
<li>데이터: <code>D = 10111001010</code></li>
<li>생성자: <code>G = 1001</code> (4비트)</li>
<li>CRC 길이: <code>G의 비트 수 - 1 = 3비트</code></li>
<li>따라서 데이터 뒤에 3개의 0을 붙여서 나눗셈 수행</li>
<li>나머지를 CRC 값으로 하여 데이터에 첨가</li>
</ul>
<h2 id="-네트워킹-관련-문제-정답-및-풀이">📝 네트워킹 관련 문제 정답 및 풀이</h2>
<h3 id="9-서브넷팅-subnetting-문제">9. 서브넷팅 (Subnetting) 문제</h3>
<ol>
<li><strong>최대 서브넷 개수:</strong> <strong>4개</strong></li>
<li><strong>최대 사용 가능 호스트 개수:</strong> <strong>120개</strong></li>
</ol>
<hr>
<h4 id="-풀이-과정">📜 풀이 과정</h4>
<ol>
<li><strong>호스트 비트 계산:</strong> 각 서브넷에 20개의 호스트가 필요하므로, <code>2^h - 2 ≥ 20</code> 공식을 만족하는 호스트 비트(<code>h</code>)를 찾아야 합니다.
<ul>
<li><code>2^h ≥ 22</code> 이므로, <code>h=5</code>가 됩니다 (2^5 = 32). 즉, 각 서브넷은 5개의 호스트 비트를 가져야 합니다.</li>
</ul>
</li>
<li><strong>서브넷 비트 계산:</strong> 주어진 네트워크 <code>212.20.100.0/25</code>는 기본적으로 7개의 호스트 비트(<code>32-25=7</code>)를 가집니다.
<ul>
<li>여기서 새로운 호스트 비트로 5개를 사용하면, 서브넷을 만드는 데 사용할 수 있는 비트는 <code>7 - 5 = 2</code>비트입니다.</li>
</ul>
</li>
<li><strong>최종 계산:</strong>
<ul>
<li><strong>최대 서브넷 수:</strong> <code>2^2 = 4</code>개</li>
<li><strong>서브넷당 사용 가능 호스트 수:</strong> <code>2^5 - 2 = 30</code>개</li>
<li><strong>전체 사용 가능 호스트 수:</strong> <code>30개/서브넷 * 4개 서브넷 = 120</code>개</li>
</ul>
</li>
</ol>
<h3 id="10-슈퍼네팅-supernetting-문제">10. 슈퍼네팅 (Supernetting) 문제</h3>
<ul>
<li><strong>필요한 다른 네트워크 주소:</strong> <code>212.20.101.0/24</code></li>
<li><strong>합쳐진 단일 네트워크 주소:</strong> <code>212.20.100.0/23</code></li>
</ul>
<hr>
<h4 id="-풀이-과정-1">📜 풀이 과정</h4>
<ol>
<li><strong>필요한 호스트 수 계산:</strong> 약 500개의 호스트를 지원하려면 <code>2^H ≥ 500</code>을 만족하는 호스트 비트(<code>H</code>)가 필요합니다.
<ul>
<li><code>2^9 = 512</code>이므로, 총 9개의 호스트 비트가 필요합니다.</li>
</ul>
</li>
<li><strong>슈퍼넷 마스크 결정:</strong> 9개의 호스트 비트를 사용하면 새로운 네트워크의 프리픽스는 <code>32 - 9 = 23</code>이 됩니다. 즉, <code>/23</code> 네트워크를 만들어야 합니다.</li>
<li><strong>네트워크 통합:</strong>
<ul>
<li><code>/23</code> 네트워크는 512개의 IP 주소를 포함하며, 이는 2개의 <code>/24</code> 네트워크를 합친 크기입니다.</li>
<li>주어진 <code>212.20.100.0/25</code>는 <code>212.20.100.0/24</code> 블록에 포함됩니다.</li>
<li><code>212.20.100.0/24</code>와 인접한 블록인 <code>212.20.101.0/24</code>를 합치면 <code>212.20.100.0/23</code> 슈퍼넷이 생성됩니다.</li>
</ul>
</li>
</ol>
<h3 id="11-sdnopenflow-flow-table-문제">11. SDN/OpenFlow Flow Table 문제</h3>
<p><code>s3</code> 스위치의 Flow Table에 다음과 같은 2개의 엔트리를 추가합니다. (h1 IP: <code>10.0.0.1</code>, h2 IP: <code>10.0.0.2</code>로 가정, 포트는 상황에 맞게 가정)</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Entry</strong></td>
          <td><strong>Match (매치 조건)</strong></td>
          <td><strong>Action (동작)</strong></td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td><code>in_port=1</code>, <code>eth_type=0x0800</code>, <code>ipv4_src=10.0.0.1</code></td>
          <td><code>output:2</code></td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td><code>in_port=1</code>, <code>eth_type=0x0800</code>, <code>ipv4_src=10.0.0.2</code></td>
          <td><code>output:2</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="-설명">📜 설명</h4>
<ul>
<li><strong>Match:</strong> <code>s3</code> 스위치로 들어오는 패킷을 검사하는 조건입니다.
<ul>
<li><code>in_port=1</code>: h1, h2가 연결된 방향의 포트에서 들어온 패킷.</li>
<li><code>eth_type=0x0800</code>: IPv4 패킷.</li>
<li><code>ipv4_src</code>: 출발지 IP 주소가 <code>h1</code> 또는 <code>h2</code>인 경우.</li>
</ul>
</li>
<li><strong>Action:</strong> Match 조건이 일치할 때 수행할 동작입니다.
<ul>
<li><code>output:2</code>: <code>s2</code> 스위치와 연결된 2번 포트로 패킷을 전달(Forwarding)합니다.</li>
</ul>
</li>
</ul>
<h3 id="12-nat-network-address-translation-문제">12. NAT (Network Address Translation) 문제</h3>
<ol>
<li><strong>NAT 테이블 예시:</strong> (3개 호스트가 동시에 <code>8.8.8.8:443</code>에 접속하는 경우)</li>
</ol>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>내부 출발지 IP:Port</strong></td>
          <td><strong>외부(공인) 출발지 IP:Port</strong></td>
          <td><strong>외부 목적지 IP:Port</strong></td>
      </tr>
      <tr>
          <td><code>192.168.0.1:1001</code></td>
          <td><code>210.100.10.5:4000</code></td>
          <td><code>8.8.8.8:443</code></td>
      </tr>
      <tr>
          <td><code>192.168.0.2:2002</code></td>
          <td><code>210.100.10.5:4001</code></td>
          <td><code>8.8.8.8:443</code></td>
      </tr>
      <tr>
          <td><code>192.168.0.3:3003</code></td>
          <td><code>210.100.10.5:4002</code></td>
          <td><code>8.8.8.8:443</code></td>
      </tr>
  </tbody>
</table>
<ol start="2">
<li><strong>응답 패킷 전달 방법:</strong> 외부 서버에서 온 응답 패킷이 NAT 라우터의 공인 IP(<code>210.100.10.5</code>)로 도착하면, 라우터는 <strong>패킷의 목적지 포트 번호</strong>를 확인합니다. 예를 들어, 목적지 포트가 <code>4001</code>이라면, 라우터는 NAT 테이블을 조회하여 이 포트가 내부 호스트 <code>192.168.0.2:2002</code>와 매핑된 것을 확인합니다. 그 후, 패킷의 목적지 IP와 포트를 <code>192.168.0.2:2002</code>로 변환하여 해당 내부 호스트에게 정확히 전달합니다.</li>
</ol>
<h3 id="crcerror-detection-계산-문제">CRC(Error Detection) 계산 문제</h3>
<ul>
<li><strong>계산된 CRC 체크섬(FCS) 값:</strong> <strong><code>001</code></strong></li>
</ul>
<hr>
<h4 id="-계산-과정">📜 계산 과정</h4>
<ol>
<li>
<p><strong>준비:</strong> 생성자 <code>G = 1001</code>는 4비트이므로 데이터 <code>D = 10111001010</code> 뒤에 <code>4 - 1 = 3</code>개의 <code>0</code>을 추가합니다.</p>
<ul>
<li>나눗셈 대상 데이터: <code>10111001010000</code></li>
</ul>
</li>
<li>
<p><strong>이진 나눗셈 (XOR 연산):</strong></p>
</li>
</ol>
<pre tabindex="0"><code>          10101100011  &lt;- 몫 (중요하지 않음)
        ____________
    1001 | 10111001010000
           1001
           ----
            01010
             1001
            -----
             00111
              0000
             -----
              01110
               1001
              -----
               01110
                1001
               -----
                01111
                 1001
                -----
                 01100
                  1001
                 -----
                  01010
                   1001
                  -----
                   00110
                    0000
                   -----
                    01100
                     1001
                    -----
                     0101  &lt;- 최종 나머지 (Remainder)
</code></pre><pre><code>**수정된 계산:**
</code></pre>
<pre tabindex="0"><code>          10111001010000
    G=    1001
    XOR   1001
          ----
          001010
           0000
          ----
           1010
           1001
          ----
           00110
            0000
          ----
            1100
            1001
          ----
            1011
            1001
          ----
            0100
             000
          ----
             1000
             1001
          ----
             001  &lt;- 최종 나머지 (Remainder)
</code></pre><ol start="5">
<li><strong>결과:</strong> 계산된 최종 나머지 <code>001</code>이 CRC 체크섬(FCS) 값입니다. 이 값을 원본 데이터 뒤에 붙여 <code>10111001010**001**</code>을 전송합니다.</li>
</ol>
<p>다음은 주어진 내용을 바탕으로 <strong>정리된 마크다운 형식의 문제</strong>입니다:</p>
<hr>
<h1 id="네트워크-구성-및-통신-관련-문제-총-30점">네트워크 구성 및 통신 관련 문제 (총 30점)</h1>
<p>
        <img src="/08.media/20250613142740-1749792460168-image.png" alt=" (Image resource not found)" ></p>
<h2 id="주어진-조건-요약">주어진 조건 요약</h2>
<ul>
<li><strong>S3</strong>: 다른 호스트들이 사용하는 서버</li>
<li><strong>S1</strong>: DNS 서버</li>
<li><strong>S2</strong>: 웹 서버 (<code>www.neighbor.com</code>)</li>
<li><strong>D</strong>: 호스트가 <code>subnet mask 255.255.254.0</code>인 네트워크에 새로 접속</li>
<li>D는 웹 브라우저에서 <code>www.neighbor.com</code>을 요청하는 상황을 기반으로 문제 해결</li>
</ul>
<hr>
<h2 id="13-네트워크-설정-정보-확인-문제-5점">13. 네트워크 설정 정보 확인 문제 (5점)</h2>
<p>D 호스트가 새로 접속한 네트워크에서 인터넷 사용을 위해 네트워크 관련 설정을 시행하고 있습니다.</p>
<h3 id="질문-3">질문:</h3>
<ol>
<li><strong>호스트가 속한 네트워크 주소</strong>(실제 숫자)를 쓰시오.</li>
<li><strong>외부 인터넷과 데이터그램 송수신을 담당할 기기 인터페이스의 주소</strong>를 <strong>CIDR 표기법</strong>으로 쓰시오.</li>
</ol>
<hr>
<h2 id="14-dhcp-request-frame-전송-문제-5점">14. DHCP Request Frame 전송 문제 (5점)</h2>
<p>D 호스트가 새로 접속한 네트워크는 이더넷이며, 인터넷 사용을 위해 <strong>DHCP</strong>를 사용하여 네트워크 관련 설정을 수행합니다.</p>
<h3 id="질문-4">질문:</h3>
<ul>
<li>이때 전송되는 <strong>DHCP Request 메시지가 담긴 Layer 2 프레임</strong>의 <strong>destination 주소</strong>는 무엇입니까?</li>
</ul>
<hr>
<h2 id="15-arp-protocol-활용-문제-5점">15. ARP Protocol 활용 문제 (5점)</h2>
<p>D 호스트가 <code>www.neighbor.com</code>의 IP 주소를 알아내기 위해 응용 계층(Application Layer)의 질의를 보낸 후, 해당 질의가 링크 계층(Link Layer)까지 도달했습니다.</p>
<p>이제 이 질의를 외부 인터넷으로 내보내야 하는 상황입니다.</p>
<p>D 호스트는 외부 인터넷과 데이터그램 송수신을 담당할 기기 인터페이스의 IP 주소는 알고 있지만, <strong>해당 주소에 대응되는 Layer 2 주소</strong>(MAC 주소)는 모르고 있습니다.</p>
<h3 id="질문-5">질문:</h3>
<ol>
<li>이 문제를 해결하기 위해 사용하는 <strong>프로토콜의 정식 명칭</strong>을 쓰시오.</li>
<li>해당 프로토콜을 사용해서 알아낸 <strong>Layer 2 주소</strong>(MAC 주소)를 쓰시오.</li>
</ol>
<hr>
<h2 id="16-dns-질의-응답-패킷의-source-ip-문제-5점">16. DNS 질의 응답 패킷의 Source IP 문제 (5점)</h2>
<p>D 호스트가 <code>www.neighbor.com</code>의 IP 주소를 알아내기 위해 보낸 DNS 질의에 대한 응답 패킷이 <strong>라우터 R2</strong>에 도착했습니다.</p>
<p>이후 R2에서 해당 네트워크 계층(IP Datagram) 패킷을 외부로 보낼 때 사용하는 <strong>source IP 주소</strong>는 무엇입니까?</p>
<hr>
<h2 id="17-tcp-연결-설정-시-ack-segment의-source-layer-2-주소-문제-5점">17. TCP 연결 설정 시 ACK Segment의 Source Layer 2 주소 문제 (5점)</h2>
<p>D 호스트가 <code>www.neighbor.com</code>의 IP 주소를 알아낸 후, 홈페이지 요청을 위한 TCP 연결 설정을 시작했습니다.</p>
<p>이때 전송된 <strong>ACK 세그먼트</strong>(TCP Segment)가 <strong>라우터 R3</strong>에 도착했고, 이후 R3에서 외부로 보내는 <strong>링크 계층</strong>(Layer 2) 프레임에서 사용되는 <strong>source 주소</strong>는 무엇입니까?</p>
<hr>
<h2 id="18-웹-서버-응답-패킷의-destination-layer-2-주소-문제-5점">18. 웹 서버 응답 패킷의 Destination Layer 2 주소 문제 (5점)</h2>
<p>D 호스트의 홈페이지 요청에 대해, 웹 서버(<code>www.neighbor.com</code>)로부터 온 응답 패킷이 <strong>라우터 R2</strong>에 도착했습니다.</p>
<p>이후 R2에서 D 호스트로 보내는 <strong>링크 계층</strong>(Layer 2) 프레임에서 사용되는 <strong>destination 주소</strong>는 무엇입니까?</p>
<hr>
<p>필요하시면 각 문제에 대한 <strong>풀이 예시 및 설명도 함께 제공해 드릴 수 있습니다.</strong><br>
풀이 원하시는 문제 번호를 알려주세요 😊</p>
<p>네, 주어진 네트워크 구성도와 문제를 바탕으로 각 질문에 대한 답변을 정리해 드립니다.</p>
<hr>
<h3 id="13-네트워크-설정-정보-확인-문제"><strong>13. 네트워크 설정 정보 확인 문제</strong></h3>
<ol>
<li>
<p><strong>호스트가 속한 네트워크 주소</strong>: 호스트 D의 IP 주소 <code>110.0.0.2</code>와 서브넷 마스크 <code>255.255.254.0</code>를 AND 연산하면 네트워크 주소를 알 수 있습니다.</p>
<ul>
<li><strong>정답: <code>110.0.0.0</code></strong></li>
</ul>
</li>
<li>
<p><strong>외부 인터넷과 데이터그램 송수신을 담당할 기기(게이트웨이) 인터페이스의 주소</strong>: 호스트 D가 속한 네트워크의 게이트웨이는 라우터 R3입니다. R3의 해당 인터페이스 IP 주소는 <code>110.0.0.1</code>이며, 서브넷 마스크 <code>255.255.254.0</code>는 23비트를 사용하므로 CIDR 표기법으로는 <code>/23</code>입니다.</p>
<ul>
<li><strong>정답: <code>110.0.0.1/23</code></strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="14-dhcp-request-frame-전송-문제"><strong>14. DHCP Request Frame 전송 문제</strong></h3>
<p>DHCP를 통해 IP 주소를 할당받기 전이므로, 호스트 D는 네트워크에 있는 모든 기기에게 요청을 보내기 위해 브로드캐스트 주소를 사용해야 합니다. Layer 2(이더넷) 환경에서의 브로드캐스트 주소는 정해져 있습니다.</p>
<ul>
<li><strong>정답: <code>FF-FF-FF-FF-FF-FF</code></strong></li>
</ul>
<hr>
<h3 id="15-arp-protocol-활용-문제"><strong>15. ARP Protocol 활용 문제</strong></h3>
<ol>
<li>
<p><strong>프로토콜의 정식 명칭</strong>: IP 주소를 이용해 동일 네트워크 내의 상대방 MAC 주소(Layer 2 주소)를 알아내기 위해 사용하는 프로토콜은 주소 결정 프로토콜(ARP)입니다.</p>
<ul>
<li><strong>정답: <code>Address Resolution Protocol (ARP)</code></strong></li>
</ul>
</li>
<li>
<p><strong>알아낸 Layer 2 주소</strong>: D 호스트는 게이트웨이인 R3의 IP 주소(<code>110.0.0.1</code>)에 해당하는 MAC 주소를 알아내야 합니다. 구성도에서 R3의 해당 인터페이스 MAC 주소를 확인할 수 있습니다.</p>
<ul>
<li><strong>정답: <code>2C-DA-5B-FF-E6-AB</code></strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="16-dns-질의-응답-패킷의-source-ip-문제"><strong>16. DNS 질의 응답 패킷의 Source IP 문제</strong></h3>
<p>DNS 서버 S1(<code>100.0.0.5</code>)이 보낸 응답 패킷은 라우터를 거치면서 Layer 2 헤더(MAC 주소)는 계속 바뀌지만, 일반적인 라우팅 환경(NAT가 없다는 가정 하에)에서 Layer 3 헤더의 Source IP와 Destination IP는 바뀌지 않습니다. 따라서 R2를 통과할 때도 패킷의 출발지 IP 주소는 S1의 주소입니다.</p>
<ul>
<li><strong>정답: <code>100.0.0.5</code></strong></li>
</ul>
<hr>
<h3 id="17-tcp-연결-설정-시-ack-segment의-source-layer-2-주소-문제"><strong>17. TCP 연결 설정 시 ACK Segment의 Source Layer 2 주소 문제</strong></h3>
<p>ACK 세그먼트가 R3에 도착하여 외부 인터넷(R2 방향)으로 나갈 때, R3는 새로운 Layer 2 프레임을 만듭니다. 이때 프레임의 출발지(source) 주소는 패킷을 내보내는 R3 인터페이스의 MAC 주소가 됩니다.</p>
<ul>
<li><strong>정답: <code>00-A0-CC-23-AF-4A</code></strong></li>
</ul>
<hr>
<h3 id="18-웹-서버-응답-패킷의-destination-layer-2-주소-문제"><strong>18. 웹 서버 응답 패킷의 Destination Layer 2 주소 문제</strong></h3>
<p>문제의 시나리오(웹 서버 S2의 응답이 R2에 도착)는 실제 구성과 맞지 않지만, 질문의 의도(&ldquo;라우터를 거쳐 D 호스트에게 최종적으로 전달되는 프레임의 목적지&rdquo;)를 고려하여 풀이합니다. 외부에서 온 패킷이 마지막 라우터(R3)를 거쳐 최종 목적지인 호스트 D에게 전달될 때, 이 마지막 구간에서 사용되는 Layer 2 프레임의 목적지 주소는 호스트 D의 MAC 주소입니다.</p>
<ul>
<li><strong>정답: <code>88-82-2F-54-1A-0F</code></strong></li>
</ul>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
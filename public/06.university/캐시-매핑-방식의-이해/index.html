<!DOCTYPE html>

<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>캐시 매핑 방식의 이해 | My Test Site</title>
    

    
    
    <meta name="description" content="공통 시스템 환경 설정 주기억장치 용량: 4KB (4096 바이트). 따라서 주소는 12비트가 필요합니다 (212=4096). 워드(Word)의 크기: 4 바이트. (32비트 시스템에서 흔히 볼 수 있는 구조) 블록(Block) 및 캐시 라인(Line) 크기: 4 워드 …">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/06.university/%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9D%B4%ED%95%B4/">

    
    
    
    <meta property="og:title" content="캐시 매핑 방식의 이해">
    <meta property="og:description" content="공통 시스템 환경 설정 주기억장치 용량: 4KB (4096 바이트). 따라서 주소는 12비트가 필요합니다 (212=4096). 워드(Word)의 크기: 4 바이트. (32비트 시스템에서 흔히 볼 수 있는 구조) 블록(Block) 및 캐시 라인(Line) 크기: 4 워드 …">
    <meta property="og:url" content="http://localhost:1313/06.university/%EC%BA%90%EC%8B%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9D%B4%ED%95%B4/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="캐시 매핑 방식의 이해">
    <meta name="twitter:description" content="공통 시스템 환경 설정 주기억장치 용량: 4KB (4096 바이트). 따라서 주소는 12비트가 필요합니다 (212=4096). 워드(Word)의 크기: 4 바이트. (32비트 시스템에서 흔히 볼 수 있는 구조) 블록(Block) 및 캐시 라인(Line) 크기: 4 워드 …">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>캐시 매핑 방식의 이해 **page.html**</h1>
    <h3 id="공통-시스템-환경-설정"><strong>공통 시스템 환경 설정</strong></h3>
<ul>
<li><strong>주기억장치 용량</strong>: 4KB (4096 바이트). 따라서 주소는 <strong>12비트</strong>가 필요합니다 (212=4096).</li>
<li><strong>워드(Word)의 크기</strong>: <strong>4 바이트</strong>. (32비트 시스템에서 흔히 볼 수 있는 구조)</li>
<li><strong>블록(Block) 및 캐시 라인(Line) 크기</strong>: 4 워드. 즉, 4워드×4바이트/워드=16바이트 입니다.</li>
<li><strong>캐시 메모리 크기</strong>: 256 바이트.</li>
<li><strong>캐시 라인의 수</strong>: 256바이트/16바이트/라인=16개의 라인을 가집니다.</li>
</ul>
<p>메모리 주소는 <strong>12비트</strong>이며, 이 주소를 어떻게 <code>Tag</code>, <code>Line(or Set)</code>, <code>Word(or Offset)</code> 필드로 나누는지가 각 사상 방식의 핵심입니다.</p>
<ul>
<li><strong>Word(Offset) 필드</strong>: 블록 크기가 16바이트이므로, 블록 내 특정 바이트를 가리키기 위해 log2​(16)=4비트가 필요합니다.</li>
</ul>
<hr>
<h3 id="-1-직접-사상-방식-direct-mapping">## 1. 직접 사상 방식 (Direct Mapping)</h3>
<p>직접 사상 방식에서는 주기억장치의 각 블록이 캐시의 정해진 <strong>단 하나의 라인</strong>에만 저장될 수 있습니다.</p>
<ul>
<li>
<p><strong>주소 구조</strong></p>
<ul>
<li>캐시 라인이 16개이므로, 라인 번호를 지정하기 위해 log2​(16)=4비트가 필요합니다 (<code>Line</code> 필드).</li>
<li>나머지 비트는 <code>Tag</code>가 됩니다: 12−4(Line)−4(Word)=4비트.</li>
</ul>
<p>| Tag (4비트) | Line (4비트) | Word (4비트) |</p>
<p>| :&mdash;&mdash;&mdash;: | :&mdash;&mdash;&mdash;-: | :&mdash;&mdash;&mdash;-: |</p>
</li>
<li>
<p><strong>동작 예시</strong></p>
<ol>
<li>CPU가 메모리 주소 <strong>150번지</strong>(<code>0000 1001 0110</code>₂)의 데이터를 요청합니다.</li>
<li>주소를 분해합니다:
<ul>
<li><strong>Tag</strong>: <code>0000</code></li>
<li><strong>Line</strong>: <code>1001</code> (9번 라인)</li>
<li><strong>Word</strong>: <code>0110</code></li>
</ul>
</li>
<li>캐시는 <strong>9번 라인</strong>으로 가서 Tag를 확인합니다.</li>
<li>만약 9번 라인의 Tag가 <code>0000</code>과 일치하면 **캐시 히트(Hit)**가 발생하고, 해당 블록의 6번째(<code>0110</code>₂) 바이트를 CPU에 전달합니다.</li>
<li>Tag가 다르거나 라인이 비어있으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치의 150번지가 포함된 블록(9번 블록, 144~159번지)을 통째로 가져와 캐시의 9번 라인에 저장하고, Tag 필드를 <code>0000</code>으로 갱신합니다.</li>
</ol>
</li>
</ul>
<hr>
<h3 id="-2-완전-연관-사상-방식-fully-associative-mapping">## 2. 완전 연관 사상 방식 (Fully Associative Mapping)</h3>
<p>완전 연관 사상 방식에서는 주기억장치의 블록이 캐시의 <strong>어떤 라인으로든</strong> 저장될 수 있습니다.</p>
<ul>
<li>
<p><strong>주소 구조</strong></p>
<ul>
<li>정해진 라인이 없으므로 <code>Line</code> 필드가 없습니다.</li>
<li>Tag가 주소의 대부분을 차지합니다: 12−4(Word)=8비트.</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Tag (8비트)</th>
          <th style="text-align: center">Word (4비트)</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</li>
<li>
<p><strong>동작 예시</strong></p>
<ol>
<li>CPU가 메모리 주소 <strong>150번지</strong>(<code>0000 1001 0110</code>₂)의 데이터를 요청합니다.</li>
<li>주소를 분해합니다:
<ul>
<li><strong>Tag</strong>: <code>0000 1001</code></li>
<li><strong>Word</strong>: <code>0110</code></li>
</ul>
</li>
<li>캐시는 <strong>모든 16개 라인의 Tag를 동시에 비교</strong>하여 <code>0000 1001</code>과 일치하는 Tag가 있는지 찾습니다.</li>
<li>일치하는 Tag를 찾으면 **캐시 히트(Hit)**가 발생하고, 해당 블록의 6번째(<code>0110</code>₂) 바이트를 CPU에 전달합니다.</li>
<li>일치하는 Tag가 없으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치에서 해당 블록(144~159번지)을 가져와 캐시의 <strong>비어있는 아무 라인</strong>에 저장합니다. 만약 빈 라인이 없다면, 특정 교체 정책(예: LRU)에 따라 기존 라인 중 하나를 교체합니다.</li>
</ol>
</li>
</ul>
<hr>
<h3 id="-3-세트-연관-사상-방식-set-associative-mapping">## 3. 세트 연관 사상 방식 (Set-Associative Mapping)</h3>
<p>세트 연관 사상은 직접 사상과 완전 연관 사상을 절충한 방식입니다. 캐시 라인들을 여러 개의 **세트(Set)**로 묶고, 블록은 정해진 세트 안의 어떤 라인으로든 저장될 수 있습니다.</p>
<p>여기서는 <strong>2-Way 세트 연관 사상</strong>을 예시로 들겠습니다. (하나의 세트가 2개의 라인을 가짐)</p>
<ul>
<li>
<p><strong>세트 계산</strong></p>
<ul>
<li>세트의 수 = 라인 수 / Way 수 = 16/2=8개의 세트.</li>
</ul>
</li>
<li>
<p><strong>주소 구조</strong></p>
<ul>
<li>세트 번호를 지정하기 위해 log2​(8)=3비트가 필요합니다 (<code>Set</code> 필드).</li>
<li>나머지 비트는 <code>Tag</code>가 됩니다: 12−3(Set)−4(Word)=5비트.</li>
</ul>
<p>| Tag (5비트) | Set (3비트) | Word (4비트) |</p>
<p>| :&mdash;&mdash;&mdash;: | :&mdash;&mdash;&mdash;: | :&mdash;&mdash;&mdash;-: |</p>
</li>
<li>
<p><strong>동작 예시</strong></p>
<ol>
<li>CPU가 메모리 주소 <strong>150번지</strong>(<code>0000 1001 0110</code>₂)의 데이터를 요청합니다.</li>
<li>주소를 분해합니다:
<ul>
<li><strong>Tag</strong>: <code>0000 1</code></li>
<li><strong>Set</strong>: <code>001</code> (1번 세트)</li>
<li><strong>Word</strong>: <code>0110</code></li>
</ul>
</li>
<li>캐시는 <strong>1번 세트</strong>로 갑니다. 1번 세트에는 2개의 라인이 있습니다.</li>
<li>이 <strong>두 라인의 Tag만</strong>을 비교하여 <code>0000 1</code>과 일치하는지 확인합니다.</li>
<li>일치하는 Tag를 찾으면 **캐시 히트(Hit)**가 발생합니다.</li>
<li>일치하는 Tag가 없으면 **캐시 미스(Miss)**가 발생합니다. 주기억장치에서 해당 블록을 가져와 <strong>1번 세트 내의 비어있는 라인</strong>에 저장합니다. 만약 1번 세트의 두 라인이 모두 사용 중이라면, 교체 정책에 따라 둘 중 하나를 교체합니다.</li>
</ol>
</li>
</ul>
<hr>
<h3 id="-요약-비교">## 요약 비교</h3>
<table>
  <thead>
      <tr>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>구분</strong></td>
          <td><strong>주소 구조 (Tag-Index-Offset)</strong></td>
          <td><strong>특징</strong></td>
          <td><strong>장점</strong></td>
          <td><strong>단점</strong></td>
      </tr>
      <tr>
          <td><strong>직접 사상</strong></td>
          <td>4 - 4 - 4</td>
          <td>블록 → 특정 라인 (1:1)</td>
          <td>구현이 간단하고 빠름</td>
          <td>특정 라인에 충돌이 잦음 (Conflict Miss)</td>
      </tr>
      <tr>
          <td><strong>완전 연관</strong></td>
          <td>8 - 없음 - 4</td>
          <td>블록 → 모든 라인 (1:N)</td>
          <td>매우 유연하여 히트율이 높음</td>
          <td>모든 태그를 비교해야 하므로 회로가 복잡하고 비쌈</td>
      </tr>
      <tr>
          <td><strong>세트 연관</strong></td>
          <td>5 - 3 - 4</td>
          <td>블록 → 특정 세트 (1:K)</td>
          <td>직접 사상과 완전 연관의 장점을 절충함</td>
          <td>직접 사상보다 복잡하고 완전 연관보다 히트율이 낮을 수 있음</td>
      </tr>
  </tbody>
</table>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/signal-%EC%B0%A8%EC%9D%B4-unixmacos-vs-linux/">signal 차이 unix(macos) vs linux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B5%AC%EC%A1%B0-%EB%B3%80%ED%99%94-%EC%97%AD%EC%82%AC/">백엔드 구조 변화 역사</a></li>
            
            <li><a href="http://localhost:1313/%EC%BD%94%EC%96%B4-%EB%8D%A4%ED%94%84core-dump/">코어 덤프(Core Dump)</a></li>
            
            <li><a href="http://localhost:1313/copilot/copilot-custom-prompts/translate-to-chinese/">Translate to Chinese</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>
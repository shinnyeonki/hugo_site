<!DOCTYPE html>

<html lang="ko-KR"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    <title>터미널 command line shell | My Test Site</title>
    

    
    
    <meta name="description" content="리눅스 콘솔 환경에서 shell 의 관한 정보">

    
    
    <meta name="robots" content="index, follow">
    

    
    <link rel="canonical" href="http://localhost:1313/temp/%ED%84%B0%EB%AF%B8%EB%84%90-command-line-shell/">

    
    
    
    <meta property="og:title" content="터미널 command line shell">
    <meta property="og:description" content="리눅스 콘솔 환경에서 shell 의 관한 정보">
    <meta property="og:url" content="http://localhost:1313/temp/%ED%84%B0%EB%AF%B8%EB%84%90-command-line-shell/">
    <meta property="og:site_name" content="My Test Site">
    
    <meta property="og:type" content="blog">
    

    
    
    

    
    
    
    <meta name="twitter:card" content="summary_large_image">
    
    <meta name="twitter:title" content="터미널 command line shell">
    <meta name="twitter:description" content="리눅스 콘솔 환경에서 shell 의 관한 정보">
    

    
    
    

    
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>

</head><body>
    
     
    <header class="site-header">
        <div class="site-title">
            <a href="http://localhost:1313/">My Test Site</a>
        </div>
    </header>
    
    <nav class="site-nav">
        <ul>
            
        </ul>
    </nav>
    
    <main>
        
        
<article class="prose prose-sm lg:prose-base max-w-3xl mx-auto dk:prose-stone">
    <h1>터미널 command line shell **page.html**</h1>
    <p>터미널 command line 이라고 한정하여 shell 이라고 말한다면
일반적으로 /dev 파일 내부에 터미널 드라이브 장치를 통해 사용되는 shell 을 말한다 즉![[../08.media/20231223130204.png|login shell vs non-login shell-20231223130204]]2020231223130204.png)</p>
<h2 id="분류">분류</h2>
<ul>
<li>login vs non-login : shell 이 다른 셸의 하위 프로세스로 실행되는가</li>
<li>interactive vs non-interactive : 사용자와 상호작용하는가</li>
</ul>
<h2 id="login-shell-vs-non-login-shell">login shell vs non-login shell</h2>
<blockquote>
<p>[!요약]
Login Shell : userid passwd 입력해서 들어가는 방법
Non Longin Shell : 이미 다른 로그인 된 shell 에서 shell 을 fork 형태로 불러내는 방법</p>
</blockquote>
<p>초기에는 자원의 효과적인 사용을 위해서 사용된 개념이다
로그인 셸에서 할 수 있는 최대한의 환경 구성을 미리 해두면 이후 비로그인 셸에서 적게 환경구성을 할 수 있다</p>
<p>로그인 셸은 대화형 세션에서 로그인 할 때 사용자 id 로 실행되는 첫번째 프로세스 이다</p>
<h2 id="interactive-shell-vs-non-interactive-shell">Interactive Shell vs non Interactive Shell</h2>
<p>타 프로그래밍 언어와의 큰 차이이다 interactive Shell 은 python 명령어 입력시 나타나는 것과 비슷한 것으로 사용자 입력을 순차적으로 입력 받을 수 있는 방식이다
이에 반해 non interactive shell 은 <code>python hello.py</code> 같이 실행한다</p>
<h2 id="로그인-셸-비로그인-셸-확인하기">로그인 셸 비로그인 셸 확인하기</h2>
<pre tabindex="0"><code>prompt&gt; echo $0 # 로그인 셸
-bash # &#34;-&#34; is the first character. Therefore, this is a login shell.

prompt&gt; echo $0 # 비 로그인 셸
bash # &#34;-&#34; is NOT the first character. This is a non-login shell.
</code></pre><h2 id="실행순서">실행순서</h2>
<p><code>bash -lx</code> : -l 로그인 셸 -x 디버깅 : 로그인 셸이 실행한 모든 코드를 볼 수 있다</p>
<pre tabindex="0"><code>로그인 셸
1) /etc/profile
2) ~/.bash_profile    or    ~/.bash_login    or    ~/.profile

비로그인 셸
로그인 셸의 속성중 상속을 받을 수 있는 속성만 상속후
3) /etc/bashrc (우분투는 bash.bashrc)
4) ~/.bashrc
</code></pre><p>하지만 현실은&hellip; (우분투 기준)</p>
<pre tabindex="0"><code>if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi
구문으로 인해 
1) /etc/profile
2) ~/.bash_profile    or    ~/.bash_login    or    ~/.profile
3) /etc/bashrc (우분투는 bash.bashrc)
4) ~/.bashrc
순으로 실행된다
</code></pre><pre tabindex="0"><code>&#34;로그인 셸의 속성중 상속을 받을 수 있는 속성만 상속후&#34; 의 의미
ex) root 로 로그인 후 shinnk 로 비로그인 하면 
root의 .profile 설정과 shinnk의 .bashrc 설정을 가지게 된다

사용자 이동시에는 로그인 셸을 사용하자

그렇다면 상속을 받을 수 있는 속성이란 
</code></pre><h2 id="특수-매게-변수">특수 매게 변수</h2>
<ul>
<li><code>$1</code>, <code>$2</code>, <code>$3</code>, &hellip;는 <a href="https://www.gnu.org/software/bash/manual/html_node/Positional-Parameters.html" class="external-link" target="_blank" rel="noopener noreferrer" >위치 매개변수</a> 입니다 .</li>
<li><code>&quot;$@&quot;</code>모든 위치 매개변수의 배열과 유사한 구성입니다 <code>{$1, $2, $3 ...}</code>.</li>
<li><code>&quot;$*&quot;</code>는 모든 위치 매개변수의 IFS 확장입니다 <code>$1 $2 $3 ...</code>.</li>
<li><code>$#</code>위치 매개변수의 수입니다.</li>
<li><code>$-</code>쉘에 설정된 현재 옵션.</li>
<li><code>$$</code>현재 쉘의 pid(서브쉘 아님)</li>
<li><code>$_</code>가장 최근 매개변수(또는 시작 후 즉시 현재 쉘을 시작하는 명령의 절대 경로).</li>
<li><code>$IFS</code>(입력) 필드 구분 기호입니다.</li>
<li><code>$?</code>가장 최근의 포그라운드 파이프라인 종료 상태입니다.</li>
<li><code>$!</code>가장 최근 백그라운드 명령의 PID입니다.</li>
<li><code>$0</code>쉘 또는 쉘 스크립트의 이름입니다</li>
</ul>
<h2 id="셸-옵션-변경">셸 옵션 변경</h2>
<p><code>set</code> 명령과 <code>shopt</code> 명령을 통해 셸의 옵션을 변경할 수 있는데
set 보다 shopt 가 조금더 고급의 추상화된 작업을 제공한다</p>
<h2 id="셸-확장">셸 확장</h2>
<h3 id="brace-expansion">Brace Expansion</h3>
<p>Brace expansion은 중괄호를 사용하여 표현식을 확장하여 여러 아이템을 생성합니다.
예시: <code>echo a{1,2,3}b</code>는 <code>a1b a2b a3b</code>로 확장됩니다.</p>
<h3 id="tilde-expansion">Tilde Expansion</h3>
<p>Tilde expansion은 홈 디렉토리 경로를 나타내는 데 사용됩니다.
예시: <code>cd ~</code>는 사용자의 홈 디렉토리로 이동합니다. <code>echo ~user</code>는 <code>user</code>의 홈 디렉토리 경로를 출력합니다.</p>
<h3 id="parameter-and-variable-expansion">Parameter and Variable Expansion</h3>
<p>변수나 파라미터의 값을 대체합니다.
예시: <code>name=&quot;World&quot;; echo Hello, $name!</code>는 <code>Hello, World!</code>로 확장됩니다.</p>
<h3 id="command-substitution">Command Substitution</h3>
<p>명령어의 실행 결과를 대체합니다.
예시: <code>echo &quot;Today is $(date)&quot;</code>는 <code>Today is</code>와 <code>date</code> 명령어의 실행 결과로 확장됩니다.</p>
<h3 id="arithmetic-expansion">Arithmetic Expansion</h3>
<p>산술 연산의 결과를 계산하여 대체합니다.
예시: <code>echo $((2 + 3))</code>는 <code>5</code>로 확장됩니다.</p>
<h3 id="word-splitting">Word Splitting</h3>
<p>변수의 값을 IFS(Internal Field Separator)에 따라 단어로 나눕니다.
예시: <code>name=&quot;one two three&quot;; echo $name</code>는 <code>one</code>, <code>two</code>, <code>three</code>로 나누어 출력합니다. 이는 IFS의 기본값이 공백, 탭, 개행 문자임을 반영합니다.</p>
<h3 id="filename-expansion">Filename Expansion</h3>
<p>와일드카드를 사용하여 파일 이름을 확장합니다.
예시: <code>echo *.txt</code>는 현재 디렉토리의 모든 <code>.txt</code> 파일 명을 출력합니다.
각 확장 방식은 스크립트를 보다 유연하고 강력하게 만들어주는 도구입니다. 적절히 사용하면 복잡한 작업을 간단하게 수행할 수 있습니다.</p>
<h3 id="process-substitution-프로세스-치환">Process Substitution (프로세스 치환)</h3>
<p>프로세스의 입력이나 출력을 파일명을 사용하여 참조합니다. 예를 들어, <code>diff &lt;(ls folder1) &lt;(ls folder2)</code>는 두 디렉토리의 리스트를 출력하여 비교합니다.</p>
<h3 id="quote-removal-인용-부호-제거">Quote Removal (인용 부호 제거)</h3>
<p>이스케이프 문자, 인용 부호, 백슬래시의 비인용 인스턴스를 제거합니다. 예를 들어, <code>echo &quot;Hello, \&quot;World\&quot;!&quot;</code>는 <code>Hello, &quot;World&quot;!</code>를 결과로 나타냅니다.</p>

</article>


        
        <footer class="site-footer">
            
            <address>
                
            </address>
            <p>&copy; 2025 My Test Site. All rights reserved.</p>
        </footer>
    </main>

    
    <aside class="sidebar">
        <h3>최근 글</h3>
        <ul>
            
            <li><a href="http://localhost:1313/02.inbox/di-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9D%98-%ED%83%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%A0%91%EA%B7%BC-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8C%93%EA%B8%80/">di (의존성 주입) 의 타 프레임워크 접근 유튜브 댓글</a></li>
            
            <li><a href="http://localhost:1313/%EB%AC%B4%EC%A0%9C-12/">무제 12</a></li>
            
            <li><a href="http://localhost:1313/temp/tmux/">tmux</a></li>
            
            <li><a href="http://localhost:1313/02.inbox/doxyzen-%ED%82%A4%EC%9B%8C%EB%93%9C/">Doxyzen 키워드</a></li>
            
            <li><a href="http://localhost:1313/university-algorizm/">university algorizm</a></li>
            
        </ul>

        <h3>태그</h3>
        
        
    </aside>
</body>
</html>